use crate::derivation::generate_key_iv;
use aes::cipher::{KeyIvInit, StreamCipher};

// Module-specific constants
const AES_BLOCK_SIZE: usize = 16;
const AES_KEY_SIZE: usize = 16;

const PRG_KEY_LENGTH: usize = AES_KEY_SIZE;
const PRG_COUNTER_LENGTH: usize = 4;
const PRG_IV_LENGTH: usize = AES_BLOCK_SIZE - PRG_COUNTER_LENGTH;

const HASH_KEY_PRG: &str = "HASH_KEY_PRG";

type Aes128Ctr32BE = ctr::Ctr32BE<aes::Aes128>;

/// Parameters for the Pseudo-Random Generator (PRG) function
/// This consists of IV and the raw secret key for use by the underlying block cipher.
pub struct PRGParameters {
    key: [u8; PRG_KEY_LENGTH],
    iv: [u8; PRG_IV_LENGTH],
}

impl Default for PRGParameters {
    fn default() -> Self {
        Self {
            key: [0u8; PRG_KEY_LENGTH],
            iv: [0u8; PRG_IV_LENGTH],
        }
    }
}

impl PRGParameters {
    /// Creates new parameters for the PRG by expanding the given
    /// keying material into the secret key and IV for the underlying block cipher.
    pub fn new(secret: &[u8]) -> Self {
        let mut ret = PRGParameters::default();
        generate_key_iv(secret, HASH_KEY_PRG.as_bytes(), &mut ret.key, &mut ret.iv, true)
            .expect("invalid secret given");
        ret
    }
}

impl PRGParameters {
    /// Raw key material for the underlying block cipher
    pub fn key(&self) -> &[u8] {
        &self.key
    }

    /// Initialization vector for the underlying block cipher
    pub fn iv(&self) -> &[u8] {
        &self.iv
    }
}

/// Pseudo-Random Generator (PRG) function that is instantiated
/// using AES-128 block cipher in Counter mode (with 32-bit counter).
/// It forms an infinite sequence of pseudo-random bytes (generated deterministically from the parameters)
/// and can be queried by chunks using the `digest` function.
pub struct PRG {
    params: PRGParameters,
}

impl PRG {
    /// Creates a PRG instance  using the raw key and IV for the underlying block cipher.
    pub fn new(key: &[u8], iv: &[u8]) -> Self {
        assert_eq!(key.len(), PRG_KEY_LENGTH, "invalid key size");
        assert_eq!(iv.len(), PRG_IV_LENGTH, "invalid iv size");

        let mut ret = Self {
            params: PRGParameters::default(),
        };

        ret.params.key.copy_from_slice(key);
        ret.params.iv.copy_from_slice(iv);

        ret
    }

    /// Creates a new PRG instance using the given parameters
    pub fn from_parameters(params: PRGParameters) -> Self {
        Self::new(&params.key, &params.iv) // Correct sizing taken care of by PRGParameters
    }
}

impl PRG {
    /// Gets the chunk of the pseudorandom sequence generated by the PRG
    /// between `from` (incl.) and `to` (excl.) offsets.
    pub fn digest(&self, from: usize, to: usize) -> Box<[u8]> {
        assert!(from < to);

        let first_block = from / AES_BLOCK_SIZE;
        let start = from % AES_BLOCK_SIZE;

        let last_block_end = to % AES_BLOCK_SIZE;
        let last_block = to / AES_BLOCK_SIZE + if last_block_end != 0 { 1 } else { 0 };
        let count_blocks = last_block - first_block;
        let end = AES_BLOCK_SIZE * count_blocks
            - if last_block_end > 0 {
                AES_BLOCK_SIZE - last_block_end
            } else {
                0
            };

        // Allocate required memory
        let mut key_stream = vec![0u8; count_blocks * AES_BLOCK_SIZE];

        // Set correct counter value to the IV
        // NOTE: We are using Big Endian ordering for the counter
        let mut new_iv = [0u8; AES_BLOCK_SIZE];
        let (prefix, counter) = new_iv.split_at_mut(PRG_IV_LENGTH);
        prefix.copy_from_slice(&self.params.iv);
        counter.copy_from_slice(&(first_block as u32).to_be_bytes());

        // Create key stream
        let mut cipher = Aes128Ctr32BE::new(&self.params.key.into(), &new_iv.into());
        cipher.apply_keystream(&mut key_stream);

        // Slice the result accordingly
        let result = &key_stream.as_slice()[start..end];
        result.into()
    }
}

#[cfg(test)]
mod tests {
    use crate::parameters::SECRET_KEY_LENGTH;
    use crate::prg::{PRGParameters, AES_BLOCK_SIZE, AES_KEY_SIZE, PRG};
    use hex_literal::hex;

    #[test]
    fn test_prg_single_block() {
        let key = [0u8; 16];
        let iv = [0u8; 12];

        let out = PRG::new(&key, &iv).digest(5, 10);

        assert_eq!(5, out.len());
    }

    #[test]
    fn test_prg_more_blocks() {
        let key = [0u8; 16];
        let iv = [0u8; 12];

        let out = PRG::new(&key, &iv).digest(0, AES_BLOCK_SIZE * 2);

        assert_eq!(32, out.len());
    }

    #[test]
    fn test_prg_across_blocks() {
        let key = [0u8; 16];
        let iv = [0u8; 12];

        let out = PRG::new(&key, &iv).digest(5, AES_KEY_SIZE * 2 + 10);

        assert_eq!(AES_BLOCK_SIZE * 2 + 5, out.len());
    }

    #[test]
    fn test_prg_parameters() {
        let expected_key = hex!("c642ceb7af7a65308ab2dbff9f6c7132");
        let expected_iv = hex!("a735d1806513af957dd25de7");

        let secret = [0u8; SECRET_KEY_LENGTH];
        let params = PRGParameters::new(&secret);

        assert_eq!(expected_key, params.key);
        assert_eq!(expected_iv, params.iv)
    }
}
