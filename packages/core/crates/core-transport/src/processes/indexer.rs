use async_lock::RwLock;
use core_crypto::types::OffchainPublicKey;
use core_ethereum_db::traits::HoprCoreEthereumDbActions;
use core_network::{network::Network, PeerId};
use core_p2p::libp2p_swarm::derive_prelude::Multiaddr;
use futures::{channel::mpsc::Sender, future::poll_fn, StreamExt};
use std::{pin::Pin, sync::Arc};
use utils_log::{error, warn};
use utils_types::traits::PeerIdLike;

#[cfg(any(not(feature = "wasm"), test))]
use async_std::task::spawn_local;

use core_ethereum_types::chain_events::NetworkRegistryStatus;
#[cfg(all(feature = "wasm", not(test)))]
use wasm_bindgen_futures::spawn_local;

use crate::adaptors::network::ExternalNetworkInteractions;

/// Maximum queue size for events generated by the indexer mechanism
pub const INDEXER_UPDATE_QUEUE_SIZE: usize = 4096;

#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum PeerEligibility {
    Eligible,
    Ineligible,
}

impl From<NetworkRegistryStatus> for PeerEligibility {
    fn from(value: NetworkRegistryStatus) -> Self {
        match value {
            NetworkRegistryStatus::Allowed => Self::Eligible,
            NetworkRegistryStatus::Denied => Self::Ineligible,
        }
    }
}

pub enum IndexerToProcess {
    EligibilityUpdate(PeerId, PeerEligibility),
    RegisterStatusUpdate,
    Announce(PeerId, Vec<Multiaddr>),
}

#[derive(Debug)]
pub enum IndexerProcessed {
    Allow(PeerId),
    Ban(PeerId),
    Announce(PeerId, Vec<Multiaddr>),
}

/// Implementor interface for indexer actions
///
/// The `IndexerActions` object creates a background `async` loop that ensures
/// reading of events generated by the WASM exposed external functions and processing them
/// into channel events processable by the business logic mechanism of HOPRd.
#[derive(Debug, Clone)]
pub struct IndexerActions {
    internal_emitter: Sender<IndexerToProcess>,
}

impl IndexerActions {
    pub fn new<Db>(
        db: Arc<RwLock<Db>>,
        network: Arc<RwLock<Network<ExternalNetworkInteractions>>>,
        emitter: Sender<IndexerProcessed>,
    ) -> Self
    where
        Db: HoprCoreEthereumDbActions + 'static,
    {
        let (to_process_tx, mut to_process_rx) =
            futures::channel::mpsc::channel::<IndexerToProcess>(INDEXER_UPDATE_QUEUE_SIZE);

        spawn_local(async move {
            let mut emitter = emitter;
            let db_local: Arc<RwLock<Db>> = db.clone();

            while let Some(value) = to_process_rx.next().await {
                let event = match value {
                    IndexerToProcess::EligibilityUpdate(peer, eligibility) => match eligibility {
                        PeerEligibility::Eligible => IndexerProcessed::Allow(peer),
                        PeerEligibility::Ineligible => {
                            (*network.write().await).remove(&peer);
                            IndexerProcessed::Ban(peer)
                        }
                    },
                    IndexerToProcess::Announce(peer, multiaddress) => IndexerProcessed::Announce(peer, multiaddress),
                    // TODO: when is this even triggered? network registry missing?
                    IndexerToProcess::RegisterStatusUpdate => {
                        let peers = (*network.read().await).get_all_peers();

                        for peer in peers.into_iter() {
                            let is_allowed = {
                                let address = {
                                    if let Ok(key) = OffchainPublicKey::from_peerid(&peer) {
                                        match db_local.read().await.get_chain_key(&key).await.and_then(
                                            |maybe_address| {
                                                maybe_address.ok_or(utils_db::errors::DbError::GenericError(format!(
                                                    "No address available for peer '{}'",
                                                    peer
                                                )))
                                            },
                                        ) {
                                            Ok(v) => v,
                                            Err(e) => {
                                                error!("{e}");
                                                continue;
                                            }
                                        }
                                    } else {
                                        warn!("Could not convert the peer id '{}' to an offchain public key", peer);
                                        continue;
                                    }
                                };

                                match db_local.read().await.is_allowed_to_access_network(&address).await {
                                    Ok(v) => v,
                                    Err(_) => continue,
                                }
                            };

                            let event = if is_allowed {
                                IndexerProcessed::Allow(peer)
                            } else {
                                (*network.write().await).remove(&peer);
                                IndexerProcessed::Ban(peer)
                            };

                            match poll_fn(|cx| Pin::new(&mut emitter).poll_ready(cx)).await {
                                Ok(_) => match emitter.start_send(event) {
                                    Ok(_) => {}
                                    Err(e) => error!("Failed to emit an indexer event: {}", e),
                                },
                                Err(e) => {
                                    warn!("The receiver for processed indexer events no longer exists: {}", e);
                                }
                            };
                        }
                        continue;
                    }
                };

                match poll_fn(|cx| Pin::new(&mut emitter).poll_ready(cx)).await {
                    Ok(_) => match emitter.start_send(event) {
                        Ok(_) => {}
                        Err(e) => error!("Failed to emit an indexer event: {}", e),
                    },
                    Err(e) => {
                        warn!("The receiver for processed indexer events no longer exists: {}", e);
                    }
                };
            }
        });

        Self {
            internal_emitter: to_process_tx,
        }
    }
}

impl IndexerActions {
    pub async fn emit_indexer_update(&self, event: IndexerToProcess) {
        let mut internal_emitter = self.internal_emitter.clone();

        match poll_fn(|cx| Pin::new(&mut internal_emitter).poll_ready(cx)).await {
            Ok(_) => match internal_emitter.start_send(event) {
                Ok(_) => {}
                Err(e) => error!("Failed to send register update 'eligibility' to the receiver: {}", e),
            },
            Err(e) => error!("The receiver for indexer updates was dropped: {}", e),
        }
    }
}
