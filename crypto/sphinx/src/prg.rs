use aes::cipher::{KeyIvInit, StreamCipher};
use chacha20::ChaCha20;
use chacha20::cipher::StreamCipherSeek;
use hopr_crypto_types::primitives::SecretKey;
use zeroize::ZeroizeOnDrop;

use crate::derivation::generate_key_iv;

/// Abstraction for Pseudo-Random Generator function.
pub trait PRG: for<'a> From<&'a SecretKey> {
    /// Skips `offset` bytes of the pseudorandom sequence generated by the PRG
    /// and then XORs the following bytes of the sequence to the given `buffer`.
    fn apply(&mut self, offset: usize, buffer: &mut [u8]);
}

#[derive(ZeroizeOnDrop)]
pub struct Chacha20PRG(ChaCha20);

impl From<&SecretKey> for Chacha20PRG {
    fn from(value: &SecretKey) -> Self {
        let mut key = chacha20::Key::default();
        let mut iv = chacha20::Nonce::default();
        generate_key_iv(value, HASH_KEY_PRG.as_bytes(), &mut key, &mut iv, true);
        Self(ChaCha20::new(&key, &iv))
    }
}

impl PRG for Chacha20PRG {
    fn apply(&mut self, offset: usize, buffer: &mut [u8]) {
        self.0.seek(offset as u64);
        self.0.apply_keystream(buffer);
    }
}

const HASH_KEY_PRG: &str = "HASH_KEY_PRG";

