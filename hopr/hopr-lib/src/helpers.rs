use std::sync::Arc;

use async_lock::RwLock;
use futures::{Stream, StreamExt, stream};
use hopr_chain_api::SignificantChainEvent;
use hopr_db_node::HoprNodeDb;
use hopr_internal_types::channels::{ChannelChange, ChannelStatus};
use hopr_strategy::strategy::MultiStrategy;
use tracing::info;

use crate::{
    exports::{chain::types::chain_events::ChainEventType, transport::PeerDiscovery},
    prelude::Address,
};

/// Creates a pipeline that chains the indexer-generated data, processes them into
/// the individual components, and creates a filtered output stream that is fed into
/// the transport layer swarm.
///
/// * `event_stream` - represents the events generated by the indexer. If the Indexer is not synced, it will not
///   generate any events.
/// * `preloading_event_stream` - a stream used by the components to preload the data from the objects (db, channel
///   graph...)
#[allow(clippy::too_many_arguments)]
pub fn chain_events_to_transport_events<StreamIn>(
    event_stream: StreamIn,
    me_onchain: Address,
    multi_strategy: Arc<MultiStrategy>,
    channel_graph: Arc<RwLock<hopr_path::channel_graph::ChannelGraph>>,
    db: HoprNodeDb,
) -> impl Stream<Item = PeerDiscovery> + Send + 'static
where
    StreamIn: Stream<Item = SignificantChainEvent> + Send + 'static,
{
    Box::pin(
        event_stream
            .filter_map(move |event| {
                let multi_strategy = multi_strategy.clone();
                let channel_graph = channel_graph.clone();
                let db = db.clone();

                async move {
                    match event.event_type {
                        ChainEventType::Announcement{peer, multiaddresses, ..} => {
                            Some(vec![PeerDiscovery::Announce(peer, multiaddresses), PeerDiscovery::Allow(peer)])
                        }
                        ChainEventType::ChannelOpened(channel) |
                        ChainEventType::ChannelClosureInitiated(channel) |
                        ChainEventType::ChannelClosed(channel) |
                        ChainEventType::ChannelBalanceIncreased(channel, _) | // needed ?
                        ChainEventType::ChannelBalanceDecreased(channel, _) | // needed ?
                        ChainEventType::TicketRedeemed(channel, _) => {   // needed ?
                            let maybe_direction = channel.direction(&me_onchain);

                            let change = channel_graph
                                .write_arc()
                                .await
                                .update_channel(channel);

                            db.invalidate_unrealized_value(&channel).await;

                            // Check if this is our own channel
                            if let Some(own_channel_direction) = maybe_direction {
                                if let Some(change_set) = change {
                                    for channel_change in change_set {
                                        let _ = hopr_strategy::strategy::SingularStrategy::on_own_channel_changed(
                                            &*multi_strategy,
                                            &channel,
                                            own_channel_direction,
                                            channel_change,
                                        )
                                            .await;
                                    }
                                } else if channel.status == ChannelStatus::Open {
                                    // Emit Opening event if the channel did not exist before in the graph
                                    let _ = hopr_strategy::strategy::SingularStrategy::on_own_channel_changed(
                                        &*multi_strategy,
                                        &channel,
                                        own_channel_direction,
                                        ChannelChange::Status {
                                            left: ChannelStatus::Closed,
                                            right: ChannelStatus::Open,
                                        },
                                    )
                                        .await;
                                }
                            }

                            None
                        }
                        ChainEventType::NetworkRegistryUpdate(address, allowed) => {
                            info!(%address, ?allowed, "network registry update received as a no-op");
                            None
                        }
                        ChainEventType::NodeSafeRegistered(safe_address) =>  {
                            info!(%safe_address, "Node safe registered");
                            None
                        }
                    }
                }
            })
            .flat_map(stream::iter),
    )
}
