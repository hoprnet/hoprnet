//! Network and physical transport related utilities
//!
//! This package contains objects and utilities that allow storing and
//! querying the current state of the observable `Network`.
//!
//! Background processes and event updates ensure that the Network data is
//! regularly updated to offer the complete information about each observed
//! peer:
//! 1. the timestamps of last observations
//! 2. quality measurements based on the heartbeat and ping reporting mechanism,
//! 3. individual metrics counting windowed quality characteristics
//! 4. on and off-chain observed peer related data (multiaddresses...)
//!
//! NOTE: This object has not been significantly altered from the previous versions
//! and will be improved in the upcoming releases together with physical transport
//! upgrades that will make it possible to record more data faster. As such, this
//! object should slowly transform into a pollable physical network graph processing
//! live telemetry from the packet transport process.

/// Configuration of the network module.
pub mod config;

/// Errors that can be generated by the crate.
pub mod errors;

/// Implementation of a basic peer store.
pub mod store;

/// Traits representing the network abstraction functionality.
pub mod traits;

/// Observations related to the peer activity in the network.
pub mod track;

mod utils;

pub use libp2p_identity::PeerId;

/// Network health represented with colors, where green is the best and red
/// is the worst possible observed nework quality.
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, strum::Display, strum::EnumString)]
pub enum Health {
    /// Unknown health, on application startup
    Unknown = 0,
    /// No connection, default
    Red = 1,
    /// Low-quality connection to at least 1 public relay
    Orange = 2,
    /// High-quality connection to at least 1 public relay
    Yellow = 3,
    /// High-quality connection to at least 1 public relay and 1 NAT node
    Green = 4,
}

#[cfg(test)]
mod tests {
    use super::Health;
    #[test]
    fn network_health_should_be_ordered_numerically_for_hopr_metrics_output() {
        assert_eq!(Health::Unknown as i32, 0);
        assert_eq!(Health::Red as i32, 1);
        assert_eq!(Health::Orange as i32, 2);
        assert_eq!(Health::Yellow as i32, 3);
        assert_eq!(Health::Green as i32, 4);
    }

    #[test]
    fn network_health_should_serialize_to_a_proper_string() {
        assert_eq!(format!("{}", Health::Orange), "Orange".to_owned())
    }

    #[test]
    fn network_health_should_deserialize_from_proper_string() -> anyhow::Result<()> {
        let parsed: Health = "Orange".parse()?;
        assert_eq!(parsed, Health::Orange);

        Ok(())
    }
}
