//! # P2P
//!
//! The underlying technology for managing the peer-to-peer networking used by this package is the [`rust-libp2p`](https://github.com/libp2p/rust-libp2p) library ([documentation](https://docs.libp2p.io/)).
//!
//! ## Modularity
//!
//! `rust-libp2p` is highly modular allowing for reimplmenting expected behavior using custom implementations for API traits.
//!
//! This way it is possible to experiment with and combine different components of the library in order to construct a specific targeted use case.
//!
//! ## `rust-libp2p` connectivity
//!
//! As per the [official documentation](https://connectivity.libp2p.io/), the connectivity types in the library are divided into the `standalone` (implementation of network over host) and `browser` (implementation of network over browser).
//!
//! Nodes that are not located behind a blocking firewall or NAT are designated as **public nodes** and can utilize the `TCP` or `QUIC` connectivity, with the recommendation to use QUIC if possible.
//!
//! Browser based solutions are almost always located behind a private network or a blocking firewall and to open a connection towards the standalone nodes these utilize either the `WebSocket` approach (by hijacking the `TCP` connection) or the (not yet fully speced up) `WebTransport` (by hijacking the `QUIC` connection).
//!

/// Constants exported by the crate.
pub mod constants;
/// Errors generated by the crate.
pub mod errors;

/// Raw swarm definition for the HOPR network.
pub mod swarm;

/// P2P behavior definitions for the transport level interactions not related to the HOPR protocol
mod behavior;

use futures::Stream;
use libp2p::{swarm::NetworkBehaviour, StreamProtocol};
use serde::{Deserialize, Serialize};
use std::fmt::Debug;
use std::time::Duration;

use core_network::messaging::ControlMessage;
use core_network::network::NetworkTriggeredEvent;
use core_network::ping::PingQueryReplier;
use hopr_internal_types::legacy;
use hopr_internal_types::protocol::Acknowledgement;
use hopr_transport_identity::PeerId;
use hopr_transport_protocol::PeerDiscovery;

use crate::constants::{
    HOPR_ACKNOWLEDGE_PROTOCOL_V_0_1_0, HOPR_HEARTBEAT_PROTOCOL_V_0_1_0, HOPR_MESSAGE_PROTOCOL_V_0_1_0,
    HOPR_TICKET_AGGREGATION_PROTOCOL_V_0_1_0,
};

pub const MSG_ACK_TIMEOUT: std::time::Duration = std::time::Duration::from_secs(1);
// The libp2p internal default is 100. We set the default higher to achieve higher throughput given
// that we use req/resp for single messages.
pub const MSG_ACK_MAX_TOTAL_STREAMS: usize = 200;

/// `Ping` protocol base type for the ping operation
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct Ping(pub ControlMessage);

/// `Ping` protocol base type for the pong operation

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct Pong(pub ControlMessage, pub String);

/// Network Behavior definition for aggregated HOPR network functionality.
///
/// Individual network behaviors from the libp2p perspectives are aggregated
/// under this type in order to create an aggregated network behavior capable
/// of generating events for all component behaviors.
#[derive(NetworkBehaviour)]
#[behaviour(to_swarm = "HoprNetworkBehaviorEvent")]
pub struct HoprNetworkBehavior {
    heartbeat_generator: behavior::heartbeat::Behaviour,
    ticket_aggregation_behavior: behavior::ticket_aggregation::Behaviour,
    pub heartbeat: libp2p::request_response::cbor::Behaviour<Ping, Pong>,
    pub msg: libp2p::request_response::cbor::Behaviour<Box<[u8]>, ()>,
    pub ack: libp2p::request_response::cbor::Behaviour<Acknowledgement, ()>,
    pub ticket_aggregation: libp2p::request_response::cbor::Behaviour<
        Vec<legacy::AcknowledgedTicket>,
        std::result::Result<legacy::Ticket, String>,
    >,
    // WARNING: the order of struct members is important, `discovery` must be the last member,
    // because the request_response components remove the peer from its peer store after a failed
    // dial operation and the discovery mechanism is responsible for populating all peer stores.
    discovery: behavior::discovery::Behaviour,
}

impl Debug for HoprNetworkBehavior {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("HoprNetworkBehavior").finish()
    }
}

impl HoprNetworkBehavior {
    #[allow(clippy::too_many_arguments)]
    pub fn new<T, U, V, W>(
        me: PeerId,
        network_events: T,
        onchain_events: U,
        heartbeat_requests: V,
        ticket_aggregation_processed_events: W,
        hb_timeout: std::time::Duration,
        ticket_aggregation_timeout: std::time::Duration,
    ) -> Self
    where
        T: Stream<Item = NetworkTriggeredEvent> + Send + 'static,
        U: Stream<Item = PeerDiscovery> + Send + 'static,
        V: Stream<Item = (PeerId, PingQueryReplier)> + Send + 'static,
        W: Stream<Item = behavior::ticket_aggregation::Event> + Send + 'static,
    {
        Self {
            discovery: behavior::discovery::Behaviour::new(me, network_events, onchain_events),
            heartbeat_generator: behavior::heartbeat::Behaviour::new(heartbeat_requests),
            ticket_aggregation_behavior: behavior::ticket_aggregation::Behaviour::new(
                ticket_aggregation_processed_events,
            ),
            heartbeat: libp2p::request_response::cbor::Behaviour::<Ping, Pong>::new(
                [(
                    StreamProtocol::new(HOPR_HEARTBEAT_PROTOCOL_V_0_1_0),
                    libp2p::request_response::ProtocolSupport::Full,
                )],
                libp2p::request_response::Config::default().with_request_timeout(hb_timeout),
            ),
            msg: libp2p::request_response::cbor::Behaviour::<Box<[u8]>, ()>::new(
                [(
                    StreamProtocol::new(HOPR_MESSAGE_PROTOCOL_V_0_1_0),
                    libp2p::request_response::ProtocolSupport::Full,
                )],
                libp2p::request_response::Config::default()
                    .with_request_timeout(
                        std::env::var("HOPR_INTERNAL_LIBP2P_MSG_ACK_TIMEOUT_MS")
                            .and_then(|v| {
                                v.parse::<u64>()
                                    .map(Duration::from_millis)
                                    .map_err(|_e| std::env::VarError::NotPresent)
                            })
                            .unwrap_or(MSG_ACK_TIMEOUT),
                    )
                    .with_max_concurrent_streams(
                        std::env::var("HOPR_INTERNAL_LIBP2P_MSG_ACK_MAX_TOTAL_STREAMS")
                            .and_then(|v| v.parse::<usize>().map_err(|_e| std::env::VarError::NotPresent))
                            .unwrap_or(MSG_ACK_MAX_TOTAL_STREAMS),
                    ),
            ),
            ack: libp2p::request_response::cbor::Behaviour::<Acknowledgement, ()>::new(
                [(
                    StreamProtocol::new(HOPR_ACKNOWLEDGE_PROTOCOL_V_0_1_0),
                    libp2p::request_response::ProtocolSupport::Full,
                )],
                libp2p::request_response::Config::default()
                    .with_request_timeout(
                        std::env::var("HOPR_INTERNAL_LIBP2P_MSG_ACK_TIMEOUT_MS")
                            .and_then(|v| {
                                v.parse::<u64>()
                                    .map(Duration::from_millis)
                                    .map_err(|_e| std::env::VarError::NotPresent)
                            })
                            .unwrap_or(MSG_ACK_TIMEOUT),
                    )
                    .with_max_concurrent_streams(
                        std::env::var("HOPR_INTERNAL_LIBP2P_MSG_ACK_MAX_TOTAL_STREAMS")
                            .and_then(|v| v.parse::<usize>().map_err(|_e| std::env::VarError::NotPresent))
                            .unwrap_or(1024 * 10),
                    ),
            ),
            ticket_aggregation: libp2p::request_response::cbor::Behaviour::<
                Vec<legacy::AcknowledgedTicket>,
                std::result::Result<legacy::Ticket, String>,
            >::new(
                [(
                    StreamProtocol::new(HOPR_TICKET_AGGREGATION_PROTOCOL_V_0_1_0),
                    libp2p::request_response::ProtocolSupport::Full,
                )],
                libp2p::request_response::Config::default().with_request_timeout(ticket_aggregation_timeout),
            ),
        }
    }
}

/// Aggregated network behavior event inheriting the component behaviors' events.
///
/// Necessary to allow the libp2p handler to properly distribute the events for
/// processing in the business logic loop.
#[derive(Debug)]
pub enum HoprNetworkBehaviorEvent {
    Discovery(behavior::discovery::Event),
    HeartbeatGenerator(behavior::heartbeat::Event),
    TicketAggregationBehavior(behavior::ticket_aggregation::Event),
    Heartbeat(libp2p::request_response::Event<Ping, Pong>),
    Message(libp2p::request_response::Event<Box<[u8]>, ()>),
    Acknowledgement(libp2p::request_response::Event<Acknowledgement, ()>),
    TicketAggregation(
        libp2p::request_response::Event<Vec<legacy::AcknowledgedTicket>, std::result::Result<legacy::Ticket, String>>,
    ),
    KeepAlive(void::Void),
}

impl From<void::Void> for HoprNetworkBehaviorEvent {
    fn from(event: void::Void) -> Self {
        Self::KeepAlive(event)
    }
}

impl From<behavior::discovery::Event> for HoprNetworkBehaviorEvent {
    fn from(event: behavior::discovery::Event) -> Self {
        Self::Discovery(event)
    }
}

impl From<behavior::heartbeat::Event> for HoprNetworkBehaviorEvent {
    fn from(event: behavior::heartbeat::Event) -> Self {
        Self::HeartbeatGenerator(event)
    }
}

impl From<behavior::ticket_aggregation::Event> for HoprNetworkBehaviorEvent {
    fn from(event: behavior::ticket_aggregation::Event) -> Self {
        Self::TicketAggregationBehavior(event)
    }
}

impl From<libp2p::request_response::Event<Ping, Pong>> for HoprNetworkBehaviorEvent {
    fn from(event: libp2p::request_response::Event<Ping, Pong>) -> Self {
        Self::Heartbeat(event)
    }
}

impl From<libp2p::request_response::Event<Box<[u8]>, ()>> for HoprNetworkBehaviorEvent {
    fn from(event: libp2p::request_response::Event<Box<[u8]>, ()>) -> Self {
        Self::Message(event)
    }
}

impl From<libp2p::request_response::Event<Vec<legacy::AcknowledgedTicket>, std::result::Result<legacy::Ticket, String>>>
    for HoprNetworkBehaviorEvent
{
    fn from(
        event: libp2p::request_response::Event<
            Vec<legacy::AcknowledgedTicket>,
            std::result::Result<legacy::Ticket, String>,
        >,
    ) -> Self {
        Self::TicketAggregation(event)
    }
}

impl From<libp2p::request_response::Event<Acknowledgement, ()>> for HoprNetworkBehaviorEvent {
    fn from(event: libp2p::request_response::Event<Acknowledgement, ()>) -> Self {
        Self::Acknowledgement(event)
    }
}

pub use swarm::HoprSwarm;
