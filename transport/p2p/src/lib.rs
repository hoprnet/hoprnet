//! # P2P
//!
//! The underlying technology for managing the peer-to-peer networking used by this package is the [`rust-libp2p`](https://github.com/libp2p/rust-libp2p) library ([documentation](https://docs.libp2p.io/)).
//!
//! ## Modularity
//!
//! `rust-libp2p` is highly modular allowing for reimplmenting expected behavior using custom implementations for API
//! traits.
//!
//! This way it is possible to experiment with and combine different components of the library in order to construct a
//! specific targeted use case.
//!
//! ## `rust-libp2p` connectivity
//!
//! As per the [official documentation](https://connectivity.libp2p.io/), the connectivity types in the library are divided into the `standalone` (implementation of network over host) and `browser` (implementation of network over browser).
//!
//! Nodes that are not located behind a blocking firewall or NAT are designated as **public nodes** and can utilize the
//! `TCP` or `QUIC` connectivity, with the recommendation to use QUIC if possible.
//!
//! Browser based solutions are almost always located behind a private network or a blocking firewall and to open a
//! connection towards the standalone nodes these utilize either the `WebSocket` approach (by hijacking the `TCP`
//! connection) or the (not yet fully speced up) `WebTransport` (by hijacking the `QUIC` connection).

/// Constants exported by the crate.
pub mod constants;

/// Errors generated by the crate.
pub mod errors;

/// Raw swarm definition for the HOPR network.
pub mod swarm;

/// P2P behavior definitions for the transport level interactions not related to the HOPR protocol
mod behavior;

use std::collections::HashSet;
use std::sync::Arc;

use dashmap::DashSet;
use futures::{AsyncRead, AsyncWrite};
pub use hopr_api::network::Health;
use hopr_api::network::NetworkView;
use libp2p::{Multiaddr, PeerId};

pub use crate::{
    behavior::{HoprNetworkBehavior, HoprNetworkBehaviorEvent},
    swarm::HoprLibp2pNetworkBuilder,
};

#[derive(Clone)]
pub struct HoprNetwork {
    tracker: Arc<DashSet<PeerId>>,
    store: hopr_transport_network::store::NetworkPeerStore,
    control: libp2p_stream::Control,
    protocol: libp2p::StreamProtocol,
}

impl std::fmt::Debug for HoprNetwork {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("HoprNetwork")
            .field("tracker", &self.tracker)
            .field("store", &self.store)
            .field("protocol", &self.protocol)
            .finish()
    }
}

impl NetworkView for HoprNetwork {
    fn listening_as(&self) -> HashSet<Multiaddr> {
        self.store.get(self.store.me()).unwrap_or_else(|| {
            tracing::error!("failed to get own peer info from the peer store");
            std::collections::HashSet::new()
        })
    }

    #[inline]
    fn discovered_peers(&self) -> HashSet<PeerId> {
        self.store.iter_keys().collect()
    }

    #[inline]
    fn connected_peers(&self) -> HashSet<PeerId> {
        self.tracker.iter().map(|r| *r).collect()
    }

    fn is_connected(&self, peer: &PeerId) -> bool {
        self.tracker.contains(peer)
    }

    #[inline]
    fn multiaddress_of(&self, peer: &PeerId) -> Option<HashSet<Multiaddr>> {
        self.store.get(peer)
    }

    fn health(&self) -> Health {
        match self.tracker.len() {
            0 => Health::Red,
            1 => Health::Orange,
            2..4 => Health::Yellow,
            _ => Health::Green,
        }
    }
}

#[async_trait::async_trait]
impl hopr_transport_protocol::stream::BidirectionalStreamControl for HoprNetwork {
    fn accept(
        mut self,
    ) -> Result<impl futures::Stream<Item = (PeerId, impl AsyncRead + AsyncWrite + Send)> + Send, impl std::error::Error>
    {
        self.control.accept(self.protocol)
    }

    async fn open(mut self, peer: PeerId) -> Result<impl AsyncRead + AsyncWrite + Send, impl std::error::Error> {
        self.control.open_stream(peer, self.protocol).await
    }
}
