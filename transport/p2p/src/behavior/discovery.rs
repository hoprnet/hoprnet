//! The discovery mechanism uses an external stimulus to trigger the discovery
//! process on the libp2p side. It is responsible for processing the events
//! generated by other components and passing them to the libp2p swarm in
//! an appropriate format.
use std::collections::{HashMap, HashSet, VecDeque};

use futures::stream::{BoxStream, Stream, StreamExt};
use hopr_network_types::addr::is_public_address;
use hopr_transport_protocol::PeerDiscovery;
use libp2p::{
    Multiaddr, PeerId,
    core::Endpoint,
    swarm::{ConnectionDenied, ConnectionId, DialFailure, NetworkBehaviour, ToSwarm, dummy::ConnectionHandler},
};

#[derive(Debug)]
pub enum DiscoveryInput {
    Indexer(PeerDiscovery),
}

#[derive(Debug)]
pub enum Event {
    IncomingConnection(PeerId, Multiaddr),
    FailedDial(PeerId),
}

pub struct Behaviour {
    me: PeerId,
    events: BoxStream<'static, DiscoveryInput>,
    pending_events: VecDeque<
        libp2p::swarm::ToSwarm<
            <Self as NetworkBehaviour>::ToSwarm,
            <<Self as NetworkBehaviour>::ConnectionHandler as libp2p::swarm::ConnectionHandler>::FromBehaviour,
        >,
    >,
    bootstrap_peers: HashMap<PeerId, Vec<Multiaddr>>,
    connected_peers: HashMap<PeerId, usize>,
}

impl Behaviour {
    pub fn new<T>(me: PeerId, onchain_events: T) -> Self
    where
        T: Stream<Item = PeerDiscovery> + Send + 'static,
    {
        Self {
            me,
            events: Box::pin(onchain_events.map(DiscoveryInput::Indexer)),
            bootstrap_peers: HashMap::new(),
            pending_events: VecDeque::new(),
            connected_peers: HashMap::new(),
        }
    }
}

impl NetworkBehaviour for Behaviour {
    type ConnectionHandler = ConnectionHandler;
    type ToSwarm = Event;

    #[tracing::instrument(
        level = "debug",
        name = "Discovery::handle_established_inbound_connection",
        skip(self),
        fields(transport = "p2p discovery"),
        err(Display)
    )]
    fn handle_established_inbound_connection(
        &mut self,
        connection_id: libp2p::swarm::ConnectionId,
        peer: libp2p::PeerId,
        local_addr: &libp2p::Multiaddr,
        remote_addr: &libp2p::Multiaddr,
    ) -> Result<libp2p::swarm::THandler<Self>, libp2p::swarm::ConnectionDenied> {
        self.pending_events
            .push_back(ToSwarm::GenerateEvent(Event::IncomingConnection(
                peer,
                remote_addr.clone(),
            )));

        Some(Self::ConnectionHandler {}).ok_or_else(|| {
            libp2p::swarm::ConnectionDenied::new(crate::errors::P2PError::Logic(format!(
                "Connection from '{peer}' is not allowed"
            )))
        })
    }

    #[tracing::instrument(
        level = "debug",
        name = "Discovery::handle_pending_outbound_connection"
        skip(self),
        fields(transport = "p2p discovery"),
        ret(Debug),
        err(Display)
    )]
    fn handle_pending_outbound_connection(
        &mut self,
        connection_id: ConnectionId,
        maybe_peer: Option<PeerId>,
        addresses: &[Multiaddr],
        effective_role: Endpoint,
    ) -> Result<Vec<Multiaddr>, ConnectionDenied> {
        if let Some(peer) = maybe_peer {
            // inject the multiaddress of the peer for possible dial usage by stream protocols
            return Ok(self
                .bootstrap_peers
                .get(&peer)
                .map_or(vec![], |addresses| addresses.clone()));
        }

        Ok(vec![])
    }

    #[tracing::instrument(
        level = "trace",
        name = "Discovery::handle_established_outbound_connection",
        skip(self),
        fields(transport = "p2p discovery"),
        err(Display)
    )]
    fn handle_established_outbound_connection(
        &mut self,
        connection_id: libp2p::swarm::ConnectionId,
        peer: libp2p::PeerId,
        addr: &libp2p::Multiaddr,
        role_override: libp2p::core::Endpoint,
        port_use: libp2p::core::transport::PortUse,
    ) -> Result<libp2p::swarm::THandler<Self>, libp2p::swarm::ConnectionDenied> {
        // cannot connect without the handle_ending_outbound_connection being called first
        Ok(Self::ConnectionHandler {})
    }

    #[tracing::instrument(
        level = "debug",
        name = "Discovery::on_swarm_event"
        skip(self),
        fields(transport = "p2p discovery"),
    )]
    fn on_swarm_event(&mut self, event: libp2p::swarm::FromSwarm) {
        match event {
            libp2p::swarm::FromSwarm::ConnectionEstablished(data) => {
                *self.connected_peers.entry(data.peer_id).or_insert(0) += 1
            }
            libp2p::swarm::FromSwarm::ConnectionClosed(data) => {
                let v = self.connected_peers.entry(data.peer_id).or_insert(0);
                if *v > 0 {
                    *v -= 1;
                };
            }
            libp2p::swarm::FromSwarm::DialFailure(DialFailure { peer_id, error, .. }) => {
                tracing::debug!(?peer_id, %error, "Failed to dial peer");

                if let Some(peer) = peer_id {
                    self.pending_events
                        .push_back(ToSwarm::GenerateEvent(Event::FailedDial(peer)));
                }
            }
            _ => {}
        }
    }

    fn on_connection_handler_event(
        &mut self,
        _peer_id: libp2p::PeerId,
        _connection_id: libp2p::swarm::ConnectionId,
        _event: libp2p::swarm::THandlerOutEvent<Self>,
    ) {
        // Nothing is necessary here, because no ConnectionHandler events should be generated
    }

    #[tracing::instrument(
        level = "debug",
        name = "Discovery::poll"
        skip(self, cx),
        fields(transport = "p2p discovery")
    )]
    fn poll(
        &mut self,
        cx: &mut std::task::Context<'_>,
    ) -> std::task::Poll<libp2p::swarm::ToSwarm<Self::ToSwarm, libp2p::swarm::THandlerInEvent<Self>>> {
        if let Some(value) = self.pending_events.pop_front() {
            return std::task::Poll::Ready(value);
        };

        let poll_result = self.events.poll_next_unpin(cx).map(|e| {
            if let Some(DiscoveryInput::Indexer(PeerDiscovery::Announce(peer, multiaddresses))) = e {
                if peer != self.me {
                        let multiaddress_count = multiaddresses.len();
                        tracing::debug!(%peer, addresses = ?&multiaddresses, "Announcement");

                        // Filter out private addresses before adding to pending events and peer store
                        let public_addresses: HashSet<_> = multiaddresses.into_iter()
                            .filter(is_public_address)
                            .collect();

                        let filtered_count = multiaddress_count - public_addresses.len();
                        if filtered_count > 0 {
                            tracing::debug!(%peer, filtered_private_addresses = filtered_count, total_addresses = multiaddress_count, "Filtered out private addresses from announcement");
                        }

                        for multiaddress in &public_addresses {
                            self.pending_events.push_back(ToSwarm::NewExternalAddrOfPeer {
                                peer_id: peer,
                                address: multiaddress.clone(),
                            });
                        }

                        // Only store public addresses in bootstrap_peers
                        if !public_addresses.is_empty() {
                            self.bootstrap_peers.insert(peer, public_addresses.into_iter().collect::<Vec::<_>>());
                        }
                    }
            }
        });

        if matches!(poll_result, std::task::Poll::Pending) {
            std::task::Poll::Pending
        } else if let Some(value) = self.pending_events.pop_front() {
            std::task::Poll::Ready(value)
        } else {
            std::task::Poll::Pending
        }
    }
}
