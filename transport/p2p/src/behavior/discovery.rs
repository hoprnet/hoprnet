//! The discovery mechanism uses an external stimulus to trigger the discovery
//! process on the libp2p side. It is responsible for processing the events
//! generated by other components and passing them to the libp2p swarm in
//! an appropriate format.
use std::{
    cmp::{Ordering, Reverse},
    collections::{BinaryHeap, HashMap, VecDeque},
};

use backon::BackoffBuilder;
use futures::stream::{BoxStream, Stream, StreamExt};
use hopr_transport_protocol::PeerDiscovery;
use libp2p::{
    Multiaddr, PeerId,
    core::Endpoint,
    swarm::{
        ConnectionDenied, ConnectionId, DialFailure, NetworkBehaviour, ToSwarm, dial_opts::DialOpts,
        dummy::ConnectionHandler,
    },
};

#[derive(Debug)]
pub enum DiscoveryInput {
    Indexer(PeerDiscovery),
}

/// Data structure holding the item alongside a release timemestamp.
///
/// The ordering functionality is defined only over the release timestamp.
pub struct Delayed<T> {
    pub release_at: std::time::Instant,
    pub item: T,
}

impl<T> PartialEq for Delayed<T> {
    fn eq(&self, other: &Self) -> bool {
        self.release_at == other.release_at
    }
}

impl<T> PartialOrd for Delayed<T> {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

impl<T> Eq for Delayed<T> {}

impl<T> Ord for Delayed<T> {
    fn cmp(&self, other: &Self) -> Ordering {
        self.release_at.cmp(&other.release_at)
    }
}

impl<T> From<(std::time::Instant, T)> for Delayed<T> {
    fn from(value: (std::time::Instant, T)) -> Self {
        Self {
            release_at: value.0,
            item: value.1,
        }
    }
}

fn initial_backoff() -> backon::ExponentialBackoff {
    backon::ExponentialBuilder::new()
        .with_min_delay(std::time::Duration::from_secs(3))
        .with_max_delay(std::time::Duration::from_secs(120))
        .with_factor(1.5)
        .with_jitter()
        .build()
}

pub struct Behaviour {
    me: PeerId,
    events: BoxStream<'static, DiscoveryInput>,
    pending_events: VecDeque<
        libp2p::swarm::ToSwarm<
            <Self as NetworkBehaviour>::ToSwarm,
            <<Self as NetworkBehaviour>::ConnectionHandler as libp2p::swarm::ConnectionHandler>::FromBehaviour,
        >,
    >,
    bootstrap_peers: HashMap<PeerId, Vec<Multiaddr>>,
    connected_peers: HashMap<PeerId, usize>,
    next_dial_attempts: BinaryHeap<Reverse<Delayed<PeerId>>>,
    not_connected_peers: HashMap<PeerId, backon::ExponentialBackoff>,
}

impl Behaviour {
    pub fn new<T>(me: PeerId, external_discovery_events: T) -> Self
    where
        T: Stream<Item = PeerDiscovery> + Send + 'static,
    {
        Self {
            me,
            events: Box::pin(external_discovery_events.map(DiscoveryInput::Indexer)),
            bootstrap_peers: HashMap::new(),
            pending_events: VecDeque::new(),
            connected_peers: HashMap::new(),
            next_dial_attempts: BinaryHeap::with_capacity(1500),
            not_connected_peers: HashMap::new(),
        }
    }

    fn schedule_dial_with(&mut self, peer: PeerId, mut backoff: backon::ExponentialBackoff) {
        let duration = backoff.next().unwrap_or_else(|| {
            tracing::warn!(%peer, "failed to get next backoff duration, using 10s");
            std::time::Duration::from_secs(10)
        });
        self.not_connected_peers.insert(peer, backoff);
        self.next_dial_attempts.push(Reverse(Delayed {
            release_at: std::time::Instant::now() + duration,
            item: peer,
        }));
    }
}

impl NetworkBehaviour for Behaviour {
    type ConnectionHandler = ConnectionHandler;
    type ToSwarm = ();

    #[tracing::instrument(
        level = "debug",
        name = "Discovery::handle_established_inbound_connection",
        skip(self),
        fields(transport = "p2p discovery"),
        err(Display)
    )]
    fn handle_established_inbound_connection(
        &mut self,
        connection_id: libp2p::swarm::ConnectionId,
        peer: libp2p::PeerId,
        local_addr: &libp2p::Multiaddr,
        remote_addr: &libp2p::Multiaddr,
    ) -> Result<libp2p::swarm::THandler<Self>, libp2p::swarm::ConnectionDenied> {
        Some(Self::ConnectionHandler {}).ok_or_else(|| {
            libp2p::swarm::ConnectionDenied::new(crate::errors::P2PError::Logic(format!(
                "Connection from '{peer}' is not allowed"
            )))
        })
    }

    #[tracing::instrument(
        level = "debug",
        name = "Discovery::handle_pending_outbound_connection"
        skip(self),
        fields(transport = "p2p discovery"),
        ret(Debug),
        err(Display)
    )]
    fn handle_pending_outbound_connection(
        &mut self,
        connection_id: ConnectionId,
        maybe_peer: Option<PeerId>,
        addresses: &[Multiaddr],
        effective_role: Endpoint,
    ) -> Result<Vec<Multiaddr>, ConnectionDenied> {
        if let Some(peer) = maybe_peer {
            // inject the multiaddress of the peer for possible dial usage by stream protocols
            return Ok(self
                .bootstrap_peers
                .get(&peer)
                .map_or(vec![], |addresses| addresses.clone()));
        }

        Ok(vec![])
    }

    #[tracing::instrument(
        level = "trace",
        name = "Discovery::handle_established_outbound_connection",
        skip(self),
        fields(transport = "p2p discovery"),
        err(Display)
    )]
    fn handle_established_outbound_connection(
        &mut self,
        connection_id: libp2p::swarm::ConnectionId,
        peer: libp2p::PeerId,
        addr: &libp2p::Multiaddr,
        role_override: libp2p::core::Endpoint,
        port_use: libp2p::core::transport::PortUse,
    ) -> Result<libp2p::swarm::THandler<Self>, libp2p::swarm::ConnectionDenied> {
        Ok(Self::ConnectionHandler {})
    }

    #[tracing::instrument(
        level = "debug",
        name = "Discovery::on_swarm_event"
        skip(self),
        fields(transport = "p2p discovery"),
    )]
    fn on_swarm_event(&mut self, event: libp2p::swarm::FromSwarm) {
        match event {
            libp2p::swarm::FromSwarm::ConnectionEstablished(data) => {
                *self.connected_peers.entry(data.peer_id).or_insert(0) += 1;
                self.not_connected_peers.remove(&data.peer_id);
            }
            libp2p::swarm::FromSwarm::ConnectionClosed(data) => {
                let v = self.connected_peers.entry(data.peer_id).or_insert(0);
                if *v > 0 {
                    *v -= 1;
                }

                let has_no_more_live_connections = *v == 0;

                if has_no_more_live_connections {
                    self.connected_peers.remove(&data.peer_id);
                    self.schedule_dial_with(data.peer_id, initial_backoff());
                }
            }
            libp2p::swarm::FromSwarm::DialFailure(DialFailure { peer_id, error, .. }) => {
                tracing::debug!(?peer_id, %error, "Failed to dial peer");

                // on a failed dial get the next scheduled dial using the backoff
                if let Some(peer) = peer_id {
                    let backoff = self.not_connected_peers.remove(&peer).unwrap_or_else(|| {
                        tracing::error!(%peer, "no backoff for a failed dial, creating new backoff");
                        initial_backoff()
                    });
                    self.schedule_dial_with(peer, backoff);
                }
            }
            _ => {}
        }
    }

    fn on_connection_handler_event(
        &mut self,
        _peer_id: libp2p::PeerId,
        _connection_id: libp2p::swarm::ConnectionId,
        _event: libp2p::swarm::THandlerOutEvent<Self>,
    ) {
        // Nothing is necessary here, because no ConnectionHandler events should be generated
    }

    #[tracing::instrument(
        level = "debug",
        name = "Discovery::poll"
        skip(self, cx),
        fields(transport = "p2p discovery")
    )]
    fn poll(
        &mut self,
        cx: &mut std::task::Context<'_>,
    ) -> std::task::Poll<libp2p::swarm::ToSwarm<Self::ToSwarm, libp2p::swarm::THandlerInEvent<Self>>> {
        if let Some(value) = self.pending_events.pop_front() {
            return std::task::Poll::Ready(value);
        };

        let poll_result = self.events.poll_next_unpin(cx).map(|e| {
            if let Some(DiscoveryInput::Indexer(PeerDiscovery::Announce(peer, multiaddresses))) = e
                && peer != self.me
            {
                tracing::debug!(%peer, addresses = ?&multiaddresses, "Announcement");

                for multiaddress in &multiaddresses {
                    self.pending_events.push_back(ToSwarm::NewExternalAddrOfPeer {
                        peer_id: peer,
                        address: multiaddress.clone(),
                    });
                }

                // Store announced addresses for later dialing / protocol use
                if !multiaddresses.is_empty() {
                    self.bootstrap_peers.insert(peer, multiaddresses);
                    if !self.connected_peers.contains_key(&peer) {
                        self.schedule_dial_with(peer, initial_backoff());
                    }
                }
            }
        });

        if matches!(poll_result, std::task::Poll::Ready(_))
            && let Some(value) = self.pending_events.pop_front()
        {
            return std::task::Poll::Ready(value);
        }

        let now = std::time::Instant::now();
        while self
            .next_dial_attempts
            .peek()
            .map(|x| x.0.release_at <= now)
            .unwrap_or(false)
        {
            let peer = self
                .next_dial_attempts
                .pop()
                .expect("The value should be present within the same access")
                .0
                .item;

            // Skip stale entries (peer reconnected or was otherwise unscheduled)
            if !self.not_connected_peers.contains_key(&peer) {
                continue;
            }

            tracing::trace!(%peer, "attempting a new dial attempt item");
            self.pending_events.push_back(ToSwarm::Dial {
                opts: DialOpts::peer_id(peer).build(),
            });
        }

        if let Some(value) = self.pending_events.pop_front() {
            std::task::Poll::Ready(value)
        } else {
            std::task::Poll::Pending
        }
    }
}
