//! The discovery mechanism uses an external stimulus to trigger the discovery
//! process on the libp2p side. It is responsible for processing the events
//! generated by other components and passing them to the libp2p swarm in
//! an appropriate format.
use std::collections::{HashMap, HashSet, VecDeque};

use futures::stream::{BoxStream, Stream, StreamExt};
use hopr_transport_protocol::PeerDiscovery;
use libp2p::{
    Multiaddr, PeerId,
    core::Endpoint,
    swarm::{
        CloseConnection, ConnectionDenied, ConnectionId, NetworkBehaviour, ToSwarm, dial_opts::DialOpts,
        dummy::ConnectionHandler,
    },
};
use tracing::{debug, trace};

#[derive(Debug)]
pub enum DiscoveryInput {
    Indexer(PeerDiscovery),
}

#[derive(Debug)]
pub enum Event {}

pub struct Behaviour {
    me: PeerId,
    events: BoxStream<'static, DiscoveryInput>,
    pending_events: VecDeque<
        libp2p::swarm::ToSwarm<
            <Self as NetworkBehaviour>::ToSwarm,
            <<Self as NetworkBehaviour>::ConnectionHandler as libp2p::swarm::ConnectionHandler>::FromBehaviour,
        >,
    >,
    all_peers: HashMap<PeerId, Vec<Multiaddr>>,
    allowed_peers: HashSet<PeerId>,
    connected_peers: HashMap<PeerId, usize>,
}

impl Behaviour {
    pub fn new<T>(me: PeerId, onchain_events: T) -> Self
    where
        T: Stream<Item = PeerDiscovery> + Send + 'static,
    {
        Self {
            me,
            events: Box::pin(onchain_events.map(DiscoveryInput::Indexer)),
            all_peers: HashMap::new(),
            pending_events: VecDeque::new(),
            allowed_peers: HashSet::new(),
            connected_peers: HashMap::new(),
        }
    }

    fn is_peer_connected(&self, peer: &PeerId) -> bool {
        self.connected_peers.get(peer).map(|v| *v > 0).unwrap_or(false)
    }
}

impl NetworkBehaviour for Behaviour {
    type ConnectionHandler = ConnectionHandler;
    type ToSwarm = Event;

    #[tracing::instrument(level = "debug", skip(self), fields(transport = "p2p discovery"), err(Display))]
    fn handle_established_inbound_connection(
        &mut self,
        connection_id: libp2p::swarm::ConnectionId,
        peer: libp2p::PeerId,
        local_addr: &libp2p::Multiaddr,
        remote_addr: &libp2p::Multiaddr,
    ) -> Result<libp2p::swarm::THandler<Self>, libp2p::swarm::ConnectionDenied> {
        if self.allowed_peers.contains(&peer) {
            trace!(%peer, "Discovery::handle_established_inbound_connection in allowed_peers");
            Ok(Self::ConnectionHandler {})
        } else {
            trace!(%peer, "Discovery::handle_established_inbound_connection NOT in allowed_peers");
            Err(libp2p::swarm::ConnectionDenied::new(crate::errors::P2PError::Logic(
                format!("Connection from '{peer}' is not allowed"),
            )))
        }
    }

    #[tracing::instrument(
        level = "debug",
        skip(self),
        fields(transport = "p2p discovery"),
        ret(Debug),
        err(Display)
    )]
    fn handle_pending_outbound_connection(
        &mut self,
        connection_id: ConnectionId,
        maybe_peer: Option<PeerId>,
        addresses: &[Multiaddr],
        effective_role: Endpoint,
    ) -> Result<Vec<Multiaddr>, ConnectionDenied> {
        if let Some(peer) = maybe_peer {
            if self.allowed_peers.contains(&peer) {
                trace!(%peer, "Discovery::handle_pending_outbound_connection in allowed_peers");
                // inject the multiaddress of the peer for possible dial usage by stream protocols
                return Ok(self.all_peers.get(&peer).map_or_else(
                    || {
                        tracing::debug!(%peer, "No multiaddress found for peer");
                        vec![]
                    },
                    |addresses| addresses.clone(),
                ));
            } else {
                trace!(%peer, "Discovery::handle_pending_outbound_connection NOT in allowed_peers");
                return Err(libp2p::swarm::ConnectionDenied::new(crate::errors::P2PError::Logic(
                    format!("Connection to '{peer}' is not allowed"),
                )));
            }
        }

        Ok(vec![])
    }

    #[tracing::instrument(level = "debug", skip(self), fields(transport = "p2p discovery"), err(Display))]
    fn handle_established_outbound_connection(
        &mut self,
        connection_id: libp2p::swarm::ConnectionId,
        peer: libp2p::PeerId,
        addr: &libp2p::Multiaddr,
        role_override: libp2p::core::Endpoint,
        port_use: libp2p::core::transport::PortUse,
    ) -> Result<libp2p::swarm::THandler<Self>, libp2p::swarm::ConnectionDenied> {
        // cannot connect without the handle_ending_outbound_connection being called first
        Ok(Self::ConnectionHandler {})
    }

    fn on_swarm_event(&mut self, event: libp2p::swarm::FromSwarm) {
        match event {
            libp2p::swarm::FromSwarm::ConnectionEstablished(data) => {
                *self.connected_peers.entry(data.peer_id).or_insert(0) += 1
            }
            libp2p::swarm::FromSwarm::ConnectionClosed(data) => {
                let v = self.connected_peers.entry(data.peer_id).or_insert(0);
                if *v > 0 {
                    *v -= 1;
                };
            }
            _ => {}
        }
    }

    fn on_connection_handler_event(
        &mut self,
        _peer_id: libp2p::PeerId,
        _connection_id: libp2p::swarm::ConnectionId,
        _event: libp2p::swarm::THandlerOutEvent<Self>,
    ) {
        // Nothing is necessary here, because no ConnectionHandler events should be generated
    }

    #[tracing::instrument(
        level = "debug",
        name = "poll_on_event",
        skip(self, cx),
        fields(transport = "p2p discovery")
    )]
    fn poll(
        &mut self,
        cx: &mut std::task::Context<'_>,
    ) -> std::task::Poll<libp2p::swarm::ToSwarm<Self::ToSwarm, libp2p::swarm::THandlerInEvent<Self>>> {
        if let Some(value) = self.pending_events.pop_front() {
            return std::task::Poll::Ready(value);
        };

        let poll_result = self.events.poll_next_unpin(cx).map(|e| match e {
            Some(DiscoveryInput::Indexer(event)) => match event {
                PeerDiscovery::Allow(peer) => {
                    let inserted_into_allow_list = self.allowed_peers.insert(peer);
                    debug!(%peer, inserted_into_allow_list, "Discovery::Poll Insert allowed_peers");

                    let multiaddresses = self.all_peers.get(&peer);
                    if let Some(multiaddresses) = self.all_peers.get(&peer) {
                        for address in multiaddresses {
                            self.pending_events.push_back(ToSwarm::NewExternalAddrOfPeer {
                                peer_id: peer,
                                address: address.clone(),
                            });
                        }
                    }

                    tracing::debug!(%peer, inserted_into_allow_list, emitted_libp2p_address_announce = multiaddresses.is_some_and(|v| !v.is_empty()), "Network registry allow");
                }
                PeerDiscovery::Ban(peer) => {
                    let was_allowed = self.allowed_peers.remove(&peer);
                    debug!(%peer, was_allowed, "Discovery::Poll Remove allowed_peers");
                    tracing::debug!(%peer, was_allowed, "Network registry ban");

                    if self.is_peer_connected(&peer) {
                        self.pending_events.push_back(ToSwarm::CloseConnection {
                            peer_id: peer,
                            connection: CloseConnection::default(),
                        });
                        tracing::debug!(%peer, "Requesting disconnect due to ban");
                    }
                }
                PeerDiscovery::Announce(peer, multiaddresses) => {
                    if peer != self.me {
                        tracing::debug!(%peer, addresses = ?&multiaddresses, "Announcement");

                        for multiaddress in &multiaddresses {
                            self.pending_events.push_back(ToSwarm::NewExternalAddrOfPeer {
                                peer_id: peer,
                                address: multiaddress.clone(),
                            });
                        }

                        self.all_peers.insert(peer, multiaddresses.clone());

                        if self.allowed_peers.contains(&peer) {
                            // the dial is performed to create a first connection some time before the heartbeat mechanism
                            // kicks in, otherwise the heartbeat is likely to fail on the first try due to dial and protocol
                            // negotiation taking longer than the request response timeout
                            self.pending_events.push_back(ToSwarm::Dial { opts: DialOpts::peer_id(peer).addresses(multiaddresses).build()});
                        }
                    }
                }
            },
            None => {}
        });

        if matches!(poll_result, std::task::Poll::Pending) {
            std::task::Poll::Pending
        } else if let Some(value) = self.pending_events.pop_front() {
            std::task::Poll::Ready(value)
        } else {
            std::task::Poll::Pending
        }
    }
}
