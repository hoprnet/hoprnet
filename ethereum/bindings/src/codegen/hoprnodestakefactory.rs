/**

Generated by the following Solidity interface...
```solidity
interface HoprNodeStakeFactory {
    error TooFewOwners();

    event NewHoprNodeStakeModule(address indexed moduleImplementation, address instance);
    event NewHoprNodeStakeSafe(address instance);

    constructor();

    function clone(address moduleSingletonAddress, address[] memory admins, uint256 nonce, bytes32 defaultTarget) external returns (address, address payable);
    function predictDeterministicAddress(address implementation, bytes32 salt) external view returns (address predicted);
    function safeVersion() external pure returns (string memory);
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "clone",
    "inputs": [
      {
        "name": "moduleSingletonAddress",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "admins",
        "type": "address[]",
        "internalType": "address[]"
      },
      {
        "name": "nonce",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "defaultTarget",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "",
        "type": "address",
        "internalType": "address payable"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "predictDeterministicAddress",
    "inputs": [
      {
        "name": "implementation",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "salt",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "predicted",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "safeVersion",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "event",
    "name": "NewHoprNodeStakeModule",
    "inputs": [
      {
        "name": "moduleImplementation",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "instance",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "NewHoprNodeStakeSafe",
    "inputs": [
      {
        "name": "instance",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "error",
    "name": "TooFewOwners",
    "inputs": []
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod HoprNodeStakeFactory {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x60a06040523480156200001157600080fd5b5030608081905260408051602081019290925260009082015260600160408051601f19818403018152908290526200005291600160f81b9060200162000078565b6040516020818303038152906040526000908162000071919062000176565b5062000242565b6000835160005b818110156200009b57602081870181015185830152016200007f565b507fff00000000000000000000000000000000000000000000000000000000000000939093169190920190815260010192915050565b634e487b7160e01b600052604160045260246000fd5b600181811c90821680620000fc57607f821691505b6020821081036200011d57634e487b7160e01b600052602260045260246000fd5b50919050565b601f8211156200017157600081815260208120601f850160051c810160208610156200014c5750805b601f850160051c820191505b818110156200016d5782815560010162000158565b5050505b505050565b81516001600160401b03811115620001925762000192620000d1565b620001aa81620001a38454620000e7565b8462000123565b602080601f831160018114620001e25760008415620001c95750858301515b600019600386901b1c1916600185901b1785556200016d565b600085815260208120601f198616915b828110156200021357888601518255948401946001909101908401620001f2565b5085821015620002325787850151600019600388901b60f8161c191681555b5050505050600190811b01905550565b608051610de66200025b60003960005050610de66000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c8063360d0fad146100465780637ef2721f14610076578063930f426a1461009d575b600080fd5b6100596100543660046108ee565b6100d0565b6040516001600160a01b0390911681526020015b60405180910390f35b6040805180820182526005815264312e342e3160d81b6020820152905161006d919061096a565b6100b06100ab366004610993565b6100ee565b604080516001600160a01b0393841681529290911660208301520161006d565b60006100e56001600160a01b0384168361049d565b90505b92915050565b6000808451600003610113576040516306bfe8d560e11b815260040160405180910390fd5b6040516bffffffffffffffffffffffff193360601b1660208201526034810185905260009060540160408051601f1981840301815291905280516020909101209050600061016a6001600160a01b038916836104fd565b905060008760008151811061018157610181610a7b565b60200260200101519050308860008151811061019f5761019f610a7b565b60200260200101906001600160a01b031690816001600160a01b03168152505060008860016000732a15de4410d4c8af0a7b6c12803120f43c42b82060008060006040516024016101f69796959493929190610a91565b60408051601f198184030181529181526020820180516001600160e01b031663b63e800d60e01b17905251631688f0b960e01b8152909150600090734e1dcf7ad4e460cfd30791ccc4f9c8a4f820ec6790631688f0b990610273907341675c099f32341bf84bfc5382af534df5c7461a9086908e90600401610b52565b6020604051808303816000875af1158015610292573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102b69190610b86565b604080516001600160a01b0383166020820152739641d764fc13c8b624c04430c7356c1c7c8102e28183015260608082018c90528251808303909101815260808201909252919250829160009161030f9160a40161096a565b60408051601f198184030181529190526020810180516001600160e01b031663439fab9160e01b179052905061034e6001600160a01b0387168261059f565b506040516001600160a01b038716602482015260009060440160408051601f198184030181529190526020810180516001600160e01b031663610b592560e01b179052905061039f836000836105e3565b604051600160248201523060448201526001600160a01b038716606482015260009060840160408051601f198184030181529190526020810180516001600160e01b031663e318b52b60e01b17905290506103fc846001836105e3565b8e6001600160a01b03167f813d391dc490d6c1dae7d3fdd555f337533d1da2c908c6efd36d4cf557a632068960405161044491906001600160a01b0391909116815260200190565b60405180910390a26040516001600160a01b03861681527f8231d169f416b666ae7fa43faa24a18899738075a53f32c97617d173b189e3869060200160405180910390a150959d919c50909a5050505050505050505050565b6040513060388201526f5af43d82803e903d91602b57fd5bf3ff602482015260148101839052733d602d80600a3d3981f3363d3d373d3d3d363d738152605881018290526037600c820120607882015260556043909101206000906100e5565b6000763d602d80600a3d3981f3363d3d373d3d3d363d730000008360601b60e81c176000526e5af43d82803e903d91602b57fd5bf38360781b1760205281603760096000f590506001600160a01b0381166100e85760405162461bcd60e51b815260206004820152601760248201527f455243313136373a2063726561746532206661696c656400000000000000000060448201526064015b60405180910390fd5b60606100e5838360006040518060400160405280601e81526020017f416464726573733a206c6f772d6c6576656c2063616c6c206661696c6564000081525061074b565b604051631b1a23ef60e31b81526000906001600160a01b0385169063d8d11f7890610624908790859087908290819081908190819033908f90600401610bcc565b602060405180830381865afa158015610641573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106659190610c42565b60405163d4d9bdcd60e01b8152600481018290529091506001600160a01b0385169063d4d9bdcd90602401600060405180830381600087803b1580156106aa57600080fd5b505af11580156106be573d6000803e3d6000fd5b505060405163353b090160e11b81526001600160a01b0387169250636a761202915061070190879060009087908290819081908190819033908290600401610c5b565b6020604051808303816000875af1158015610720573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107449190610d72565b5050505050565b6060824710156107ac5760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f6044820152651c8818d85b1b60d21b6064820152608401610596565b600080866001600160a01b031685876040516107c89190610d94565b60006040518083038185875af1925050503d8060008114610805576040519150601f19603f3d011682016040523d82523d6000602084013e61080a565b606091505b509150915061081b87838387610828565b925050505b949350505050565b60608315610897578251600003610890576001600160a01b0385163b6108905760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e74726163740000006044820152606401610596565b5081610820565b61082083838151156108ac5781518083602001fd5b8060405162461bcd60e51b8152600401610596919061096a565b6001600160a01b03811681146108db57600080fd5b50565b80356108e9816108c6565b919050565b6000806040838503121561090157600080fd5b823561090c816108c6565b946020939093013593505050565b60005b8381101561093557818101518382015260200161091d565b50506000910152565b6000815180845261095681602086016020860161091a565b601f01601f19169290920160200192915050565b6020815260006100e5602083018461093e565b634e487b7160e01b600052604160045260246000fd5b600080600080608085870312156109a957600080fd5b84356109b4816108c6565b935060208581013567ffffffffffffffff808211156109d257600080fd5b818801915088601f8301126109e657600080fd5b8135818111156109f8576109f861097d565b8060051b604051601f19603f83011681018181108582111715610a1d57610a1d61097d565b60405291825284820192508381018501918b831115610a3b57600080fd5b938501935b82851015610a6057610a51856108de565b84529385019392850192610a40565b989b989a505050506040870135966060013595945050505050565b634e487b7160e01b600052603260045260246000fd5b6101008082528851908201819052600090610120830190602090818c01845b82811015610ad55781516001600160a01b031685529383019390830190600101610ab0565b50505060ff8a1684820152506001600160a01b03881660408401528281036060840152600181526000602082015260408101915050610b1f60808301876001600160a01b03169052565b6001600160a01b03851660a083015260ff841660c08301526001600160a01b03831660e083015298975050505050505050565b6001600160a01b0384168152606060208201819052600090610b769083018561093e565b9050826040830152949350505050565b600060208284031215610b9857600080fd5b8151610ba3816108c6565b9392505050565b60028110610bc857634e487b7160e01b600052602160045260246000fd5b9052565b6001600160a01b038b81168252602082018b905261014060408301819052600091610bf98483018d61093e565b9250610c08606085018c610baa565b60808401999099525060a082019690965260c081019490945291851660e08401529093166101008201526101200191909152949350505050565b600060208284031215610c5457600080fd5b5051919050565b600061014060018060a01b03808e16845260208d81860152826040860152610c858386018e61093e565b9250610c94606086018d610baa565b8a60808601528960a08601528860c086015281881660e086015281871661010086015284830361012086015260009150855482600182811c915080831680610cdd57607f831692505b8483108103610cfa57634e487b7160e01b86526022600452602486fd5b828752602087019650808015610d175760018114610d2d57610d58565b60ff198516885283151560051b88019650610d58565b60008b81526020902060005b85811015610d525781548a820152908401908701610d39565b89019750505b50505050505080925050509b9a5050505050505050505050565b600060208284031215610d8457600080fd5b81518015158114610ba357600080fd5b60008251610da681846020870161091a565b919091019291505056fea26469706673582212209886696b2909c8efe81802f6e75fd0d1072e9b57e0ca5680d6168aaf5fae4bc364736f6c63430008130033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\xA0`@R4\x80\x15b\0\0\x11W`\0\x80\xFD[P0`\x80\x81\x90R`@\x80Q` \x81\x01\x92\x90\x92R`\0\x90\x82\x01R``\x01`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x90\x82\x90Rb\0\0R\x91`\x01`\xF8\x1B\x90` \x01b\0\0xV[`@Q` \x81\x83\x03\x03\x81R\x90`@R`\0\x90\x81b\0\0q\x91\x90b\0\x01vV[Pb\0\x02BV[`\0\x83Q`\0[\x81\x81\x10\x15b\0\0\x9BW` \x81\x87\x01\x81\x01Q\x85\x83\x01R\x01b\0\0\x7FV[P\x7F\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x93\x90\x93\x16\x91\x90\x92\x01\x90\x81R`\x01\x01\x92\x91PPV[cNH{q`\xE0\x1B`\0R`A`\x04R`$`\0\xFD[`\x01\x81\x81\x1C\x90\x82\x16\x80b\0\0\xFCW`\x7F\x82\x16\x91P[` \x82\x10\x81\x03b\0\x01\x1DWcNH{q`\xE0\x1B`\0R`\"`\x04R`$`\0\xFD[P\x91\x90PV[`\x1F\x82\x11\x15b\0\x01qW`\0\x81\x81R` \x81 `\x1F\x85\x01`\x05\x1C\x81\x01` \x86\x10\x15b\0\x01LWP\x80[`\x1F\x85\x01`\x05\x1C\x82\x01\x91P[\x81\x81\x10\x15b\0\x01mW\x82\x81U`\x01\x01b\0\x01XV[PPP[PPPV[\x81Q`\x01`\x01`@\x1B\x03\x81\x11\x15b\0\x01\x92Wb\0\x01\x92b\0\0\xD1V[b\0\x01\xAA\x81b\0\x01\xA3\x84Tb\0\0\xE7V[\x84b\0\x01#V[` \x80`\x1F\x83\x11`\x01\x81\x14b\0\x01\xE2W`\0\x84\x15b\0\x01\xC9WP\x85\x83\x01Q[`\0\x19`\x03\x86\x90\x1B\x1C\x19\x16`\x01\x85\x90\x1B\x17\x85Ub\0\x01mV[`\0\x85\x81R` \x81 `\x1F\x19\x86\x16\x91[\x82\x81\x10\x15b\0\x02\x13W\x88\x86\x01Q\x82U\x94\x84\x01\x94`\x01\x90\x91\x01\x90\x84\x01b\0\x01\xF2V[P\x85\x82\x10\x15b\0\x022W\x87\x85\x01Q`\0\x19`\x03\x88\x90\x1B`\xF8\x16\x1C\x19\x16\x81U[PPPPP`\x01\x90\x81\x1B\x01\x90UPV[`\x80Qa\r\xE6b\0\x02[`\09`\0PPa\r\xE6`\0\xF3\xFE`\x80`@R4\x80\x15a\0\x10W`\0\x80\xFD[P`\x046\x10a\0AW`\x005`\xE0\x1C\x80c6\r\x0F\xAD\x14a\0FW\x80c~\xF2r\x1F\x14a\0vW\x80c\x93\x0FBj\x14a\0\x9DW[`\0\x80\xFD[a\0Ya\0T6`\x04a\x08\xEEV[a\0\xD0V[`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R` \x01[`@Q\x80\x91\x03\x90\xF3[`@\x80Q\x80\x82\x01\x82R`\x05\x81Rd1.4.1`\xD8\x1B` \x82\x01R\x90Qa\0m\x91\x90a\tjV[a\0\xB0a\0\xAB6`\x04a\t\x93V[a\0\xEEV[`@\x80Q`\x01`\x01`\xA0\x1B\x03\x93\x84\x16\x81R\x92\x90\x91\x16` \x83\x01R\x01a\0mV[`\0a\0\xE5`\x01`\x01`\xA0\x1B\x03\x84\x16\x83a\x04\x9DV[\x90P[\x92\x91PPV[`\0\x80\x84Q`\0\x03a\x01\x13W`@Qc\x06\xBF\xE8\xD5`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`@Qk\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x193``\x1B\x16` \x82\x01R`4\x81\x01\x85\x90R`\0\x90`T\x01`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x90R\x80Q` \x90\x91\x01 \x90P`\0a\x01j`\x01`\x01`\xA0\x1B\x03\x89\x16\x83a\x04\xFDV[\x90P`\0\x87`\0\x81Q\x81\x10a\x01\x81Wa\x01\x81a\n{V[` \x02` \x01\x01Q\x90P0\x88`\0\x81Q\x81\x10a\x01\x9FWa\x01\x9Fa\n{V[` \x02` \x01\x01\x90`\x01`\x01`\xA0\x1B\x03\x16\x90\x81`\x01`\x01`\xA0\x1B\x03\x16\x81RPP`\0\x88`\x01`\0s*\x15\xDED\x10\xD4\xC8\xAF\n{l\x12\x801 \xF4<B\xB8 `\0\x80`\0`@Q`$\x01a\x01\xF6\x97\x96\x95\x94\x93\x92\x91\x90a\n\x91V[`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x81R` \x82\x01\x80Q`\x01`\x01`\xE0\x1B\x03\x16c\xB6>\x80\r`\xE0\x1B\x17\x90RQc\x16\x88\xF0\xB9`\xE0\x1B\x81R\x90\x91P`\0\x90sN\x1D\xCFz\xD4\xE4`\xCF\xD3\x07\x91\xCC\xC4\xF9\xC8\xA4\xF8 \xECg\x90c\x16\x88\xF0\xB9\x90a\x02s\x90sAg\\\t\x9F24\x1B\xF8K\xFCS\x82\xAFSM\xF5\xC7F\x1A\x90\x86\x90\x8E\x90`\x04\x01a\x0BRV[` `@Q\x80\x83\x03\x81`\0\x87Z\xF1\x15\x80\x15a\x02\x92W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x02\xB6\x91\x90a\x0B\x86V[`@\x80Q`\x01`\x01`\xA0\x1B\x03\x83\x16` \x82\x01Rs\x96A\xD7d\xFC\x13\xC8\xB6$\xC0D0\xC75l\x1C|\x81\x02\xE2\x81\x83\x01R``\x80\x82\x01\x8C\x90R\x82Q\x80\x83\x03\x90\x91\x01\x81R`\x80\x82\x01\x90\x92R\x91\x92P\x82\x91`\0\x91a\x03\x0F\x91`\xA4\x01a\tjV[`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x90R` \x81\x01\x80Q`\x01`\x01`\xE0\x1B\x03\x16cC\x9F\xAB\x91`\xE0\x1B\x17\x90R\x90Pa\x03N`\x01`\x01`\xA0\x1B\x03\x87\x16\x82a\x05\x9FV[P`@Q`\x01`\x01`\xA0\x1B\x03\x87\x16`$\x82\x01R`\0\x90`D\x01`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x90R` \x81\x01\x80Q`\x01`\x01`\xE0\x1B\x03\x16ca\x0BY%`\xE0\x1B\x17\x90R\x90Pa\x03\x9F\x83`\0\x83a\x05\xE3V[`@Q`\x01`$\x82\x01R0`D\x82\x01R`\x01`\x01`\xA0\x1B\x03\x87\x16`d\x82\x01R`\0\x90`\x84\x01`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x90R` \x81\x01\x80Q`\x01`\x01`\xE0\x1B\x03\x16c\xE3\x18\xB5+`\xE0\x1B\x17\x90R\x90Pa\x03\xFC\x84`\x01\x83a\x05\xE3V[\x8E`\x01`\x01`\xA0\x1B\x03\x16\x7F\x81=9\x1D\xC4\x90\xD6\xC1\xDA\xE7\xD3\xFD\xD5U\xF37S=\x1D\xA2\xC9\x08\xC6\xEF\xD3mL\xF5W\xA62\x06\x89`@Qa\x04D\x91\x90`\x01`\x01`\xA0\x1B\x03\x91\x90\x91\x16\x81R` \x01\x90V[`@Q\x80\x91\x03\x90\xA2`@Q`\x01`\x01`\xA0\x1B\x03\x86\x16\x81R\x7F\x821\xD1i\xF4\x16\xB6f\xAE\x7F\xA4?\xAA$\xA1\x88\x99s\x80u\xA5?2\xC9v\x17\xD1s\xB1\x89\xE3\x86\x90` \x01`@Q\x80\x91\x03\x90\xA1P\x95\x9D\x91\x9CP\x90\x9APPPPPPPPPPPV[`@Q0`8\x82\x01RoZ\xF4=\x82\x80>\x90=\x91`+W\xFD[\xF3\xFF`$\x82\x01R`\x14\x81\x01\x83\x90Rs=`-\x80`\n=9\x81\xF36==7===6=s\x81R`X\x81\x01\x82\x90R`7`\x0C\x82\x01 `x\x82\x01R`U`C\x90\x91\x01 `\0\x90a\0\xE5V[`\0v=`-\x80`\n=9\x81\xF36==7===6=s\0\0\0\x83``\x1B`\xE8\x1C\x17`\0RnZ\xF4=\x82\x80>\x90=\x91`+W\xFD[\xF3\x83`x\x1B\x17` R\x81`7`\t`\0\xF5\x90P`\x01`\x01`\xA0\x1B\x03\x81\x16a\0\xE8W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x17`$\x82\x01R\x7FERC1167: create2 failed\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01[`@Q\x80\x91\x03\x90\xFD[``a\0\xE5\x83\x83`\0`@Q\x80`@\x01`@R\x80`\x1E\x81R` \x01\x7FAddress: low-level call failed\0\0\x81RPa\x07KV[`@Qc\x1B\x1A#\xEF`\xE3\x1B\x81R`\0\x90`\x01`\x01`\xA0\x1B\x03\x85\x16\x90c\xD8\xD1\x1Fx\x90a\x06$\x90\x87\x90\x85\x90\x87\x90\x82\x90\x81\x90\x81\x90\x81\x90\x81\x903\x90\x8F\x90`\x04\x01a\x0B\xCCV[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x06AW=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x06e\x91\x90a\x0CBV[`@Qc\xD4\xD9\xBD\xCD`\xE0\x1B\x81R`\x04\x81\x01\x82\x90R\x90\x91P`\x01`\x01`\xA0\x1B\x03\x85\x16\x90c\xD4\xD9\xBD\xCD\x90`$\x01`\0`@Q\x80\x83\x03\x81`\0\x87\x80;\x15\x80\x15a\x06\xAAW`\0\x80\xFD[PZ\xF1\x15\x80\x15a\x06\xBEW=`\0\x80>=`\0\xFD[PP`@Qc5;\t\x01`\xE1\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x87\x16\x92Pcjv\x12\x02\x91Pa\x07\x01\x90\x87\x90`\0\x90\x87\x90\x82\x90\x81\x90\x81\x90\x81\x90\x81\x903\x90\x82\x90`\x04\x01a\x0C[V[` `@Q\x80\x83\x03\x81`\0\x87Z\xF1\x15\x80\x15a\x07 W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x07D\x91\x90a\rrV[PPPPPV[``\x82G\x10\x15a\x07\xACW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`&`$\x82\x01R\x7FAddress: insufficient balance fo`D\x82\x01Re\x1C\x88\x18\xD8[\x1B`\xD2\x1B`d\x82\x01R`\x84\x01a\x05\x96V[`\0\x80\x86`\x01`\x01`\xA0\x1B\x03\x16\x85\x87`@Qa\x07\xC8\x91\x90a\r\x94V[`\0`@Q\x80\x83\x03\x81\x85\x87Z\xF1\x92PPP=\x80`\0\x81\x14a\x08\x05W`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=`\0` \x84\x01>a\x08\nV[``\x91P[P\x91P\x91Pa\x08\x1B\x87\x83\x83\x87a\x08(V[\x92PPP[\x94\x93PPPPV[``\x83\x15a\x08\x97W\x82Q`\0\x03a\x08\x90W`\x01`\x01`\xA0\x1B\x03\x85\x16;a\x08\x90W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1D`$\x82\x01R\x7FAddress: call to non-contract\0\0\0`D\x82\x01R`d\x01a\x05\x96V[P\x81a\x08 V[a\x08 \x83\x83\x81Q\x15a\x08\xACW\x81Q\x80\x83` \x01\xFD[\x80`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x05\x96\x91\x90a\tjV[`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a\x08\xDBW`\0\x80\xFD[PV[\x805a\x08\xE9\x81a\x08\xC6V[\x91\x90PV[`\0\x80`@\x83\x85\x03\x12\x15a\t\x01W`\0\x80\xFD[\x825a\t\x0C\x81a\x08\xC6V[\x94` \x93\x90\x93\x015\x93PPPV[`\0[\x83\x81\x10\x15a\t5W\x81\x81\x01Q\x83\x82\x01R` \x01a\t\x1DV[PP`\0\x91\x01RV[`\0\x81Q\x80\x84Ra\tV\x81` \x86\x01` \x86\x01a\t\x1AV[`\x1F\x01`\x1F\x19\x16\x92\x90\x92\x01` \x01\x92\x91PPV[` \x81R`\0a\0\xE5` \x83\x01\x84a\t>V[cNH{q`\xE0\x1B`\0R`A`\x04R`$`\0\xFD[`\0\x80`\0\x80`\x80\x85\x87\x03\x12\x15a\t\xA9W`\0\x80\xFD[\x845a\t\xB4\x81a\x08\xC6V[\x93P` \x85\x81\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x82\x11\x15a\t\xD2W`\0\x80\xFD[\x81\x88\x01\x91P\x88`\x1F\x83\x01\x12a\t\xE6W`\0\x80\xFD[\x815\x81\x81\x11\x15a\t\xF8Wa\t\xF8a\t}V[\x80`\x05\x1B`@Q`\x1F\x19`?\x83\x01\x16\x81\x01\x81\x81\x10\x85\x82\x11\x17\x15a\n\x1DWa\n\x1Da\t}V[`@R\x91\x82R\x84\x82\x01\x92P\x83\x81\x01\x85\x01\x91\x8B\x83\x11\x15a\n;W`\0\x80\xFD[\x93\x85\x01\x93[\x82\x85\x10\x15a\n`Wa\nQ\x85a\x08\xDEV[\x84R\x93\x85\x01\x93\x92\x85\x01\x92a\n@V[\x98\x9B\x98\x9APPPP`@\x87\x015\x96``\x015\x95\x94PPPPPV[cNH{q`\xE0\x1B`\0R`2`\x04R`$`\0\xFD[a\x01\0\x80\x82R\x88Q\x90\x82\x01\x81\x90R`\0\x90a\x01 \x83\x01\x90` \x90\x81\x8C\x01\x84[\x82\x81\x10\x15a\n\xD5W\x81Q`\x01`\x01`\xA0\x1B\x03\x16\x85R\x93\x83\x01\x93\x90\x83\x01\x90`\x01\x01a\n\xB0V[PPP`\xFF\x8A\x16\x84\x82\x01RP`\x01`\x01`\xA0\x1B\x03\x88\x16`@\x84\x01R\x82\x81\x03``\x84\x01R`\x01\x81R`\0` \x82\x01R`@\x81\x01\x91PPa\x0B\x1F`\x80\x83\x01\x87`\x01`\x01`\xA0\x1B\x03\x16\x90RV[`\x01`\x01`\xA0\x1B\x03\x85\x16`\xA0\x83\x01R`\xFF\x84\x16`\xC0\x83\x01R`\x01`\x01`\xA0\x1B\x03\x83\x16`\xE0\x83\x01R\x98\x97PPPPPPPPV[`\x01`\x01`\xA0\x1B\x03\x84\x16\x81R``` \x82\x01\x81\x90R`\0\x90a\x0Bv\x90\x83\x01\x85a\t>V[\x90P\x82`@\x83\x01R\x94\x93PPPPV[`\0` \x82\x84\x03\x12\x15a\x0B\x98W`\0\x80\xFD[\x81Qa\x0B\xA3\x81a\x08\xC6V[\x93\x92PPPV[`\x02\x81\x10a\x0B\xC8WcNH{q`\xE0\x1B`\0R`!`\x04R`$`\0\xFD[\x90RV[`\x01`\x01`\xA0\x1B\x03\x8B\x81\x16\x82R` \x82\x01\x8B\x90Ra\x01@`@\x83\x01\x81\x90R`\0\x91a\x0B\xF9\x84\x83\x01\x8Da\t>V[\x92Pa\x0C\x08``\x85\x01\x8Ca\x0B\xAAV[`\x80\x84\x01\x99\x90\x99RP`\xA0\x82\x01\x96\x90\x96R`\xC0\x81\x01\x94\x90\x94R\x91\x85\x16`\xE0\x84\x01R\x90\x93\x16a\x01\0\x82\x01Ra\x01 \x01\x91\x90\x91R\x94\x93PPPPV[`\0` \x82\x84\x03\x12\x15a\x0CTW`\0\x80\xFD[PQ\x91\x90PV[`\0a\x01@`\x01\x80`\xA0\x1B\x03\x80\x8E\x16\x84R` \x8D\x81\x86\x01R\x82`@\x86\x01Ra\x0C\x85\x83\x86\x01\x8Ea\t>V[\x92Pa\x0C\x94``\x86\x01\x8Da\x0B\xAAV[\x8A`\x80\x86\x01R\x89`\xA0\x86\x01R\x88`\xC0\x86\x01R\x81\x88\x16`\xE0\x86\x01R\x81\x87\x16a\x01\0\x86\x01R\x84\x83\x03a\x01 \x86\x01R`\0\x91P\x85T\x82`\x01\x82\x81\x1C\x91P\x80\x83\x16\x80a\x0C\xDDW`\x7F\x83\x16\x92P[\x84\x83\x10\x81\x03a\x0C\xFAWcNH{q`\xE0\x1B\x86R`\"`\x04R`$\x86\xFD[\x82\x87R` \x87\x01\x96P\x80\x80\x15a\r\x17W`\x01\x81\x14a\r-Wa\rXV[`\xFF\x19\x85\x16\x88R\x83\x15\x15`\x05\x1B\x88\x01\x96Pa\rXV[`\0\x8B\x81R` \x90 `\0[\x85\x81\x10\x15a\rRW\x81T\x8A\x82\x01R\x90\x84\x01\x90\x87\x01a\r9V[\x89\x01\x97PP[PPPPPP\x80\x92PPP\x9B\x9APPPPPPPPPPPV[`\0` \x82\x84\x03\x12\x15a\r\x84W`\0\x80\xFD[\x81Q\x80\x15\x15\x81\x14a\x0B\xA3W`\0\x80\xFD[`\0\x82Qa\r\xA6\x81\x84` \x87\x01a\t\x1AV[\x91\x90\x91\x01\x92\x91PPV\xFE\xA2dipfsX\"\x12 \x98\x86ik)\t\xC8\xEF\xE8\x18\x02\xF6\xE7_\xD0\xD1\x07.\x9BW\xE0\xCAV\x80\xD6\x16\x8A\xAF_\xAEK\xC3dsolcC\0\x08\x13\x003",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x608060405234801561001057600080fd5b50600436106100415760003560e01c8063360d0fad146100465780637ef2721f14610076578063930f426a1461009d575b600080fd5b6100596100543660046108ee565b6100d0565b6040516001600160a01b0390911681526020015b60405180910390f35b6040805180820182526005815264312e342e3160d81b6020820152905161006d919061096a565b6100b06100ab366004610993565b6100ee565b604080516001600160a01b0393841681529290911660208301520161006d565b60006100e56001600160a01b0384168361049d565b90505b92915050565b6000808451600003610113576040516306bfe8d560e11b815260040160405180910390fd5b6040516bffffffffffffffffffffffff193360601b1660208201526034810185905260009060540160408051601f1981840301815291905280516020909101209050600061016a6001600160a01b038916836104fd565b905060008760008151811061018157610181610a7b565b60200260200101519050308860008151811061019f5761019f610a7b565b60200260200101906001600160a01b031690816001600160a01b03168152505060008860016000732a15de4410d4c8af0a7b6c12803120f43c42b82060008060006040516024016101f69796959493929190610a91565b60408051601f198184030181529181526020820180516001600160e01b031663b63e800d60e01b17905251631688f0b960e01b8152909150600090734e1dcf7ad4e460cfd30791ccc4f9c8a4f820ec6790631688f0b990610273907341675c099f32341bf84bfc5382af534df5c7461a9086908e90600401610b52565b6020604051808303816000875af1158015610292573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102b69190610b86565b604080516001600160a01b0383166020820152739641d764fc13c8b624c04430c7356c1c7c8102e28183015260608082018c90528251808303909101815260808201909252919250829160009161030f9160a40161096a565b60408051601f198184030181529190526020810180516001600160e01b031663439fab9160e01b179052905061034e6001600160a01b0387168261059f565b506040516001600160a01b038716602482015260009060440160408051601f198184030181529190526020810180516001600160e01b031663610b592560e01b179052905061039f836000836105e3565b604051600160248201523060448201526001600160a01b038716606482015260009060840160408051601f198184030181529190526020810180516001600160e01b031663e318b52b60e01b17905290506103fc846001836105e3565b8e6001600160a01b03167f813d391dc490d6c1dae7d3fdd555f337533d1da2c908c6efd36d4cf557a632068960405161044491906001600160a01b0391909116815260200190565b60405180910390a26040516001600160a01b03861681527f8231d169f416b666ae7fa43faa24a18899738075a53f32c97617d173b189e3869060200160405180910390a150959d919c50909a5050505050505050505050565b6040513060388201526f5af43d82803e903d91602b57fd5bf3ff602482015260148101839052733d602d80600a3d3981f3363d3d373d3d3d363d738152605881018290526037600c820120607882015260556043909101206000906100e5565b6000763d602d80600a3d3981f3363d3d373d3d3d363d730000008360601b60e81c176000526e5af43d82803e903d91602b57fd5bf38360781b1760205281603760096000f590506001600160a01b0381166100e85760405162461bcd60e51b815260206004820152601760248201527f455243313136373a2063726561746532206661696c656400000000000000000060448201526064015b60405180910390fd5b60606100e5838360006040518060400160405280601e81526020017f416464726573733a206c6f772d6c6576656c2063616c6c206661696c6564000081525061074b565b604051631b1a23ef60e31b81526000906001600160a01b0385169063d8d11f7890610624908790859087908290819081908190819033908f90600401610bcc565b602060405180830381865afa158015610641573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106659190610c42565b60405163d4d9bdcd60e01b8152600481018290529091506001600160a01b0385169063d4d9bdcd90602401600060405180830381600087803b1580156106aa57600080fd5b505af11580156106be573d6000803e3d6000fd5b505060405163353b090160e11b81526001600160a01b0387169250636a761202915061070190879060009087908290819081908190819033908290600401610c5b565b6020604051808303816000875af1158015610720573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107449190610d72565b5050505050565b6060824710156107ac5760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f6044820152651c8818d85b1b60d21b6064820152608401610596565b600080866001600160a01b031685876040516107c89190610d94565b60006040518083038185875af1925050503d8060008114610805576040519150601f19603f3d011682016040523d82523d6000602084013e61080a565b606091505b509150915061081b87838387610828565b925050505b949350505050565b60608315610897578251600003610890576001600160a01b0385163b6108905760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e74726163740000006044820152606401610596565b5081610820565b61082083838151156108ac5781518083602001fd5b8060405162461bcd60e51b8152600401610596919061096a565b6001600160a01b03811681146108db57600080fd5b50565b80356108e9816108c6565b919050565b6000806040838503121561090157600080fd5b823561090c816108c6565b946020939093013593505050565b60005b8381101561093557818101518382015260200161091d565b50506000910152565b6000815180845261095681602086016020860161091a565b601f01601f19169290920160200192915050565b6020815260006100e5602083018461093e565b634e487b7160e01b600052604160045260246000fd5b600080600080608085870312156109a957600080fd5b84356109b4816108c6565b935060208581013567ffffffffffffffff808211156109d257600080fd5b818801915088601f8301126109e657600080fd5b8135818111156109f8576109f861097d565b8060051b604051601f19603f83011681018181108582111715610a1d57610a1d61097d565b60405291825284820192508381018501918b831115610a3b57600080fd5b938501935b82851015610a6057610a51856108de565b84529385019392850192610a40565b989b989a505050506040870135966060013595945050505050565b634e487b7160e01b600052603260045260246000fd5b6101008082528851908201819052600090610120830190602090818c01845b82811015610ad55781516001600160a01b031685529383019390830190600101610ab0565b50505060ff8a1684820152506001600160a01b03881660408401528281036060840152600181526000602082015260408101915050610b1f60808301876001600160a01b03169052565b6001600160a01b03851660a083015260ff841660c08301526001600160a01b03831660e083015298975050505050505050565b6001600160a01b0384168152606060208201819052600090610b769083018561093e565b9050826040830152949350505050565b600060208284031215610b9857600080fd5b8151610ba3816108c6565b9392505050565b60028110610bc857634e487b7160e01b600052602160045260246000fd5b9052565b6001600160a01b038b81168252602082018b905261014060408301819052600091610bf98483018d61093e565b9250610c08606085018c610baa565b60808401999099525060a082019690965260c081019490945291851660e08401529093166101008201526101200191909152949350505050565b600060208284031215610c5457600080fd5b5051919050565b600061014060018060a01b03808e16845260208d81860152826040860152610c858386018e61093e565b9250610c94606086018d610baa565b8a60808601528960a08601528860c086015281881660e086015281871661010086015284830361012086015260009150855482600182811c915080831680610cdd57607f831692505b8483108103610cfa57634e487b7160e01b86526022600452602486fd5b828752602087019650808015610d175760018114610d2d57610d58565b60ff198516885283151560051b88019650610d58565b60008b81526020902060005b85811015610d525781548a820152908401908701610d39565b89019750505b50505050505080925050509b9a5050505050505050505050565b600060208284031215610d8457600080fd5b81518015158114610ba357600080fd5b60008251610da681846020870161091a565b919091019291505056fea26469706673582212209886696b2909c8efe81802f6e75fd0d1072e9b57e0ca5680d6168aaf5fae4bc364736f6c63430008130033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R4\x80\x15a\0\x10W`\0\x80\xFD[P`\x046\x10a\0AW`\x005`\xE0\x1C\x80c6\r\x0F\xAD\x14a\0FW\x80c~\xF2r\x1F\x14a\0vW\x80c\x93\x0FBj\x14a\0\x9DW[`\0\x80\xFD[a\0Ya\0T6`\x04a\x08\xEEV[a\0\xD0V[`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R` \x01[`@Q\x80\x91\x03\x90\xF3[`@\x80Q\x80\x82\x01\x82R`\x05\x81Rd1.4.1`\xD8\x1B` \x82\x01R\x90Qa\0m\x91\x90a\tjV[a\0\xB0a\0\xAB6`\x04a\t\x93V[a\0\xEEV[`@\x80Q`\x01`\x01`\xA0\x1B\x03\x93\x84\x16\x81R\x92\x90\x91\x16` \x83\x01R\x01a\0mV[`\0a\0\xE5`\x01`\x01`\xA0\x1B\x03\x84\x16\x83a\x04\x9DV[\x90P[\x92\x91PPV[`\0\x80\x84Q`\0\x03a\x01\x13W`@Qc\x06\xBF\xE8\xD5`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`@Qk\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x193``\x1B\x16` \x82\x01R`4\x81\x01\x85\x90R`\0\x90`T\x01`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x90R\x80Q` \x90\x91\x01 \x90P`\0a\x01j`\x01`\x01`\xA0\x1B\x03\x89\x16\x83a\x04\xFDV[\x90P`\0\x87`\0\x81Q\x81\x10a\x01\x81Wa\x01\x81a\n{V[` \x02` \x01\x01Q\x90P0\x88`\0\x81Q\x81\x10a\x01\x9FWa\x01\x9Fa\n{V[` \x02` \x01\x01\x90`\x01`\x01`\xA0\x1B\x03\x16\x90\x81`\x01`\x01`\xA0\x1B\x03\x16\x81RPP`\0\x88`\x01`\0s*\x15\xDED\x10\xD4\xC8\xAF\n{l\x12\x801 \xF4<B\xB8 `\0\x80`\0`@Q`$\x01a\x01\xF6\x97\x96\x95\x94\x93\x92\x91\x90a\n\x91V[`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x81R` \x82\x01\x80Q`\x01`\x01`\xE0\x1B\x03\x16c\xB6>\x80\r`\xE0\x1B\x17\x90RQc\x16\x88\xF0\xB9`\xE0\x1B\x81R\x90\x91P`\0\x90sN\x1D\xCFz\xD4\xE4`\xCF\xD3\x07\x91\xCC\xC4\xF9\xC8\xA4\xF8 \xECg\x90c\x16\x88\xF0\xB9\x90a\x02s\x90sAg\\\t\x9F24\x1B\xF8K\xFCS\x82\xAFSM\xF5\xC7F\x1A\x90\x86\x90\x8E\x90`\x04\x01a\x0BRV[` `@Q\x80\x83\x03\x81`\0\x87Z\xF1\x15\x80\x15a\x02\x92W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x02\xB6\x91\x90a\x0B\x86V[`@\x80Q`\x01`\x01`\xA0\x1B\x03\x83\x16` \x82\x01Rs\x96A\xD7d\xFC\x13\xC8\xB6$\xC0D0\xC75l\x1C|\x81\x02\xE2\x81\x83\x01R``\x80\x82\x01\x8C\x90R\x82Q\x80\x83\x03\x90\x91\x01\x81R`\x80\x82\x01\x90\x92R\x91\x92P\x82\x91`\0\x91a\x03\x0F\x91`\xA4\x01a\tjV[`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x90R` \x81\x01\x80Q`\x01`\x01`\xE0\x1B\x03\x16cC\x9F\xAB\x91`\xE0\x1B\x17\x90R\x90Pa\x03N`\x01`\x01`\xA0\x1B\x03\x87\x16\x82a\x05\x9FV[P`@Q`\x01`\x01`\xA0\x1B\x03\x87\x16`$\x82\x01R`\0\x90`D\x01`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x90R` \x81\x01\x80Q`\x01`\x01`\xE0\x1B\x03\x16ca\x0BY%`\xE0\x1B\x17\x90R\x90Pa\x03\x9F\x83`\0\x83a\x05\xE3V[`@Q`\x01`$\x82\x01R0`D\x82\x01R`\x01`\x01`\xA0\x1B\x03\x87\x16`d\x82\x01R`\0\x90`\x84\x01`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x90R` \x81\x01\x80Q`\x01`\x01`\xE0\x1B\x03\x16c\xE3\x18\xB5+`\xE0\x1B\x17\x90R\x90Pa\x03\xFC\x84`\x01\x83a\x05\xE3V[\x8E`\x01`\x01`\xA0\x1B\x03\x16\x7F\x81=9\x1D\xC4\x90\xD6\xC1\xDA\xE7\xD3\xFD\xD5U\xF37S=\x1D\xA2\xC9\x08\xC6\xEF\xD3mL\xF5W\xA62\x06\x89`@Qa\x04D\x91\x90`\x01`\x01`\xA0\x1B\x03\x91\x90\x91\x16\x81R` \x01\x90V[`@Q\x80\x91\x03\x90\xA2`@Q`\x01`\x01`\xA0\x1B\x03\x86\x16\x81R\x7F\x821\xD1i\xF4\x16\xB6f\xAE\x7F\xA4?\xAA$\xA1\x88\x99s\x80u\xA5?2\xC9v\x17\xD1s\xB1\x89\xE3\x86\x90` \x01`@Q\x80\x91\x03\x90\xA1P\x95\x9D\x91\x9CP\x90\x9APPPPPPPPPPPV[`@Q0`8\x82\x01RoZ\xF4=\x82\x80>\x90=\x91`+W\xFD[\xF3\xFF`$\x82\x01R`\x14\x81\x01\x83\x90Rs=`-\x80`\n=9\x81\xF36==7===6=s\x81R`X\x81\x01\x82\x90R`7`\x0C\x82\x01 `x\x82\x01R`U`C\x90\x91\x01 `\0\x90a\0\xE5V[`\0v=`-\x80`\n=9\x81\xF36==7===6=s\0\0\0\x83``\x1B`\xE8\x1C\x17`\0RnZ\xF4=\x82\x80>\x90=\x91`+W\xFD[\xF3\x83`x\x1B\x17` R\x81`7`\t`\0\xF5\x90P`\x01`\x01`\xA0\x1B\x03\x81\x16a\0\xE8W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x17`$\x82\x01R\x7FERC1167: create2 failed\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01[`@Q\x80\x91\x03\x90\xFD[``a\0\xE5\x83\x83`\0`@Q\x80`@\x01`@R\x80`\x1E\x81R` \x01\x7FAddress: low-level call failed\0\0\x81RPa\x07KV[`@Qc\x1B\x1A#\xEF`\xE3\x1B\x81R`\0\x90`\x01`\x01`\xA0\x1B\x03\x85\x16\x90c\xD8\xD1\x1Fx\x90a\x06$\x90\x87\x90\x85\x90\x87\x90\x82\x90\x81\x90\x81\x90\x81\x90\x81\x903\x90\x8F\x90`\x04\x01a\x0B\xCCV[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x06AW=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x06e\x91\x90a\x0CBV[`@Qc\xD4\xD9\xBD\xCD`\xE0\x1B\x81R`\x04\x81\x01\x82\x90R\x90\x91P`\x01`\x01`\xA0\x1B\x03\x85\x16\x90c\xD4\xD9\xBD\xCD\x90`$\x01`\0`@Q\x80\x83\x03\x81`\0\x87\x80;\x15\x80\x15a\x06\xAAW`\0\x80\xFD[PZ\xF1\x15\x80\x15a\x06\xBEW=`\0\x80>=`\0\xFD[PP`@Qc5;\t\x01`\xE1\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x87\x16\x92Pcjv\x12\x02\x91Pa\x07\x01\x90\x87\x90`\0\x90\x87\x90\x82\x90\x81\x90\x81\x90\x81\x90\x81\x903\x90\x82\x90`\x04\x01a\x0C[V[` `@Q\x80\x83\x03\x81`\0\x87Z\xF1\x15\x80\x15a\x07 W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x07D\x91\x90a\rrV[PPPPPV[``\x82G\x10\x15a\x07\xACW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`&`$\x82\x01R\x7FAddress: insufficient balance fo`D\x82\x01Re\x1C\x88\x18\xD8[\x1B`\xD2\x1B`d\x82\x01R`\x84\x01a\x05\x96V[`\0\x80\x86`\x01`\x01`\xA0\x1B\x03\x16\x85\x87`@Qa\x07\xC8\x91\x90a\r\x94V[`\0`@Q\x80\x83\x03\x81\x85\x87Z\xF1\x92PPP=\x80`\0\x81\x14a\x08\x05W`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=`\0` \x84\x01>a\x08\nV[``\x91P[P\x91P\x91Pa\x08\x1B\x87\x83\x83\x87a\x08(V[\x92PPP[\x94\x93PPPPV[``\x83\x15a\x08\x97W\x82Q`\0\x03a\x08\x90W`\x01`\x01`\xA0\x1B\x03\x85\x16;a\x08\x90W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1D`$\x82\x01R\x7FAddress: call to non-contract\0\0\0`D\x82\x01R`d\x01a\x05\x96V[P\x81a\x08 V[a\x08 \x83\x83\x81Q\x15a\x08\xACW\x81Q\x80\x83` \x01\xFD[\x80`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x05\x96\x91\x90a\tjV[`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a\x08\xDBW`\0\x80\xFD[PV[\x805a\x08\xE9\x81a\x08\xC6V[\x91\x90PV[`\0\x80`@\x83\x85\x03\x12\x15a\t\x01W`\0\x80\xFD[\x825a\t\x0C\x81a\x08\xC6V[\x94` \x93\x90\x93\x015\x93PPPV[`\0[\x83\x81\x10\x15a\t5W\x81\x81\x01Q\x83\x82\x01R` \x01a\t\x1DV[PP`\0\x91\x01RV[`\0\x81Q\x80\x84Ra\tV\x81` \x86\x01` \x86\x01a\t\x1AV[`\x1F\x01`\x1F\x19\x16\x92\x90\x92\x01` \x01\x92\x91PPV[` \x81R`\0a\0\xE5` \x83\x01\x84a\t>V[cNH{q`\xE0\x1B`\0R`A`\x04R`$`\0\xFD[`\0\x80`\0\x80`\x80\x85\x87\x03\x12\x15a\t\xA9W`\0\x80\xFD[\x845a\t\xB4\x81a\x08\xC6V[\x93P` \x85\x81\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x82\x11\x15a\t\xD2W`\0\x80\xFD[\x81\x88\x01\x91P\x88`\x1F\x83\x01\x12a\t\xE6W`\0\x80\xFD[\x815\x81\x81\x11\x15a\t\xF8Wa\t\xF8a\t}V[\x80`\x05\x1B`@Q`\x1F\x19`?\x83\x01\x16\x81\x01\x81\x81\x10\x85\x82\x11\x17\x15a\n\x1DWa\n\x1Da\t}V[`@R\x91\x82R\x84\x82\x01\x92P\x83\x81\x01\x85\x01\x91\x8B\x83\x11\x15a\n;W`\0\x80\xFD[\x93\x85\x01\x93[\x82\x85\x10\x15a\n`Wa\nQ\x85a\x08\xDEV[\x84R\x93\x85\x01\x93\x92\x85\x01\x92a\n@V[\x98\x9B\x98\x9APPPP`@\x87\x015\x96``\x015\x95\x94PPPPPV[cNH{q`\xE0\x1B`\0R`2`\x04R`$`\0\xFD[a\x01\0\x80\x82R\x88Q\x90\x82\x01\x81\x90R`\0\x90a\x01 \x83\x01\x90` \x90\x81\x8C\x01\x84[\x82\x81\x10\x15a\n\xD5W\x81Q`\x01`\x01`\xA0\x1B\x03\x16\x85R\x93\x83\x01\x93\x90\x83\x01\x90`\x01\x01a\n\xB0V[PPP`\xFF\x8A\x16\x84\x82\x01RP`\x01`\x01`\xA0\x1B\x03\x88\x16`@\x84\x01R\x82\x81\x03``\x84\x01R`\x01\x81R`\0` \x82\x01R`@\x81\x01\x91PPa\x0B\x1F`\x80\x83\x01\x87`\x01`\x01`\xA0\x1B\x03\x16\x90RV[`\x01`\x01`\xA0\x1B\x03\x85\x16`\xA0\x83\x01R`\xFF\x84\x16`\xC0\x83\x01R`\x01`\x01`\xA0\x1B\x03\x83\x16`\xE0\x83\x01R\x98\x97PPPPPPPPV[`\x01`\x01`\xA0\x1B\x03\x84\x16\x81R``` \x82\x01\x81\x90R`\0\x90a\x0Bv\x90\x83\x01\x85a\t>V[\x90P\x82`@\x83\x01R\x94\x93PPPPV[`\0` \x82\x84\x03\x12\x15a\x0B\x98W`\0\x80\xFD[\x81Qa\x0B\xA3\x81a\x08\xC6V[\x93\x92PPPV[`\x02\x81\x10a\x0B\xC8WcNH{q`\xE0\x1B`\0R`!`\x04R`$`\0\xFD[\x90RV[`\x01`\x01`\xA0\x1B\x03\x8B\x81\x16\x82R` \x82\x01\x8B\x90Ra\x01@`@\x83\x01\x81\x90R`\0\x91a\x0B\xF9\x84\x83\x01\x8Da\t>V[\x92Pa\x0C\x08``\x85\x01\x8Ca\x0B\xAAV[`\x80\x84\x01\x99\x90\x99RP`\xA0\x82\x01\x96\x90\x96R`\xC0\x81\x01\x94\x90\x94R\x91\x85\x16`\xE0\x84\x01R\x90\x93\x16a\x01\0\x82\x01Ra\x01 \x01\x91\x90\x91R\x94\x93PPPPV[`\0` \x82\x84\x03\x12\x15a\x0CTW`\0\x80\xFD[PQ\x91\x90PV[`\0a\x01@`\x01\x80`\xA0\x1B\x03\x80\x8E\x16\x84R` \x8D\x81\x86\x01R\x82`@\x86\x01Ra\x0C\x85\x83\x86\x01\x8Ea\t>V[\x92Pa\x0C\x94``\x86\x01\x8Da\x0B\xAAV[\x8A`\x80\x86\x01R\x89`\xA0\x86\x01R\x88`\xC0\x86\x01R\x81\x88\x16`\xE0\x86\x01R\x81\x87\x16a\x01\0\x86\x01R\x84\x83\x03a\x01 \x86\x01R`\0\x91P\x85T\x82`\x01\x82\x81\x1C\x91P\x80\x83\x16\x80a\x0C\xDDW`\x7F\x83\x16\x92P[\x84\x83\x10\x81\x03a\x0C\xFAWcNH{q`\xE0\x1B\x86R`\"`\x04R`$\x86\xFD[\x82\x87R` \x87\x01\x96P\x80\x80\x15a\r\x17W`\x01\x81\x14a\r-Wa\rXV[`\xFF\x19\x85\x16\x88R\x83\x15\x15`\x05\x1B\x88\x01\x96Pa\rXV[`\0\x8B\x81R` \x90 `\0[\x85\x81\x10\x15a\rRW\x81T\x8A\x82\x01R\x90\x84\x01\x90\x87\x01a\r9V[\x89\x01\x97PP[PPPPPP\x80\x92PPP\x9B\x9APPPPPPPPPPPV[`\0` \x82\x84\x03\x12\x15a\r\x84W`\0\x80\xFD[\x81Q\x80\x15\x15\x81\x14a\x0B\xA3W`\0\x80\xFD[`\0\x82Qa\r\xA6\x81\x84` \x87\x01a\t\x1AV[\x91\x90\x91\x01\x92\x91PPV\xFE\xA2dipfsX\"\x12 \x98\x86ik)\t\xC8\xEF\xE8\x18\x02\xF6\xE7_\xD0\xD1\x07.\x9BW\xE0\xCAV\x80\xD6\x16\x8A\xAF_\xAEK\xC3dsolcC\0\x08\x13\x003",
    );
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `TooFewOwners()` and selector `0x0d7fd1aa`.
```solidity
error TooFewOwners();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct TooFewOwners;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<TooFewOwners> for UnderlyingRustTuple<'_> {
            fn from(value: TooFewOwners) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for TooFewOwners {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for TooFewOwners {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "TooFewOwners()";
            const SELECTOR: [u8; 4] = [13u8, 127u8, 209u8, 170u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `NewHoprNodeStakeModule(address,address)` and selector `0x813d391dc490d6c1dae7d3fdd555f337533d1da2c908c6efd36d4cf557a63206`.
```solidity
event NewHoprNodeStakeModule(address indexed moduleImplementation, address instance);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct NewHoprNodeStakeModule {
        #[allow(missing_docs)]
        pub moduleImplementation: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub instance: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for NewHoprNodeStakeModule {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "NewHoprNodeStakeModule(address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                129u8, 61u8, 57u8, 29u8, 196u8, 144u8, 214u8, 193u8, 218u8, 231u8, 211u8,
                253u8, 213u8, 85u8, 243u8, 55u8, 83u8, 61u8, 29u8, 162u8, 201u8, 8u8,
                198u8, 239u8, 211u8, 109u8, 76u8, 245u8, 87u8, 166u8, 50u8, 6u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    moduleImplementation: topics.1,
                    instance: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.instance,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.moduleImplementation.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.moduleImplementation,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for NewHoprNodeStakeModule {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&NewHoprNodeStakeModule> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &NewHoprNodeStakeModule) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `NewHoprNodeStakeSafe(address)` and selector `0x8231d169f416b666ae7fa43faa24a18899738075a53f32c97617d173b189e386`.
```solidity
event NewHoprNodeStakeSafe(address instance);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct NewHoprNodeStakeSafe {
        #[allow(missing_docs)]
        pub instance: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for NewHoprNodeStakeSafe {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "NewHoprNodeStakeSafe(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                130u8, 49u8, 209u8, 105u8, 244u8, 22u8, 182u8, 102u8, 174u8, 127u8,
                164u8, 63u8, 170u8, 36u8, 161u8, 136u8, 153u8, 115u8, 128u8, 117u8,
                165u8, 63u8, 50u8, 201u8, 118u8, 23u8, 209u8, 115u8, 177u8, 137u8, 227u8,
                134u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { instance: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.instance,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for NewHoprNodeStakeSafe {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&NewHoprNodeStakeSafe> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &NewHoprNodeStakeSafe) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Constructor`.
```solidity
constructor();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct constructorCall {}
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<constructorCall> for UnderlyingRustTuple<'_> {
                fn from(value: constructorCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for constructorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolConstructor for constructorCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `clone(address,address[],uint256,bytes32)` and selector `0x930f426a`.
```solidity
function clone(address moduleSingletonAddress, address[] memory admins, uint256 nonce, bytes32 defaultTarget) external returns (address, address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct cloneCall {
        #[allow(missing_docs)]
        pub moduleSingletonAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub admins: alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
        #[allow(missing_docs)]
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub defaultTarget: alloy::sol_types::private::FixedBytes<32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`clone(address,address[],uint256,bytes32)`](cloneCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct cloneReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub _1: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<cloneCall> for UnderlyingRustTuple<'_> {
                fn from(value: cloneCall) -> Self {
                    (
                        value.moduleSingletonAddress,
                        value.admins,
                        value.nonce,
                        value.defaultTarget,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for cloneCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        moduleSingletonAddress: tuple.0,
                        admins: tuple.1,
                        nonce: tuple.2,
                        defaultTarget: tuple.3,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<cloneReturn> for UnderlyingRustTuple<'_> {
                fn from(value: cloneReturn) -> Self {
                    (value._0, value._1)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for cloneReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0, _1: tuple.1 }
                }
            }
        }
        impl cloneReturn {
            fn _tokenize(
                &self,
            ) -> <cloneCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._0,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._1,
                    ),
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for cloneCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = cloneReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "clone(address,address[],uint256,bytes32)";
            const SELECTOR: [u8; 4] = [147u8, 15u8, 66u8, 106u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.moduleSingletonAddress,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Address,
                    > as alloy_sol_types::SolType>::tokenize(&self.admins),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.defaultTarget),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                cloneReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `predictDeterministicAddress(address,bytes32)` and selector `0x360d0fad`.
```solidity
function predictDeterministicAddress(address implementation, bytes32 salt) external view returns (address predicted);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct predictDeterministicAddressCall {
        #[allow(missing_docs)]
        pub implementation: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub salt: alloy::sol_types::private::FixedBytes<32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`predictDeterministicAddress(address,bytes32)`](predictDeterministicAddressCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct predictDeterministicAddressReturn {
        #[allow(missing_docs)]
        pub predicted: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<predictDeterministicAddressCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: predictDeterministicAddressCall) -> Self {
                    (value.implementation, value.salt)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for predictDeterministicAddressCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        implementation: tuple.0,
                        salt: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<predictDeterministicAddressReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: predictDeterministicAddressReturn) -> Self {
                    (value.predicted,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for predictDeterministicAddressReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { predicted: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for predictDeterministicAddressCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "predictDeterministicAddress(address,bytes32)";
            const SELECTOR: [u8; 4] = [54u8, 13u8, 15u8, 173u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.implementation,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.salt),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: predictDeterministicAddressReturn = r.into();
                        r.predicted
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: predictDeterministicAddressReturn = r.into();
                        r.predicted
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `safeVersion()` and selector `0x7ef2721f`.
```solidity
function safeVersion() external pure returns (string memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct safeVersionCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`safeVersion()`](safeVersionCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct safeVersionReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<safeVersionCall> for UnderlyingRustTuple<'_> {
                fn from(value: safeVersionCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for safeVersionCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<safeVersionReturn> for UnderlyingRustTuple<'_> {
                fn from(value: safeVersionReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for safeVersionReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for safeVersionCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::String;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "safeVersion()";
            const SELECTOR: [u8; 4] = [126u8, 242u8, 114u8, 31u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: safeVersionReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: safeVersionReturn = r.into();
                        r._0
                    })
            }
        }
    };
    ///Container for all the [`HoprNodeStakeFactory`](self) function calls.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive()]
    pub enum HoprNodeStakeFactoryCalls {
        #[allow(missing_docs)]
        clone(cloneCall),
        #[allow(missing_docs)]
        predictDeterministicAddress(predictDeterministicAddressCall),
        #[allow(missing_docs)]
        safeVersion(safeVersionCall),
    }
    #[automatically_derived]
    impl HoprNodeStakeFactoryCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [54u8, 13u8, 15u8, 173u8],
            [126u8, 242u8, 114u8, 31u8],
            [147u8, 15u8, 66u8, 106u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for HoprNodeStakeFactoryCalls {
        const NAME: &'static str = "HoprNodeStakeFactoryCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 3usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::clone(_) => <cloneCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::predictDeterministicAddress(_) => {
                    <predictDeterministicAddressCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::safeVersion(_) => {
                    <safeVersionCall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<HoprNodeStakeFactoryCalls>] = &[
                {
                    fn predictDeterministicAddress(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNodeStakeFactoryCalls> {
                        <predictDeterministicAddressCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNodeStakeFactoryCalls::predictDeterministicAddress)
                    }
                    predictDeterministicAddress
                },
                {
                    fn safeVersion(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNodeStakeFactoryCalls> {
                        <safeVersionCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNodeStakeFactoryCalls::safeVersion)
                    }
                    safeVersion
                },
                {
                    fn clone(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNodeStakeFactoryCalls> {
                        <cloneCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(HoprNodeStakeFactoryCalls::clone)
                    }
                    clone
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data)
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw_validate(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_VALIDATE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<HoprNodeStakeFactoryCalls>] = &[
                {
                    fn predictDeterministicAddress(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNodeStakeFactoryCalls> {
                        <predictDeterministicAddressCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNodeStakeFactoryCalls::predictDeterministicAddress)
                    }
                    predictDeterministicAddress
                },
                {
                    fn safeVersion(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNodeStakeFactoryCalls> {
                        <safeVersionCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNodeStakeFactoryCalls::safeVersion)
                    }
                    safeVersion
                },
                {
                    fn clone(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNodeStakeFactoryCalls> {
                        <cloneCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNodeStakeFactoryCalls::clone)
                    }
                    clone
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_VALIDATE_SHIMS[idx](data)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::clone(inner) => {
                    <cloneCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::predictDeterministicAddress(inner) => {
                    <predictDeterministicAddressCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::safeVersion(inner) => {
                    <safeVersionCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::clone(inner) => {
                    <cloneCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::predictDeterministicAddress(inner) => {
                    <predictDeterministicAddressCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::safeVersion(inner) => {
                    <safeVersionCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`HoprNodeStakeFactory`](self) custom errors.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub enum HoprNodeStakeFactoryErrors {
        #[allow(missing_docs)]
        TooFewOwners(TooFewOwners),
    }
    #[automatically_derived]
    impl HoprNodeStakeFactoryErrors {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[[13u8, 127u8, 209u8, 170u8]];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for HoprNodeStakeFactoryErrors {
        const NAME: &'static str = "HoprNodeStakeFactoryErrors";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 1usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::TooFewOwners(_) => {
                    <TooFewOwners as alloy_sol_types::SolError>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<HoprNodeStakeFactoryErrors>] = &[
                {
                    fn TooFewOwners(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNodeStakeFactoryErrors> {
                        <TooFewOwners as alloy_sol_types::SolError>::abi_decode_raw(data)
                            .map(HoprNodeStakeFactoryErrors::TooFewOwners)
                    }
                    TooFewOwners
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data)
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw_validate(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_VALIDATE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<HoprNodeStakeFactoryErrors>] = &[
                {
                    fn TooFewOwners(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNodeStakeFactoryErrors> {
                        <TooFewOwners as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNodeStakeFactoryErrors::TooFewOwners)
                    }
                    TooFewOwners
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_VALIDATE_SHIMS[idx](data)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::TooFewOwners(inner) => {
                    <TooFewOwners as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::TooFewOwners(inner) => {
                    <TooFewOwners as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`HoprNodeStakeFactory`](self) events.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub enum HoprNodeStakeFactoryEvents {
        #[allow(missing_docs)]
        NewHoprNodeStakeModule(NewHoprNodeStakeModule),
        #[allow(missing_docs)]
        NewHoprNodeStakeSafe(NewHoprNodeStakeSafe),
    }
    #[automatically_derived]
    impl HoprNodeStakeFactoryEvents {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                129u8, 61u8, 57u8, 29u8, 196u8, 144u8, 214u8, 193u8, 218u8, 231u8, 211u8,
                253u8, 213u8, 85u8, 243u8, 55u8, 83u8, 61u8, 29u8, 162u8, 201u8, 8u8,
                198u8, 239u8, 211u8, 109u8, 76u8, 245u8, 87u8, 166u8, 50u8, 6u8,
            ],
            [
                130u8, 49u8, 209u8, 105u8, 244u8, 22u8, 182u8, 102u8, 174u8, 127u8,
                164u8, 63u8, 170u8, 36u8, 161u8, 136u8, 153u8, 115u8, 128u8, 117u8,
                165u8, 63u8, 50u8, 201u8, 118u8, 23u8, 209u8, 115u8, 177u8, 137u8, 227u8,
                134u8,
            ],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for HoprNodeStakeFactoryEvents {
        const NAME: &'static str = "HoprNodeStakeFactoryEvents";
        const COUNT: usize = 2usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(
                    <NewHoprNodeStakeModule as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <NewHoprNodeStakeModule as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::NewHoprNodeStakeModule)
                }
                Some(
                    <NewHoprNodeStakeSafe as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <NewHoprNodeStakeSafe as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::NewHoprNodeStakeSafe)
                }
                _ => {
                    alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                        name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                        log: alloy_sol_types::private::Box::new(
                            alloy_sol_types::private::LogData::new_unchecked(
                                topics.to_vec(),
                                data.to_vec().into(),
                            ),
                        ),
                    })
                }
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData for HoprNodeStakeFactoryEvents {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::NewHoprNodeStakeModule(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::NewHoprNodeStakeSafe(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::NewHoprNodeStakeModule(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::NewHoprNodeStakeSafe(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`HoprNodeStakeFactory`](self) contract instance.

See the [wrapper's documentation](`HoprNodeStakeFactoryInstance`) for more details.*/
    #[inline]
    pub const fn new<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> HoprNodeStakeFactoryInstance<P, N> {
        HoprNodeStakeFactoryInstance::<P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<HoprNodeStakeFactoryInstance<P, N>>,
    > {
        HoprNodeStakeFactoryInstance::<P, N>::deploy(provider)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(provider: P) -> alloy_contract::RawCallBuilder<P, N> {
        HoprNodeStakeFactoryInstance::<P, N>::deploy_builder(provider)
    }
    /**A [`HoprNodeStakeFactory`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`HoprNodeStakeFactory`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct HoprNodeStakeFactoryInstance<P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network: ::core::marker::PhantomData<N>,
    }
    #[automatically_derived]
    impl<P, N> ::core::fmt::Debug for HoprNodeStakeFactoryInstance<P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("HoprNodeStakeFactoryInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > HoprNodeStakeFactoryInstance<P, N> {
        /**Creates a new wrapper around an on-chain [`HoprNodeStakeFactory`](self) contract instance.

See the [wrapper's documentation](`HoprNodeStakeFactoryInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
        ) -> alloy_contract::Result<HoprNodeStakeFactoryInstance<P, N>> {
            let call_builder = Self::deploy_builder(provider);
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(provider: P) -> alloy_contract::RawCallBuilder<P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                ::core::clone::Clone::clone(&BYTECODE),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<P: ::core::clone::Clone, N> HoprNodeStakeFactoryInstance<&P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> HoprNodeStakeFactoryInstance<P, N> {
            HoprNodeStakeFactoryInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > HoprNodeStakeFactoryInstance<P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<&P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`clone`] function.
        pub fn clone(
            &self,
            moduleSingletonAddress: alloy::sol_types::private::Address,
            admins: alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
            nonce: alloy::sol_types::private::primitives::aliases::U256,
            defaultTarget: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, cloneCall, N> {
            self.call_builder(
                &cloneCall {
                    moduleSingletonAddress,
                    admins,
                    nonce,
                    defaultTarget,
                },
            )
        }
        ///Creates a new call builder for the [`predictDeterministicAddress`] function.
        pub fn predictDeterministicAddress(
            &self,
            implementation: alloy::sol_types::private::Address,
            salt: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, predictDeterministicAddressCall, N> {
            self.call_builder(
                &predictDeterministicAddressCall {
                    implementation,
                    salt,
                },
            )
        }
        ///Creates a new call builder for the [`safeVersion`] function.
        pub fn safeVersion(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, safeVersionCall, N> {
            self.call_builder(&safeVersionCall)
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > HoprNodeStakeFactoryInstance<P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<&P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        ///Creates a new event filter for the [`NewHoprNodeStakeModule`] event.
        pub fn NewHoprNodeStakeModule_filter(
            &self,
        ) -> alloy_contract::Event<&P, NewHoprNodeStakeModule, N> {
            self.event_filter::<NewHoprNodeStakeModule>()
        }
        ///Creates a new event filter for the [`NewHoprNodeStakeSafe`] event.
        pub fn NewHoprNodeStakeSafe_filter(
            &self,
        ) -> alloy_contract::Event<&P, NewHoprNodeStakeSafe, N> {
            self.event_filter::<NewHoprNodeStakeSafe>()
        }
    }
}
