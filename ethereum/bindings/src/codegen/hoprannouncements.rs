/**

Generated by the following Solidity interface...
```solidity
interface HoprAnnouncements {
    error AlreadyInitialized();
    error ContractNotResponsible();
    error InvalidSafeAddress();
    error MultiSigUninitialized();

    event AddressAnnouncement(address node, string baseMultiaddr);
    event KeyBinding(bytes32 ed25519_sig_0, bytes32 ed25519_sig_1, bytes32 ed25519_pub_key, address chain_key);
    event RevokeAnnouncement(address node);

    constructor(address safeRegistry);

    function announce(string memory baseMultiaddr) external;
    function announceSafe(address selfAddress, string memory baseMultiaddr) external;
    function bindKeys(bytes32 ed25519_sig_0, bytes32 ed25519_sig_1, bytes32 ed25519_pub_key) external;
    function bindKeysAnnounce(bytes32 ed25519_sig_0, bytes32 ed25519_sig_1, bytes32 ed25519_pub_key, string memory baseMultiaddr) external;
    function bindKeysAnnounceSafe(address selfAddress, bytes32 ed25519_sig_0, bytes32 ed25519_sig_1, bytes32 ed25519_pub_key, string memory baseMultiaddr) external;
    function bindKeysSafe(address selfAddress, bytes32 ed25519_sig_0, bytes32 ed25519_sig_1, bytes32 ed25519_pub_key) external;
    function multicall(bytes[] memory data) external returns (bytes[] memory results);
    function revoke() external;
    function revokeSafe(address selfAddress) external;
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [
      {
        "name": "safeRegistry",
        "type": "address",
        "internalType": "contract HoprNodeSafeRegistry"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "announce",
    "inputs": [
      {
        "name": "baseMultiaddr",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "announceSafe",
    "inputs": [
      {
        "name": "selfAddress",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "baseMultiaddr",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "bindKeys",
    "inputs": [
      {
        "name": "ed25519_sig_0",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "ed25519_sig_1",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "ed25519_pub_key",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "bindKeysAnnounce",
    "inputs": [
      {
        "name": "ed25519_sig_0",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "ed25519_sig_1",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "ed25519_pub_key",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "baseMultiaddr",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "bindKeysAnnounceSafe",
    "inputs": [
      {
        "name": "selfAddress",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "ed25519_sig_0",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "ed25519_sig_1",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "ed25519_pub_key",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "baseMultiaddr",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "bindKeysSafe",
    "inputs": [
      {
        "name": "selfAddress",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "ed25519_sig_0",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "ed25519_sig_1",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "ed25519_pub_key",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "multicall",
    "inputs": [
      {
        "name": "data",
        "type": "bytes[]",
        "internalType": "bytes[]"
      }
    ],
    "outputs": [
      {
        "name": "results",
        "type": "bytes[]",
        "internalType": "bytes[]"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "revoke",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "revokeSafe",
    "inputs": [
      {
        "name": "selfAddress",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "event",
    "name": "AddressAnnouncement",
    "inputs": [
      {
        "name": "node",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "baseMultiaddr",
        "type": "string",
        "indexed": false,
        "internalType": "string"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "KeyBinding",
    "inputs": [
      {
        "name": "ed25519_sig_0",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "ed25519_sig_1",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "ed25519_pub_key",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "chain_key",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RevokeAnnouncement",
    "inputs": [
      {
        "name": "node",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "error",
    "name": "AlreadyInitialized",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ContractNotResponsible",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidSafeAddress",
    "inputs": []
  },
  {
    "type": "error",
    "name": "MultiSigUninitialized",
    "inputs": []
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod HoprAnnouncements {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x60806040526000805460ff60a01b1916905534801561001d57600080fd5b506040516110f73803806110f783398101604081905261003c916100c5565b6100458161004b565b506100f5565b600054600160a01b900460ff16156100755760405162dc149f60e41b815260040160405180910390fd5b6001600160a01b03811661009c5760405163474ebe2f60e11b815260040160405180910390fd5b600080546001600160a01b039092166001600160a81b031990921691909117600160a01b179055565b6000602082840312156100d757600080fd5b81516001600160a01b03811681146100ee57600080fd5b9392505050565b610ff3806101046000396000f3fe608060405234801561001057600080fd5b50600436106100935760003560e01c8063dbb98d9111610066578063dbb98d91146100f1578063ddb9dfc114610104578063ea0a523714610117578063f884a9cb1461012a578063fad0e5a21461013d57600080fd5b8063308c712e14610098578063ac9650d8146100ad578063b6549f75146100d6578063cae2b434146100de575b600080fd5b6100ab6100a6366004610b11565b610150565b005b6100c06100bb366004610b2e565b61021e565b6040516100cd9190610bf3565b60405180910390f35b6100ab610313565b6100ab6100ec366004610c55565b6103dc565b6100ab6100ff366004610c90565b6104b0565b6100ab610112366004610d05565b61057f565b6100ab610125366004610d78565b610660565b6100ab610138366004610dba565b610729565b6100ab61014b366004610e1b565b6107fe565b6000548190600160a01b900460ff1661017c576040516308a9441960e31b815260040160405180910390fd5b6000546040516302265e3160e61b81526001600160a01b038381166004830152339216906389978c4090602401602060405180830381865afa1580156101c6573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101ea9190610e70565b6001600160a01b0316146102115760405163acd5a82360e01b815260040160405180910390fd5b61021a826108d0565b5050565b60608167ffffffffffffffff81111561023957610239610e8d565b60405190808252806020026020018201604052801561026c57816020015b60608152602001906001900390816102575790505b50905060005b8281101561030c576102dc3085858481811061029057610290610ea3565b90506020028101906102a29190610eb9565b8080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061090f92505050565b8282815181106102ee576102ee610ea3565b6020026020010181905250808061030490610f00565b915050610272565b5092915050565b600054600160a01b900460ff1661033d576040516308a9441960e31b815260040160405180910390fd5b600080546040516302265e3160e61b81523360048201526001600160a01b03909116906389978c4090602401602060405180830381865afa158015610386573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103aa9190610e70565b6001600160a01b0316146103d15760405163acd5a82360e01b815260040160405180910390fd5b6103da336108d0565b565b6000548490600160a01b900460ff16610408576040516308a9441960e31b815260040160405180910390fd5b6000546040516302265e3160e61b81526001600160a01b038381166004830152339216906389978c4090602401602060405180830381865afa158015610452573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104769190610e70565b6001600160a01b03161461049d5760405163acd5a82360e01b815260040160405180910390fd5b6104a98585858561093b565b5050505050565b600054600160a01b900460ff166104da576040516308a9441960e31b815260040160405180910390fd5b600080546040516302265e3160e61b81523360048201526001600160a01b03909116906389978c4090602401602060405180830381865afa158015610523573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105479190610e70565b6001600160a01b03161461056e5760405163acd5a82360e01b815260040160405180910390fd5b61057a3384848461093b565b505050565b6000548690600160a01b900460ff166105ab576040516308a9441960e31b815260040160405180910390fd5b6000546040516302265e3160e61b81526001600160a01b038381166004830152339216906389978c4090602401602060405180830381865afa1580156105f5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106199190610e70565b6001600160a01b0316146106405760405163acd5a82360e01b815260040160405180910390fd5b61064c8787878761093b565b610657878484610991565b50505050505050565b600054600160a01b900460ff1661068a576040516308a9441960e31b815260040160405180910390fd5b600080546040516302265e3160e61b81523360048201526001600160a01b03909116906389978c4090602401602060405180830381865afa1580156106d3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106f79190610e70565b6001600160a01b03161461071e5760405163acd5a82360e01b815260040160405180910390fd5b61021a338383610991565b600054600160a01b900460ff16610753576040516308a9441960e31b815260040160405180910390fd5b600080546040516302265e3160e61b81523360048201526001600160a01b03909116906389978c4090602401602060405180830381865afa15801561079c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107c09190610e70565b6001600160a01b0316146107e75760405163acd5a82360e01b815260040160405180910390fd5b6107f33386868661093b565b6104a9338383610991565b6000548390600160a01b900460ff1661082a576040516308a9441960e31b815260040160405180910390fd5b6000546040516302265e3160e61b81526001600160a01b038381166004830152339216906389978c4090602401602060405180830381865afa158015610874573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108989190610e70565b6001600160a01b0316146108bf5760405163acd5a82360e01b815260040160405180910390fd5b6108ca848484610991565b50505050565b6040516001600160a01b03821681527fa4de30a528becadf82649d1395c0e30dd18ae35b5a96ce71e9295bb14bc9f3bc9060200160405180910390a150565b60606109348383604051806060016040528060278152602001610f97602791396109d1565b9392505050565b60408051848152602081018490529081018290526001600160a01b03851660608201527fbf49ccd41a4118c7e1e72143bad844e5f6ed12bf60caa642d88d19ca10244c369060800160405180910390a150505050565b7fc4df5ba16814838ab2618829d68f8623bb897302f24dbdba2279dbe45adb3d148383836040516109c493929190610f27565b60405180910390a1505050565b6060600080856001600160a01b0316856040516109ee9190610f67565b600060405180830381855af49150503d8060008114610a29576040519150601f19603f3d011682016040523d82523d6000602084013e610a2e565b606091505b5091509150610a3f86838387610a49565b9695505050505050565b60608315610abd578251600003610ab6576001600160a01b0385163b610ab65760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e747261637400000060448201526064015b60405180910390fd5b5081610ac7565b610ac78383610acf565b949350505050565b815115610adf5781518083602001fd5b8060405162461bcd60e51b8152600401610aad9190610f83565b6001600160a01b0381168114610b0e57600080fd5b50565b600060208284031215610b2357600080fd5b813561093481610af9565b60008060208385031215610b4157600080fd5b823567ffffffffffffffff80821115610b5957600080fd5b818501915085601f830112610b6d57600080fd5b813581811115610b7c57600080fd5b8660208260051b8501011115610b9157600080fd5b60209290920196919550909350505050565b60005b83811015610bbe578181015183820152602001610ba6565b50506000910152565b60008151808452610bdf816020860160208601610ba3565b601f01601f19169290920160200192915050565b6000602080830181845280855180835260408601915060408160051b870101925083870160005b82811015610c4857603f19888603018452610c36858351610bc7565b94509285019290850190600101610c1a565b5092979650505050505050565b60008060008060808587031215610c6b57600080fd5b8435610c7681610af9565b966020860135965060408601359560600135945092505050565b600080600060608486031215610ca557600080fd5b505081359360208301359350604090920135919050565b60008083601f840112610cce57600080fd5b50813567ffffffffffffffff811115610ce657600080fd5b602083019150836020828501011115610cfe57600080fd5b9250929050565b60008060008060008060a08789031215610d1e57600080fd5b8635610d2981610af9565b9550602087013594506040870135935060608701359250608087013567ffffffffffffffff811115610d5a57600080fd5b610d6689828a01610cbc565b979a9699509497509295939492505050565b60008060208385031215610d8b57600080fd5b823567ffffffffffffffff811115610da257600080fd5b610dae85828601610cbc565b90969095509350505050565b600080600080600060808688031215610dd257600080fd5b853594506020860135935060408601359250606086013567ffffffffffffffff811115610dfe57600080fd5b610e0a88828901610cbc565b969995985093965092949392505050565b600080600060408486031215610e3057600080fd5b8335610e3b81610af9565b9250602084013567ffffffffffffffff811115610e5757600080fd5b610e6386828701610cbc565b9497909650939450505050565b600060208284031215610e8257600080fd5b815161093481610af9565b634e487b7160e01b600052604160045260246000fd5b634e487b7160e01b600052603260045260246000fd5b6000808335601e19843603018112610ed057600080fd5b83018035915067ffffffffffffffff821115610eeb57600080fd5b602001915036819003821315610cfe57600080fd5b600060018201610f2057634e487b7160e01b600052601160045260246000fd5b5060010190565b6001600160a01b03841681526040602082018190528101829052818360608301376000818301606090810191909152601f909201601f1916010192915050565b60008251610f79818460208701610ba3565b9190910192915050565b6020815260006109346020830184610bc756fe416464726573733a206c6f772d6c6576656c2064656c65676174652063616c6c206661696c6564a26469706673582212204e94a7a262a03a87bdda5fc25a815f2cb6c7326b355cb1db90620f5c8b745c7164736f6c63430008130033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R`\0\x80T`\xFF`\xA0\x1B\x19\x16\x90U4\x80\x15a\0\x1DW`\0\x80\xFD[P`@Qa\x10\xF78\x03\x80a\x10\xF7\x839\x81\x01`@\x81\x90Ra\0<\x91a\0\xC5V[a\0E\x81a\0KV[Pa\0\xF5V[`\0T`\x01`\xA0\x1B\x90\x04`\xFF\x16\x15a\0uW`@Qb\xDC\x14\x9F`\xE4\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x01`\x01`\xA0\x1B\x03\x81\x16a\0\x9CW`@QcGN\xBE/`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\0\x80T`\x01`\x01`\xA0\x1B\x03\x90\x92\x16`\x01`\x01`\xA8\x1B\x03\x19\x90\x92\x16\x91\x90\x91\x17`\x01`\xA0\x1B\x17\x90UV[`\0` \x82\x84\x03\x12\x15a\0\xD7W`\0\x80\xFD[\x81Q`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a\0\xEEW`\0\x80\xFD[\x93\x92PPPV[a\x0F\xF3\x80a\x01\x04`\09`\0\xF3\xFE`\x80`@R4\x80\x15a\0\x10W`\0\x80\xFD[P`\x046\x10a\0\x93W`\x005`\xE0\x1C\x80c\xDB\xB9\x8D\x91\x11a\0fW\x80c\xDB\xB9\x8D\x91\x14a\0\xF1W\x80c\xDD\xB9\xDF\xC1\x14a\x01\x04W\x80c\xEA\nR7\x14a\x01\x17W\x80c\xF8\x84\xA9\xCB\x14a\x01*W\x80c\xFA\xD0\xE5\xA2\x14a\x01=W`\0\x80\xFD[\x80c0\x8Cq.\x14a\0\x98W\x80c\xAC\x96P\xD8\x14a\0\xADW\x80c\xB6T\x9Fu\x14a\0\xD6W\x80c\xCA\xE2\xB44\x14a\0\xDEW[`\0\x80\xFD[a\0\xABa\0\xA66`\x04a\x0B\x11V[a\x01PV[\0[a\0\xC0a\0\xBB6`\x04a\x0B.V[a\x02\x1EV[`@Qa\0\xCD\x91\x90a\x0B\xF3V[`@Q\x80\x91\x03\x90\xF3[a\0\xABa\x03\x13V[a\0\xABa\0\xEC6`\x04a\x0CUV[a\x03\xDCV[a\0\xABa\0\xFF6`\x04a\x0C\x90V[a\x04\xB0V[a\0\xABa\x01\x126`\x04a\r\x05V[a\x05\x7FV[a\0\xABa\x01%6`\x04a\rxV[a\x06`V[a\0\xABa\x0186`\x04a\r\xBAV[a\x07)V[a\0\xABa\x01K6`\x04a\x0E\x1BV[a\x07\xFEV[`\0T\x81\x90`\x01`\xA0\x1B\x90\x04`\xFF\x16a\x01|W`@Qc\x08\xA9D\x19`\xE3\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\0T`@Qc\x02&^1`\xE6\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x83\x81\x16`\x04\x83\x01R3\x92\x16\x90c\x89\x97\x8C@\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x01\xC6W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x01\xEA\x91\x90a\x0EpV[`\x01`\x01`\xA0\x1B\x03\x16\x14a\x02\x11W`@Qc\xAC\xD5\xA8#`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x02\x1A\x82a\x08\xD0V[PPV[``\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x029Wa\x029a\x0E\x8DV[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x02lW\x81` \x01[``\x81R` \x01\x90`\x01\x90\x03\x90\x81a\x02WW\x90P[P\x90P`\0[\x82\x81\x10\x15a\x03\x0CWa\x02\xDC0\x85\x85\x84\x81\x81\x10a\x02\x90Wa\x02\x90a\x0E\xA3V[\x90P` \x02\x81\x01\x90a\x02\xA2\x91\x90a\x0E\xB9V[\x80\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83\x80\x82\x847`\0\x92\x01\x91\x90\x91RPa\t\x0F\x92PPPV[\x82\x82\x81Q\x81\x10a\x02\xEEWa\x02\xEEa\x0E\xA3V[` \x02` \x01\x01\x81\x90RP\x80\x80a\x03\x04\x90a\x0F\0V[\x91PPa\x02rV[P\x92\x91PPV[`\0T`\x01`\xA0\x1B\x90\x04`\xFF\x16a\x03=W`@Qc\x08\xA9D\x19`\xE3\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\0\x80T`@Qc\x02&^1`\xE6\x1B\x81R3`\x04\x82\x01R`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x90c\x89\x97\x8C@\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x03\x86W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x03\xAA\x91\x90a\x0EpV[`\x01`\x01`\xA0\x1B\x03\x16\x14a\x03\xD1W`@Qc\xAC\xD5\xA8#`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x03\xDA3a\x08\xD0V[V[`\0T\x84\x90`\x01`\xA0\x1B\x90\x04`\xFF\x16a\x04\x08W`@Qc\x08\xA9D\x19`\xE3\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\0T`@Qc\x02&^1`\xE6\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x83\x81\x16`\x04\x83\x01R3\x92\x16\x90c\x89\x97\x8C@\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x04RW=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x04v\x91\x90a\x0EpV[`\x01`\x01`\xA0\x1B\x03\x16\x14a\x04\x9DW`@Qc\xAC\xD5\xA8#`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x04\xA9\x85\x85\x85\x85a\t;V[PPPPPV[`\0T`\x01`\xA0\x1B\x90\x04`\xFF\x16a\x04\xDAW`@Qc\x08\xA9D\x19`\xE3\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\0\x80T`@Qc\x02&^1`\xE6\x1B\x81R3`\x04\x82\x01R`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x90c\x89\x97\x8C@\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x05#W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x05G\x91\x90a\x0EpV[`\x01`\x01`\xA0\x1B\x03\x16\x14a\x05nW`@Qc\xAC\xD5\xA8#`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x05z3\x84\x84\x84a\t;V[PPPV[`\0T\x86\x90`\x01`\xA0\x1B\x90\x04`\xFF\x16a\x05\xABW`@Qc\x08\xA9D\x19`\xE3\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\0T`@Qc\x02&^1`\xE6\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x83\x81\x16`\x04\x83\x01R3\x92\x16\x90c\x89\x97\x8C@\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x05\xF5W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x06\x19\x91\x90a\x0EpV[`\x01`\x01`\xA0\x1B\x03\x16\x14a\x06@W`@Qc\xAC\xD5\xA8#`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x06L\x87\x87\x87\x87a\t;V[a\x06W\x87\x84\x84a\t\x91V[PPPPPPPV[`\0T`\x01`\xA0\x1B\x90\x04`\xFF\x16a\x06\x8AW`@Qc\x08\xA9D\x19`\xE3\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\0\x80T`@Qc\x02&^1`\xE6\x1B\x81R3`\x04\x82\x01R`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x90c\x89\x97\x8C@\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x06\xD3W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x06\xF7\x91\x90a\x0EpV[`\x01`\x01`\xA0\x1B\x03\x16\x14a\x07\x1EW`@Qc\xAC\xD5\xA8#`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x02\x1A3\x83\x83a\t\x91V[`\0T`\x01`\xA0\x1B\x90\x04`\xFF\x16a\x07SW`@Qc\x08\xA9D\x19`\xE3\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\0\x80T`@Qc\x02&^1`\xE6\x1B\x81R3`\x04\x82\x01R`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x90c\x89\x97\x8C@\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x07\x9CW=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x07\xC0\x91\x90a\x0EpV[`\x01`\x01`\xA0\x1B\x03\x16\x14a\x07\xE7W`@Qc\xAC\xD5\xA8#`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x07\xF33\x86\x86\x86a\t;V[a\x04\xA93\x83\x83a\t\x91V[`\0T\x83\x90`\x01`\xA0\x1B\x90\x04`\xFF\x16a\x08*W`@Qc\x08\xA9D\x19`\xE3\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\0T`@Qc\x02&^1`\xE6\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x83\x81\x16`\x04\x83\x01R3\x92\x16\x90c\x89\x97\x8C@\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x08tW=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x08\x98\x91\x90a\x0EpV[`\x01`\x01`\xA0\x1B\x03\x16\x14a\x08\xBFW`@Qc\xAC\xD5\xA8#`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x08\xCA\x84\x84\x84a\t\x91V[PPPPV[`@Q`\x01`\x01`\xA0\x1B\x03\x82\x16\x81R\x7F\xA4\xDE0\xA5(\xBE\xCA\xDF\x82d\x9D\x13\x95\xC0\xE3\r\xD1\x8A\xE3[Z\x96\xCEq\xE9)[\xB1K\xC9\xF3\xBC\x90` \x01`@Q\x80\x91\x03\x90\xA1PV[``a\t4\x83\x83`@Q\x80``\x01`@R\x80`'\x81R` \x01a\x0F\x97`'\x919a\t\xD1V[\x93\x92PPPV[`@\x80Q\x84\x81R` \x81\x01\x84\x90R\x90\x81\x01\x82\x90R`\x01`\x01`\xA0\x1B\x03\x85\x16``\x82\x01R\x7F\xBFI\xCC\xD4\x1AA\x18\xC7\xE1\xE7!C\xBA\xD8D\xE5\xF6\xED\x12\xBF`\xCA\xA6B\xD8\x8D\x19\xCA\x10$L6\x90`\x80\x01`@Q\x80\x91\x03\x90\xA1PPPPV[\x7F\xC4\xDF[\xA1h\x14\x83\x8A\xB2a\x88)\xD6\x8F\x86#\xBB\x89s\x02\xF2M\xBD\xBA\"y\xDB\xE4Z\xDB=\x14\x83\x83\x83`@Qa\t\xC4\x93\x92\x91\x90a\x0F'V[`@Q\x80\x91\x03\x90\xA1PPPV[```\0\x80\x85`\x01`\x01`\xA0\x1B\x03\x16\x85`@Qa\t\xEE\x91\x90a\x0FgV[`\0`@Q\x80\x83\x03\x81\x85Z\xF4\x91PP=\x80`\0\x81\x14a\n)W`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=`\0` \x84\x01>a\n.V[``\x91P[P\x91P\x91Pa\n?\x86\x83\x83\x87a\nIV[\x96\x95PPPPPPV[``\x83\x15a\n\xBDW\x82Q`\0\x03a\n\xB6W`\x01`\x01`\xA0\x1B\x03\x85\x16;a\n\xB6W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1D`$\x82\x01R\x7FAddress: call to non-contract\0\0\0`D\x82\x01R`d\x01[`@Q\x80\x91\x03\x90\xFD[P\x81a\n\xC7V[a\n\xC7\x83\x83a\n\xCFV[\x94\x93PPPPV[\x81Q\x15a\n\xDFW\x81Q\x80\x83` \x01\xFD[\x80`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\n\xAD\x91\x90a\x0F\x83V[`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a\x0B\x0EW`\0\x80\xFD[PV[`\0` \x82\x84\x03\x12\x15a\x0B#W`\0\x80\xFD[\x815a\t4\x81a\n\xF9V[`\0\x80` \x83\x85\x03\x12\x15a\x0BAW`\0\x80\xFD[\x825g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x82\x11\x15a\x0BYW`\0\x80\xFD[\x81\x85\x01\x91P\x85`\x1F\x83\x01\x12a\x0BmW`\0\x80\xFD[\x815\x81\x81\x11\x15a\x0B|W`\0\x80\xFD[\x86` \x82`\x05\x1B\x85\x01\x01\x11\x15a\x0B\x91W`\0\x80\xFD[` \x92\x90\x92\x01\x96\x91\x95P\x90\x93PPPPV[`\0[\x83\x81\x10\x15a\x0B\xBEW\x81\x81\x01Q\x83\x82\x01R` \x01a\x0B\xA6V[PP`\0\x91\x01RV[`\0\x81Q\x80\x84Ra\x0B\xDF\x81` \x86\x01` \x86\x01a\x0B\xA3V[`\x1F\x01`\x1F\x19\x16\x92\x90\x92\x01` \x01\x92\x91PPV[`\0` \x80\x83\x01\x81\x84R\x80\x85Q\x80\x83R`@\x86\x01\x91P`@\x81`\x05\x1B\x87\x01\x01\x92P\x83\x87\x01`\0[\x82\x81\x10\x15a\x0CHW`?\x19\x88\x86\x03\x01\x84Ra\x0C6\x85\x83Qa\x0B\xC7V[\x94P\x92\x85\x01\x92\x90\x85\x01\x90`\x01\x01a\x0C\x1AV[P\x92\x97\x96PPPPPPPV[`\0\x80`\0\x80`\x80\x85\x87\x03\x12\x15a\x0CkW`\0\x80\xFD[\x845a\x0Cv\x81a\n\xF9V[\x96` \x86\x015\x96P`@\x86\x015\x95``\x015\x94P\x92PPPV[`\0\x80`\0``\x84\x86\x03\x12\x15a\x0C\xA5W`\0\x80\xFD[PP\x815\x93` \x83\x015\x93P`@\x90\x92\x015\x91\x90PV[`\0\x80\x83`\x1F\x84\x01\x12a\x0C\xCEW`\0\x80\xFD[P\x815g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x0C\xE6W`\0\x80\xFD[` \x83\x01\x91P\x83` \x82\x85\x01\x01\x11\x15a\x0C\xFEW`\0\x80\xFD[\x92P\x92\x90PV[`\0\x80`\0\x80`\0\x80`\xA0\x87\x89\x03\x12\x15a\r\x1EW`\0\x80\xFD[\x865a\r)\x81a\n\xF9V[\x95P` \x87\x015\x94P`@\x87\x015\x93P``\x87\x015\x92P`\x80\x87\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\rZW`\0\x80\xFD[a\rf\x89\x82\x8A\x01a\x0C\xBCV[\x97\x9A\x96\x99P\x94\x97P\x92\x95\x93\x94\x92PPPV[`\0\x80` \x83\x85\x03\x12\x15a\r\x8BW`\0\x80\xFD[\x825g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\r\xA2W`\0\x80\xFD[a\r\xAE\x85\x82\x86\x01a\x0C\xBCV[\x90\x96\x90\x95P\x93PPPPV[`\0\x80`\0\x80`\0`\x80\x86\x88\x03\x12\x15a\r\xD2W`\0\x80\xFD[\x855\x94P` \x86\x015\x93P`@\x86\x015\x92P``\x86\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\r\xFEW`\0\x80\xFD[a\x0E\n\x88\x82\x89\x01a\x0C\xBCV[\x96\x99\x95\x98P\x93\x96P\x92\x94\x93\x92PPPV[`\0\x80`\0`@\x84\x86\x03\x12\x15a\x0E0W`\0\x80\xFD[\x835a\x0E;\x81a\n\xF9V[\x92P` \x84\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x0EWW`\0\x80\xFD[a\x0Ec\x86\x82\x87\x01a\x0C\xBCV[\x94\x97\x90\x96P\x93\x94PPPPV[`\0` \x82\x84\x03\x12\x15a\x0E\x82W`\0\x80\xFD[\x81Qa\t4\x81a\n\xF9V[cNH{q`\xE0\x1B`\0R`A`\x04R`$`\0\xFD[cNH{q`\xE0\x1B`\0R`2`\x04R`$`\0\xFD[`\0\x80\x835`\x1E\x19\x846\x03\x01\x81\x12a\x0E\xD0W`\0\x80\xFD[\x83\x01\x805\x91Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a\x0E\xEBW`\0\x80\xFD[` \x01\x91P6\x81\x90\x03\x82\x13\x15a\x0C\xFEW`\0\x80\xFD[`\0`\x01\x82\x01a\x0F WcNH{q`\xE0\x1B`\0R`\x11`\x04R`$`\0\xFD[P`\x01\x01\x90V[`\x01`\x01`\xA0\x1B\x03\x84\x16\x81R`@` \x82\x01\x81\x90R\x81\x01\x82\x90R\x81\x83``\x83\x017`\0\x81\x83\x01``\x90\x81\x01\x91\x90\x91R`\x1F\x90\x92\x01`\x1F\x19\x16\x01\x01\x92\x91PPV[`\0\x82Qa\x0Fy\x81\x84` \x87\x01a\x0B\xA3V[\x91\x90\x91\x01\x92\x91PPV[` \x81R`\0a\t4` \x83\x01\x84a\x0B\xC7V\xFEAddress: low-level delegate call failed\xA2dipfsX\"\x12 N\x94\xA7\xA2b\xA0:\x87\xBD\xDA_\xC2Z\x81_,\xB6\xC72k5\\\xB1\xDB\x90b\x0F\\\x8Bt\\qdsolcC\0\x08\x13\x003",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x608060405234801561001057600080fd5b50600436106100935760003560e01c8063dbb98d9111610066578063dbb98d91146100f1578063ddb9dfc114610104578063ea0a523714610117578063f884a9cb1461012a578063fad0e5a21461013d57600080fd5b8063308c712e14610098578063ac9650d8146100ad578063b6549f75146100d6578063cae2b434146100de575b600080fd5b6100ab6100a6366004610b11565b610150565b005b6100c06100bb366004610b2e565b61021e565b6040516100cd9190610bf3565b60405180910390f35b6100ab610313565b6100ab6100ec366004610c55565b6103dc565b6100ab6100ff366004610c90565b6104b0565b6100ab610112366004610d05565b61057f565b6100ab610125366004610d78565b610660565b6100ab610138366004610dba565b610729565b6100ab61014b366004610e1b565b6107fe565b6000548190600160a01b900460ff1661017c576040516308a9441960e31b815260040160405180910390fd5b6000546040516302265e3160e61b81526001600160a01b038381166004830152339216906389978c4090602401602060405180830381865afa1580156101c6573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101ea9190610e70565b6001600160a01b0316146102115760405163acd5a82360e01b815260040160405180910390fd5b61021a826108d0565b5050565b60608167ffffffffffffffff81111561023957610239610e8d565b60405190808252806020026020018201604052801561026c57816020015b60608152602001906001900390816102575790505b50905060005b8281101561030c576102dc3085858481811061029057610290610ea3565b90506020028101906102a29190610eb9565b8080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061090f92505050565b8282815181106102ee576102ee610ea3565b6020026020010181905250808061030490610f00565b915050610272565b5092915050565b600054600160a01b900460ff1661033d576040516308a9441960e31b815260040160405180910390fd5b600080546040516302265e3160e61b81523360048201526001600160a01b03909116906389978c4090602401602060405180830381865afa158015610386573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103aa9190610e70565b6001600160a01b0316146103d15760405163acd5a82360e01b815260040160405180910390fd5b6103da336108d0565b565b6000548490600160a01b900460ff16610408576040516308a9441960e31b815260040160405180910390fd5b6000546040516302265e3160e61b81526001600160a01b038381166004830152339216906389978c4090602401602060405180830381865afa158015610452573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104769190610e70565b6001600160a01b03161461049d5760405163acd5a82360e01b815260040160405180910390fd5b6104a98585858561093b565b5050505050565b600054600160a01b900460ff166104da576040516308a9441960e31b815260040160405180910390fd5b600080546040516302265e3160e61b81523360048201526001600160a01b03909116906389978c4090602401602060405180830381865afa158015610523573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105479190610e70565b6001600160a01b03161461056e5760405163acd5a82360e01b815260040160405180910390fd5b61057a3384848461093b565b505050565b6000548690600160a01b900460ff166105ab576040516308a9441960e31b815260040160405180910390fd5b6000546040516302265e3160e61b81526001600160a01b038381166004830152339216906389978c4090602401602060405180830381865afa1580156105f5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106199190610e70565b6001600160a01b0316146106405760405163acd5a82360e01b815260040160405180910390fd5b61064c8787878761093b565b610657878484610991565b50505050505050565b600054600160a01b900460ff1661068a576040516308a9441960e31b815260040160405180910390fd5b600080546040516302265e3160e61b81523360048201526001600160a01b03909116906389978c4090602401602060405180830381865afa1580156106d3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106f79190610e70565b6001600160a01b03161461071e5760405163acd5a82360e01b815260040160405180910390fd5b61021a338383610991565b600054600160a01b900460ff16610753576040516308a9441960e31b815260040160405180910390fd5b600080546040516302265e3160e61b81523360048201526001600160a01b03909116906389978c4090602401602060405180830381865afa15801561079c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107c09190610e70565b6001600160a01b0316146107e75760405163acd5a82360e01b815260040160405180910390fd5b6107f33386868661093b565b6104a9338383610991565b6000548390600160a01b900460ff1661082a576040516308a9441960e31b815260040160405180910390fd5b6000546040516302265e3160e61b81526001600160a01b038381166004830152339216906389978c4090602401602060405180830381865afa158015610874573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108989190610e70565b6001600160a01b0316146108bf5760405163acd5a82360e01b815260040160405180910390fd5b6108ca848484610991565b50505050565b6040516001600160a01b03821681527fa4de30a528becadf82649d1395c0e30dd18ae35b5a96ce71e9295bb14bc9f3bc9060200160405180910390a150565b60606109348383604051806060016040528060278152602001610f97602791396109d1565b9392505050565b60408051848152602081018490529081018290526001600160a01b03851660608201527fbf49ccd41a4118c7e1e72143bad844e5f6ed12bf60caa642d88d19ca10244c369060800160405180910390a150505050565b7fc4df5ba16814838ab2618829d68f8623bb897302f24dbdba2279dbe45adb3d148383836040516109c493929190610f27565b60405180910390a1505050565b6060600080856001600160a01b0316856040516109ee9190610f67565b600060405180830381855af49150503d8060008114610a29576040519150601f19603f3d011682016040523d82523d6000602084013e610a2e565b606091505b5091509150610a3f86838387610a49565b9695505050505050565b60608315610abd578251600003610ab6576001600160a01b0385163b610ab65760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e747261637400000060448201526064015b60405180910390fd5b5081610ac7565b610ac78383610acf565b949350505050565b815115610adf5781518083602001fd5b8060405162461bcd60e51b8152600401610aad9190610f83565b6001600160a01b0381168114610b0e57600080fd5b50565b600060208284031215610b2357600080fd5b813561093481610af9565b60008060208385031215610b4157600080fd5b823567ffffffffffffffff80821115610b5957600080fd5b818501915085601f830112610b6d57600080fd5b813581811115610b7c57600080fd5b8660208260051b8501011115610b9157600080fd5b60209290920196919550909350505050565b60005b83811015610bbe578181015183820152602001610ba6565b50506000910152565b60008151808452610bdf816020860160208601610ba3565b601f01601f19169290920160200192915050565b6000602080830181845280855180835260408601915060408160051b870101925083870160005b82811015610c4857603f19888603018452610c36858351610bc7565b94509285019290850190600101610c1a565b5092979650505050505050565b60008060008060808587031215610c6b57600080fd5b8435610c7681610af9565b966020860135965060408601359560600135945092505050565b600080600060608486031215610ca557600080fd5b505081359360208301359350604090920135919050565b60008083601f840112610cce57600080fd5b50813567ffffffffffffffff811115610ce657600080fd5b602083019150836020828501011115610cfe57600080fd5b9250929050565b60008060008060008060a08789031215610d1e57600080fd5b8635610d2981610af9565b9550602087013594506040870135935060608701359250608087013567ffffffffffffffff811115610d5a57600080fd5b610d6689828a01610cbc565b979a9699509497509295939492505050565b60008060208385031215610d8b57600080fd5b823567ffffffffffffffff811115610da257600080fd5b610dae85828601610cbc565b90969095509350505050565b600080600080600060808688031215610dd257600080fd5b853594506020860135935060408601359250606086013567ffffffffffffffff811115610dfe57600080fd5b610e0a88828901610cbc565b969995985093965092949392505050565b600080600060408486031215610e3057600080fd5b8335610e3b81610af9565b9250602084013567ffffffffffffffff811115610e5757600080fd5b610e6386828701610cbc565b9497909650939450505050565b600060208284031215610e8257600080fd5b815161093481610af9565b634e487b7160e01b600052604160045260246000fd5b634e487b7160e01b600052603260045260246000fd5b6000808335601e19843603018112610ed057600080fd5b83018035915067ffffffffffffffff821115610eeb57600080fd5b602001915036819003821315610cfe57600080fd5b600060018201610f2057634e487b7160e01b600052601160045260246000fd5b5060010190565b6001600160a01b03841681526040602082018190528101829052818360608301376000818301606090810191909152601f909201601f1916010192915050565b60008251610f79818460208701610ba3565b9190910192915050565b6020815260006109346020830184610bc756fe416464726573733a206c6f772d6c6576656c2064656c65676174652063616c6c206661696c6564a26469706673582212204e94a7a262a03a87bdda5fc25a815f2cb6c7326b355cb1db90620f5c8b745c7164736f6c63430008130033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R4\x80\x15a\0\x10W`\0\x80\xFD[P`\x046\x10a\0\x93W`\x005`\xE0\x1C\x80c\xDB\xB9\x8D\x91\x11a\0fW\x80c\xDB\xB9\x8D\x91\x14a\0\xF1W\x80c\xDD\xB9\xDF\xC1\x14a\x01\x04W\x80c\xEA\nR7\x14a\x01\x17W\x80c\xF8\x84\xA9\xCB\x14a\x01*W\x80c\xFA\xD0\xE5\xA2\x14a\x01=W`\0\x80\xFD[\x80c0\x8Cq.\x14a\0\x98W\x80c\xAC\x96P\xD8\x14a\0\xADW\x80c\xB6T\x9Fu\x14a\0\xD6W\x80c\xCA\xE2\xB44\x14a\0\xDEW[`\0\x80\xFD[a\0\xABa\0\xA66`\x04a\x0B\x11V[a\x01PV[\0[a\0\xC0a\0\xBB6`\x04a\x0B.V[a\x02\x1EV[`@Qa\0\xCD\x91\x90a\x0B\xF3V[`@Q\x80\x91\x03\x90\xF3[a\0\xABa\x03\x13V[a\0\xABa\0\xEC6`\x04a\x0CUV[a\x03\xDCV[a\0\xABa\0\xFF6`\x04a\x0C\x90V[a\x04\xB0V[a\0\xABa\x01\x126`\x04a\r\x05V[a\x05\x7FV[a\0\xABa\x01%6`\x04a\rxV[a\x06`V[a\0\xABa\x0186`\x04a\r\xBAV[a\x07)V[a\0\xABa\x01K6`\x04a\x0E\x1BV[a\x07\xFEV[`\0T\x81\x90`\x01`\xA0\x1B\x90\x04`\xFF\x16a\x01|W`@Qc\x08\xA9D\x19`\xE3\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\0T`@Qc\x02&^1`\xE6\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x83\x81\x16`\x04\x83\x01R3\x92\x16\x90c\x89\x97\x8C@\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x01\xC6W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x01\xEA\x91\x90a\x0EpV[`\x01`\x01`\xA0\x1B\x03\x16\x14a\x02\x11W`@Qc\xAC\xD5\xA8#`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x02\x1A\x82a\x08\xD0V[PPV[``\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x029Wa\x029a\x0E\x8DV[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x02lW\x81` \x01[``\x81R` \x01\x90`\x01\x90\x03\x90\x81a\x02WW\x90P[P\x90P`\0[\x82\x81\x10\x15a\x03\x0CWa\x02\xDC0\x85\x85\x84\x81\x81\x10a\x02\x90Wa\x02\x90a\x0E\xA3V[\x90P` \x02\x81\x01\x90a\x02\xA2\x91\x90a\x0E\xB9V[\x80\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83\x80\x82\x847`\0\x92\x01\x91\x90\x91RPa\t\x0F\x92PPPV[\x82\x82\x81Q\x81\x10a\x02\xEEWa\x02\xEEa\x0E\xA3V[` \x02` \x01\x01\x81\x90RP\x80\x80a\x03\x04\x90a\x0F\0V[\x91PPa\x02rV[P\x92\x91PPV[`\0T`\x01`\xA0\x1B\x90\x04`\xFF\x16a\x03=W`@Qc\x08\xA9D\x19`\xE3\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\0\x80T`@Qc\x02&^1`\xE6\x1B\x81R3`\x04\x82\x01R`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x90c\x89\x97\x8C@\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x03\x86W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x03\xAA\x91\x90a\x0EpV[`\x01`\x01`\xA0\x1B\x03\x16\x14a\x03\xD1W`@Qc\xAC\xD5\xA8#`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x03\xDA3a\x08\xD0V[V[`\0T\x84\x90`\x01`\xA0\x1B\x90\x04`\xFF\x16a\x04\x08W`@Qc\x08\xA9D\x19`\xE3\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\0T`@Qc\x02&^1`\xE6\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x83\x81\x16`\x04\x83\x01R3\x92\x16\x90c\x89\x97\x8C@\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x04RW=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x04v\x91\x90a\x0EpV[`\x01`\x01`\xA0\x1B\x03\x16\x14a\x04\x9DW`@Qc\xAC\xD5\xA8#`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x04\xA9\x85\x85\x85\x85a\t;V[PPPPPV[`\0T`\x01`\xA0\x1B\x90\x04`\xFF\x16a\x04\xDAW`@Qc\x08\xA9D\x19`\xE3\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\0\x80T`@Qc\x02&^1`\xE6\x1B\x81R3`\x04\x82\x01R`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x90c\x89\x97\x8C@\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x05#W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x05G\x91\x90a\x0EpV[`\x01`\x01`\xA0\x1B\x03\x16\x14a\x05nW`@Qc\xAC\xD5\xA8#`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x05z3\x84\x84\x84a\t;V[PPPV[`\0T\x86\x90`\x01`\xA0\x1B\x90\x04`\xFF\x16a\x05\xABW`@Qc\x08\xA9D\x19`\xE3\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\0T`@Qc\x02&^1`\xE6\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x83\x81\x16`\x04\x83\x01R3\x92\x16\x90c\x89\x97\x8C@\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x05\xF5W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x06\x19\x91\x90a\x0EpV[`\x01`\x01`\xA0\x1B\x03\x16\x14a\x06@W`@Qc\xAC\xD5\xA8#`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x06L\x87\x87\x87\x87a\t;V[a\x06W\x87\x84\x84a\t\x91V[PPPPPPPV[`\0T`\x01`\xA0\x1B\x90\x04`\xFF\x16a\x06\x8AW`@Qc\x08\xA9D\x19`\xE3\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\0\x80T`@Qc\x02&^1`\xE6\x1B\x81R3`\x04\x82\x01R`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x90c\x89\x97\x8C@\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x06\xD3W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x06\xF7\x91\x90a\x0EpV[`\x01`\x01`\xA0\x1B\x03\x16\x14a\x07\x1EW`@Qc\xAC\xD5\xA8#`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x02\x1A3\x83\x83a\t\x91V[`\0T`\x01`\xA0\x1B\x90\x04`\xFF\x16a\x07SW`@Qc\x08\xA9D\x19`\xE3\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\0\x80T`@Qc\x02&^1`\xE6\x1B\x81R3`\x04\x82\x01R`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x90c\x89\x97\x8C@\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x07\x9CW=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x07\xC0\x91\x90a\x0EpV[`\x01`\x01`\xA0\x1B\x03\x16\x14a\x07\xE7W`@Qc\xAC\xD5\xA8#`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x07\xF33\x86\x86\x86a\t;V[a\x04\xA93\x83\x83a\t\x91V[`\0T\x83\x90`\x01`\xA0\x1B\x90\x04`\xFF\x16a\x08*W`@Qc\x08\xA9D\x19`\xE3\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\0T`@Qc\x02&^1`\xE6\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x83\x81\x16`\x04\x83\x01R3\x92\x16\x90c\x89\x97\x8C@\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x08tW=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x08\x98\x91\x90a\x0EpV[`\x01`\x01`\xA0\x1B\x03\x16\x14a\x08\xBFW`@Qc\xAC\xD5\xA8#`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x08\xCA\x84\x84\x84a\t\x91V[PPPPV[`@Q`\x01`\x01`\xA0\x1B\x03\x82\x16\x81R\x7F\xA4\xDE0\xA5(\xBE\xCA\xDF\x82d\x9D\x13\x95\xC0\xE3\r\xD1\x8A\xE3[Z\x96\xCEq\xE9)[\xB1K\xC9\xF3\xBC\x90` \x01`@Q\x80\x91\x03\x90\xA1PV[``a\t4\x83\x83`@Q\x80``\x01`@R\x80`'\x81R` \x01a\x0F\x97`'\x919a\t\xD1V[\x93\x92PPPV[`@\x80Q\x84\x81R` \x81\x01\x84\x90R\x90\x81\x01\x82\x90R`\x01`\x01`\xA0\x1B\x03\x85\x16``\x82\x01R\x7F\xBFI\xCC\xD4\x1AA\x18\xC7\xE1\xE7!C\xBA\xD8D\xE5\xF6\xED\x12\xBF`\xCA\xA6B\xD8\x8D\x19\xCA\x10$L6\x90`\x80\x01`@Q\x80\x91\x03\x90\xA1PPPPV[\x7F\xC4\xDF[\xA1h\x14\x83\x8A\xB2a\x88)\xD6\x8F\x86#\xBB\x89s\x02\xF2M\xBD\xBA\"y\xDB\xE4Z\xDB=\x14\x83\x83\x83`@Qa\t\xC4\x93\x92\x91\x90a\x0F'V[`@Q\x80\x91\x03\x90\xA1PPPV[```\0\x80\x85`\x01`\x01`\xA0\x1B\x03\x16\x85`@Qa\t\xEE\x91\x90a\x0FgV[`\0`@Q\x80\x83\x03\x81\x85Z\xF4\x91PP=\x80`\0\x81\x14a\n)W`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=`\0` \x84\x01>a\n.V[``\x91P[P\x91P\x91Pa\n?\x86\x83\x83\x87a\nIV[\x96\x95PPPPPPV[``\x83\x15a\n\xBDW\x82Q`\0\x03a\n\xB6W`\x01`\x01`\xA0\x1B\x03\x85\x16;a\n\xB6W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1D`$\x82\x01R\x7FAddress: call to non-contract\0\0\0`D\x82\x01R`d\x01[`@Q\x80\x91\x03\x90\xFD[P\x81a\n\xC7V[a\n\xC7\x83\x83a\n\xCFV[\x94\x93PPPPV[\x81Q\x15a\n\xDFW\x81Q\x80\x83` \x01\xFD[\x80`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\n\xAD\x91\x90a\x0F\x83V[`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a\x0B\x0EW`\0\x80\xFD[PV[`\0` \x82\x84\x03\x12\x15a\x0B#W`\0\x80\xFD[\x815a\t4\x81a\n\xF9V[`\0\x80` \x83\x85\x03\x12\x15a\x0BAW`\0\x80\xFD[\x825g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x82\x11\x15a\x0BYW`\0\x80\xFD[\x81\x85\x01\x91P\x85`\x1F\x83\x01\x12a\x0BmW`\0\x80\xFD[\x815\x81\x81\x11\x15a\x0B|W`\0\x80\xFD[\x86` \x82`\x05\x1B\x85\x01\x01\x11\x15a\x0B\x91W`\0\x80\xFD[` \x92\x90\x92\x01\x96\x91\x95P\x90\x93PPPPV[`\0[\x83\x81\x10\x15a\x0B\xBEW\x81\x81\x01Q\x83\x82\x01R` \x01a\x0B\xA6V[PP`\0\x91\x01RV[`\0\x81Q\x80\x84Ra\x0B\xDF\x81` \x86\x01` \x86\x01a\x0B\xA3V[`\x1F\x01`\x1F\x19\x16\x92\x90\x92\x01` \x01\x92\x91PPV[`\0` \x80\x83\x01\x81\x84R\x80\x85Q\x80\x83R`@\x86\x01\x91P`@\x81`\x05\x1B\x87\x01\x01\x92P\x83\x87\x01`\0[\x82\x81\x10\x15a\x0CHW`?\x19\x88\x86\x03\x01\x84Ra\x0C6\x85\x83Qa\x0B\xC7V[\x94P\x92\x85\x01\x92\x90\x85\x01\x90`\x01\x01a\x0C\x1AV[P\x92\x97\x96PPPPPPPV[`\0\x80`\0\x80`\x80\x85\x87\x03\x12\x15a\x0CkW`\0\x80\xFD[\x845a\x0Cv\x81a\n\xF9V[\x96` \x86\x015\x96P`@\x86\x015\x95``\x015\x94P\x92PPPV[`\0\x80`\0``\x84\x86\x03\x12\x15a\x0C\xA5W`\0\x80\xFD[PP\x815\x93` \x83\x015\x93P`@\x90\x92\x015\x91\x90PV[`\0\x80\x83`\x1F\x84\x01\x12a\x0C\xCEW`\0\x80\xFD[P\x815g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x0C\xE6W`\0\x80\xFD[` \x83\x01\x91P\x83` \x82\x85\x01\x01\x11\x15a\x0C\xFEW`\0\x80\xFD[\x92P\x92\x90PV[`\0\x80`\0\x80`\0\x80`\xA0\x87\x89\x03\x12\x15a\r\x1EW`\0\x80\xFD[\x865a\r)\x81a\n\xF9V[\x95P` \x87\x015\x94P`@\x87\x015\x93P``\x87\x015\x92P`\x80\x87\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\rZW`\0\x80\xFD[a\rf\x89\x82\x8A\x01a\x0C\xBCV[\x97\x9A\x96\x99P\x94\x97P\x92\x95\x93\x94\x92PPPV[`\0\x80` \x83\x85\x03\x12\x15a\r\x8BW`\0\x80\xFD[\x825g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\r\xA2W`\0\x80\xFD[a\r\xAE\x85\x82\x86\x01a\x0C\xBCV[\x90\x96\x90\x95P\x93PPPPV[`\0\x80`\0\x80`\0`\x80\x86\x88\x03\x12\x15a\r\xD2W`\0\x80\xFD[\x855\x94P` \x86\x015\x93P`@\x86\x015\x92P``\x86\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\r\xFEW`\0\x80\xFD[a\x0E\n\x88\x82\x89\x01a\x0C\xBCV[\x96\x99\x95\x98P\x93\x96P\x92\x94\x93\x92PPPV[`\0\x80`\0`@\x84\x86\x03\x12\x15a\x0E0W`\0\x80\xFD[\x835a\x0E;\x81a\n\xF9V[\x92P` \x84\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x0EWW`\0\x80\xFD[a\x0Ec\x86\x82\x87\x01a\x0C\xBCV[\x94\x97\x90\x96P\x93\x94PPPPV[`\0` \x82\x84\x03\x12\x15a\x0E\x82W`\0\x80\xFD[\x81Qa\t4\x81a\n\xF9V[cNH{q`\xE0\x1B`\0R`A`\x04R`$`\0\xFD[cNH{q`\xE0\x1B`\0R`2`\x04R`$`\0\xFD[`\0\x80\x835`\x1E\x19\x846\x03\x01\x81\x12a\x0E\xD0W`\0\x80\xFD[\x83\x01\x805\x91Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a\x0E\xEBW`\0\x80\xFD[` \x01\x91P6\x81\x90\x03\x82\x13\x15a\x0C\xFEW`\0\x80\xFD[`\0`\x01\x82\x01a\x0F WcNH{q`\xE0\x1B`\0R`\x11`\x04R`$`\0\xFD[P`\x01\x01\x90V[`\x01`\x01`\xA0\x1B\x03\x84\x16\x81R`@` \x82\x01\x81\x90R\x81\x01\x82\x90R\x81\x83``\x83\x017`\0\x81\x83\x01``\x90\x81\x01\x91\x90\x91R`\x1F\x90\x92\x01`\x1F\x19\x16\x01\x01\x92\x91PPV[`\0\x82Qa\x0Fy\x81\x84` \x87\x01a\x0B\xA3V[\x91\x90\x91\x01\x92\x91PPV[` \x81R`\0a\t4` \x83\x01\x84a\x0B\xC7V\xFEAddress: low-level delegate call failed\xA2dipfsX\"\x12 N\x94\xA7\xA2b\xA0:\x87\xBD\xDA_\xC2Z\x81_,\xB6\xC72k5\\\xB1\xDB\x90b\x0F\\\x8Bt\\qdsolcC\0\x08\x13\x003",
    );
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `AlreadyInitialized()` and selector `0x0dc149f0`.
```solidity
error AlreadyInitialized();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AlreadyInitialized;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AlreadyInitialized> for UnderlyingRustTuple<'_> {
            fn from(value: AlreadyInitialized) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for AlreadyInitialized {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AlreadyInitialized {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AlreadyInitialized()";
            const SELECTOR: [u8; 4] = [13u8, 193u8, 73u8, 240u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ContractNotResponsible()` and selector `0xacd5a823`.
```solidity
error ContractNotResponsible();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ContractNotResponsible;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ContractNotResponsible> for UnderlyingRustTuple<'_> {
            fn from(value: ContractNotResponsible) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ContractNotResponsible {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ContractNotResponsible {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ContractNotResponsible()";
            const SELECTOR: [u8; 4] = [172u8, 213u8, 168u8, 35u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidSafeAddress()` and selector `0x8e9d7c5e`.
```solidity
error InvalidSafeAddress();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidSafeAddress;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidSafeAddress> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidSafeAddress) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidSafeAddress {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidSafeAddress {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidSafeAddress()";
            const SELECTOR: [u8; 4] = [142u8, 157u8, 124u8, 94u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `MultiSigUninitialized()` and selector `0x454a20c8`.
```solidity
error MultiSigUninitialized();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct MultiSigUninitialized;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<MultiSigUninitialized> for UnderlyingRustTuple<'_> {
            fn from(value: MultiSigUninitialized) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for MultiSigUninitialized {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for MultiSigUninitialized {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "MultiSigUninitialized()";
            const SELECTOR: [u8; 4] = [69u8, 74u8, 32u8, 200u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `AddressAnnouncement(address,string)` and selector `0xc4df5ba16814838ab2618829d68f8623bb897302f24dbdba2279dbe45adb3d14`.
```solidity
event AddressAnnouncement(address node, string baseMultiaddr);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct AddressAnnouncement {
        #[allow(missing_docs)]
        pub node: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub baseMultiaddr: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for AddressAnnouncement {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::String,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "AddressAnnouncement(address,string)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                196u8, 223u8, 91u8, 161u8, 104u8, 20u8, 131u8, 138u8, 178u8, 97u8, 136u8,
                41u8, 214u8, 143u8, 134u8, 35u8, 187u8, 137u8, 115u8, 2u8, 242u8, 77u8,
                189u8, 186u8, 34u8, 121u8, 219u8, 228u8, 90u8, 219u8, 61u8, 20u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    node: data.0,
                    baseMultiaddr: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.node,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.baseMultiaddr,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for AddressAnnouncement {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&AddressAnnouncement> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &AddressAnnouncement) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `KeyBinding(bytes32,bytes32,bytes32,address)` and selector `0xbf49ccd41a4118c7e1e72143bad844e5f6ed12bf60caa642d88d19ca10244c36`.
```solidity
event KeyBinding(bytes32 ed25519_sig_0, bytes32 ed25519_sig_1, bytes32 ed25519_pub_key, address chain_key);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct KeyBinding {
        #[allow(missing_docs)]
        pub ed25519_sig_0: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub ed25519_sig_1: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub ed25519_pub_key: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub chain_key: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for KeyBinding {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "KeyBinding(bytes32,bytes32,bytes32,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                191u8, 73u8, 204u8, 212u8, 26u8, 65u8, 24u8, 199u8, 225u8, 231u8, 33u8,
                67u8, 186u8, 216u8, 68u8, 229u8, 246u8, 237u8, 18u8, 191u8, 96u8, 202u8,
                166u8, 66u8, 216u8, 141u8, 25u8, 202u8, 16u8, 36u8, 76u8, 54u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    ed25519_sig_0: data.0,
                    ed25519_sig_1: data.1,
                    ed25519_pub_key: data.2,
                    chain_key: data.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.ed25519_sig_0),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.ed25519_sig_1),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.ed25519_pub_key),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.chain_key,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for KeyBinding {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&KeyBinding> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &KeyBinding) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `RevokeAnnouncement(address)` and selector `0xa4de30a528becadf82649d1395c0e30dd18ae35b5a96ce71e9295bb14bc9f3bc`.
```solidity
event RevokeAnnouncement(address node);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RevokeAnnouncement {
        #[allow(missing_docs)]
        pub node: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RevokeAnnouncement {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "RevokeAnnouncement(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                164u8, 222u8, 48u8, 165u8, 40u8, 190u8, 202u8, 223u8, 130u8, 100u8,
                157u8, 19u8, 149u8, 192u8, 227u8, 13u8, 209u8, 138u8, 227u8, 91u8, 90u8,
                150u8, 206u8, 113u8, 233u8, 41u8, 91u8, 177u8, 75u8, 201u8, 243u8, 188u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { node: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.node,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RevokeAnnouncement {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RevokeAnnouncement> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RevokeAnnouncement) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Constructor`.
```solidity
constructor(address safeRegistry);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct constructorCall {
        #[allow(missing_docs)]
        pub safeRegistry: alloy::sol_types::private::Address,
    }
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<constructorCall> for UnderlyingRustTuple<'_> {
                fn from(value: constructorCall) -> Self {
                    (value.safeRegistry,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for constructorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { safeRegistry: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolConstructor for constructorCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.safeRegistry,
                    ),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `announce(string)` and selector `0xea0a5237`.
```solidity
function announce(string memory baseMultiaddr) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct announceCall {
        #[allow(missing_docs)]
        pub baseMultiaddr: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`announce(string)`](announceCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct announceReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<announceCall> for UnderlyingRustTuple<'_> {
                fn from(value: announceCall) -> Self {
                    (value.baseMultiaddr,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for announceCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { baseMultiaddr: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<announceReturn> for UnderlyingRustTuple<'_> {
                fn from(value: announceReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for announceReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl announceReturn {
            fn _tokenize(
                &self,
            ) -> <announceCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for announceCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::String,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = announceReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "announce(string)";
            const SELECTOR: [u8; 4] = [234u8, 10u8, 82u8, 55u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.baseMultiaddr,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                announceReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `announceSafe(address,string)` and selector `0xfad0e5a2`.
```solidity
function announceSafe(address selfAddress, string memory baseMultiaddr) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct announceSafeCall {
        #[allow(missing_docs)]
        pub selfAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub baseMultiaddr: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`announceSafe(address,string)`](announceSafeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct announceSafeReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::String,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::String,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<announceSafeCall> for UnderlyingRustTuple<'_> {
                fn from(value: announceSafeCall) -> Self {
                    (value.selfAddress, value.baseMultiaddr)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for announceSafeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        selfAddress: tuple.0,
                        baseMultiaddr: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<announceSafeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: announceSafeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for announceSafeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl announceSafeReturn {
            fn _tokenize(
                &self,
            ) -> <announceSafeCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for announceSafeCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::String,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = announceSafeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "announceSafe(address,string)";
            const SELECTOR: [u8; 4] = [250u8, 208u8, 229u8, 162u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.selfAddress,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.baseMultiaddr,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                announceSafeReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `bindKeys(bytes32,bytes32,bytes32)` and selector `0xdbb98d91`.
```solidity
function bindKeys(bytes32 ed25519_sig_0, bytes32 ed25519_sig_1, bytes32 ed25519_pub_key) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bindKeysCall {
        #[allow(missing_docs)]
        pub ed25519_sig_0: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub ed25519_sig_1: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub ed25519_pub_key: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`bindKeys(bytes32,bytes32,bytes32)`](bindKeysCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bindKeysReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bindKeysCall> for UnderlyingRustTuple<'_> {
                fn from(value: bindKeysCall) -> Self {
                    (value.ed25519_sig_0, value.ed25519_sig_1, value.ed25519_pub_key)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bindKeysCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        ed25519_sig_0: tuple.0,
                        ed25519_sig_1: tuple.1,
                        ed25519_pub_key: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bindKeysReturn> for UnderlyingRustTuple<'_> {
                fn from(value: bindKeysReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bindKeysReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl bindKeysReturn {
            fn _tokenize(
                &self,
            ) -> <bindKeysCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for bindKeysCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bindKeysReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "bindKeys(bytes32,bytes32,bytes32)";
            const SELECTOR: [u8; 4] = [219u8, 185u8, 141u8, 145u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.ed25519_sig_0),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.ed25519_sig_1),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.ed25519_pub_key),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                bindKeysReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `bindKeysAnnounce(bytes32,bytes32,bytes32,string)` and selector `0xf884a9cb`.
```solidity
function bindKeysAnnounce(bytes32 ed25519_sig_0, bytes32 ed25519_sig_1, bytes32 ed25519_pub_key, string memory baseMultiaddr) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bindKeysAnnounceCall {
        #[allow(missing_docs)]
        pub ed25519_sig_0: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub ed25519_sig_1: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub ed25519_pub_key: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub baseMultiaddr: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`bindKeysAnnounce(bytes32,bytes32,bytes32,string)`](bindKeysAnnounceCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bindKeysAnnounceReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::String,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::String,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bindKeysAnnounceCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: bindKeysAnnounceCall) -> Self {
                    (
                        value.ed25519_sig_0,
                        value.ed25519_sig_1,
                        value.ed25519_pub_key,
                        value.baseMultiaddr,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for bindKeysAnnounceCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        ed25519_sig_0: tuple.0,
                        ed25519_sig_1: tuple.1,
                        ed25519_pub_key: tuple.2,
                        baseMultiaddr: tuple.3,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bindKeysAnnounceReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: bindKeysAnnounceReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for bindKeysAnnounceReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl bindKeysAnnounceReturn {
            fn _tokenize(
                &self,
            ) -> <bindKeysAnnounceCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for bindKeysAnnounceCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::String,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bindKeysAnnounceReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "bindKeysAnnounce(bytes32,bytes32,bytes32,string)";
            const SELECTOR: [u8; 4] = [248u8, 132u8, 169u8, 203u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.ed25519_sig_0),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.ed25519_sig_1),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.ed25519_pub_key),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.baseMultiaddr,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                bindKeysAnnounceReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `bindKeysAnnounceSafe(address,bytes32,bytes32,bytes32,string)` and selector `0xddb9dfc1`.
```solidity
function bindKeysAnnounceSafe(address selfAddress, bytes32 ed25519_sig_0, bytes32 ed25519_sig_1, bytes32 ed25519_pub_key, string memory baseMultiaddr) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bindKeysAnnounceSafeCall {
        #[allow(missing_docs)]
        pub selfAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub ed25519_sig_0: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub ed25519_sig_1: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub ed25519_pub_key: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub baseMultiaddr: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`bindKeysAnnounceSafe(address,bytes32,bytes32,bytes32,string)`](bindKeysAnnounceSafeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bindKeysAnnounceSafeReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::String,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::String,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bindKeysAnnounceSafeCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: bindKeysAnnounceSafeCall) -> Self {
                    (
                        value.selfAddress,
                        value.ed25519_sig_0,
                        value.ed25519_sig_1,
                        value.ed25519_pub_key,
                        value.baseMultiaddr,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for bindKeysAnnounceSafeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        selfAddress: tuple.0,
                        ed25519_sig_0: tuple.1,
                        ed25519_sig_1: tuple.2,
                        ed25519_pub_key: tuple.3,
                        baseMultiaddr: tuple.4,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bindKeysAnnounceSafeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: bindKeysAnnounceSafeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for bindKeysAnnounceSafeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl bindKeysAnnounceSafeReturn {
            fn _tokenize(
                &self,
            ) -> <bindKeysAnnounceSafeCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for bindKeysAnnounceSafeCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::String,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bindKeysAnnounceSafeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "bindKeysAnnounceSafe(address,bytes32,bytes32,bytes32,string)";
            const SELECTOR: [u8; 4] = [221u8, 185u8, 223u8, 193u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.selfAddress,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.ed25519_sig_0),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.ed25519_sig_1),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.ed25519_pub_key),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.baseMultiaddr,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                bindKeysAnnounceSafeReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `bindKeysSafe(address,bytes32,bytes32,bytes32)` and selector `0xcae2b434`.
```solidity
function bindKeysSafe(address selfAddress, bytes32 ed25519_sig_0, bytes32 ed25519_sig_1, bytes32 ed25519_pub_key) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bindKeysSafeCall {
        #[allow(missing_docs)]
        pub selfAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub ed25519_sig_0: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub ed25519_sig_1: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub ed25519_pub_key: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`bindKeysSafe(address,bytes32,bytes32,bytes32)`](bindKeysSafeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bindKeysSafeReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bindKeysSafeCall> for UnderlyingRustTuple<'_> {
                fn from(value: bindKeysSafeCall) -> Self {
                    (
                        value.selfAddress,
                        value.ed25519_sig_0,
                        value.ed25519_sig_1,
                        value.ed25519_pub_key,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bindKeysSafeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        selfAddress: tuple.0,
                        ed25519_sig_0: tuple.1,
                        ed25519_sig_1: tuple.2,
                        ed25519_pub_key: tuple.3,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bindKeysSafeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: bindKeysSafeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bindKeysSafeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl bindKeysSafeReturn {
            fn _tokenize(
                &self,
            ) -> <bindKeysSafeCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for bindKeysSafeCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bindKeysSafeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "bindKeysSafe(address,bytes32,bytes32,bytes32)";
            const SELECTOR: [u8; 4] = [202u8, 226u8, 180u8, 52u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.selfAddress,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.ed25519_sig_0),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.ed25519_sig_1),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.ed25519_pub_key),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                bindKeysSafeReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `multicall(bytes[])` and selector `0xac9650d8`.
```solidity
function multicall(bytes[] memory data) external returns (bytes[] memory results);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct multicallCall {
        #[allow(missing_docs)]
        pub data: alloy::sol_types::private::Vec<alloy::sol_types::private::Bytes>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`multicall(bytes[])`](multicallCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct multicallReturn {
        #[allow(missing_docs)]
        pub results: alloy::sol_types::private::Vec<alloy::sol_types::private::Bytes>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bytes>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<alloy::sol_types::private::Bytes>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<multicallCall> for UnderlyingRustTuple<'_> {
                fn from(value: multicallCall) -> Self {
                    (value.data,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for multicallCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { data: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bytes>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<alloy::sol_types::private::Bytes>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<multicallReturn> for UnderlyingRustTuple<'_> {
                fn from(value: multicallReturn) -> Self {
                    (value.results,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for multicallReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { results: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for multicallCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bytes>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Vec<
                alloy::sol_types::private::Bytes,
            >;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bytes>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "multicall(bytes[])";
            const SELECTOR: [u8; 4] = [172u8, 150u8, 80u8, 216u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Bytes,
                    > as alloy_sol_types::SolType>::tokenize(&self.data),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Bytes,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: multicallReturn = r.into();
                        r.results
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: multicallReturn = r.into();
                        r.results
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `revoke()` and selector `0xb6549f75`.
```solidity
function revoke() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct revokeCall;
    ///Container type for the return parameters of the [`revoke()`](revokeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct revokeReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<revokeCall> for UnderlyingRustTuple<'_> {
                fn from(value: revokeCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for revokeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<revokeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: revokeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for revokeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl revokeReturn {
            fn _tokenize(
                &self,
            ) -> <revokeCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for revokeCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = revokeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "revoke()";
            const SELECTOR: [u8; 4] = [182u8, 84u8, 159u8, 117u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                revokeReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `revokeSafe(address)` and selector `0x308c712e`.
```solidity
function revokeSafe(address selfAddress) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct revokeSafeCall {
        #[allow(missing_docs)]
        pub selfAddress: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`revokeSafe(address)`](revokeSafeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct revokeSafeReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<revokeSafeCall> for UnderlyingRustTuple<'_> {
                fn from(value: revokeSafeCall) -> Self {
                    (value.selfAddress,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for revokeSafeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { selfAddress: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<revokeSafeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: revokeSafeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for revokeSafeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl revokeSafeReturn {
            fn _tokenize(
                &self,
            ) -> <revokeSafeCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for revokeSafeCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = revokeSafeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "revokeSafe(address)";
            const SELECTOR: [u8; 4] = [48u8, 140u8, 113u8, 46u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.selfAddress,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                revokeSafeReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`HoprAnnouncements`](self) function calls.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive()]
    pub enum HoprAnnouncementsCalls {
        #[allow(missing_docs)]
        announce(announceCall),
        #[allow(missing_docs)]
        announceSafe(announceSafeCall),
        #[allow(missing_docs)]
        bindKeys(bindKeysCall),
        #[allow(missing_docs)]
        bindKeysAnnounce(bindKeysAnnounceCall),
        #[allow(missing_docs)]
        bindKeysAnnounceSafe(bindKeysAnnounceSafeCall),
        #[allow(missing_docs)]
        bindKeysSafe(bindKeysSafeCall),
        #[allow(missing_docs)]
        multicall(multicallCall),
        #[allow(missing_docs)]
        revoke(revokeCall),
        #[allow(missing_docs)]
        revokeSafe(revokeSafeCall),
    }
    #[automatically_derived]
    impl HoprAnnouncementsCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [48u8, 140u8, 113u8, 46u8],
            [172u8, 150u8, 80u8, 216u8],
            [182u8, 84u8, 159u8, 117u8],
            [202u8, 226u8, 180u8, 52u8],
            [219u8, 185u8, 141u8, 145u8],
            [221u8, 185u8, 223u8, 193u8],
            [234u8, 10u8, 82u8, 55u8],
            [248u8, 132u8, 169u8, 203u8],
            [250u8, 208u8, 229u8, 162u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for HoprAnnouncementsCalls {
        const NAME: &'static str = "HoprAnnouncementsCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 9usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::announce(_) => <announceCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::announceSafe(_) => {
                    <announceSafeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::bindKeys(_) => <bindKeysCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::bindKeysAnnounce(_) => {
                    <bindKeysAnnounceCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::bindKeysAnnounceSafe(_) => {
                    <bindKeysAnnounceSafeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::bindKeysSafe(_) => {
                    <bindKeysSafeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::multicall(_) => {
                    <multicallCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::revoke(_) => <revokeCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::revokeSafe(_) => {
                    <revokeSafeCall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<HoprAnnouncementsCalls>] = &[
                {
                    fn revokeSafe(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsCalls> {
                        <revokeSafeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprAnnouncementsCalls::revokeSafe)
                    }
                    revokeSafe
                },
                {
                    fn multicall(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsCalls> {
                        <multicallCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(HoprAnnouncementsCalls::multicall)
                    }
                    multicall
                },
                {
                    fn revoke(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsCalls> {
                        <revokeCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(HoprAnnouncementsCalls::revoke)
                    }
                    revoke
                },
                {
                    fn bindKeysSafe(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsCalls> {
                        <bindKeysSafeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprAnnouncementsCalls::bindKeysSafe)
                    }
                    bindKeysSafe
                },
                {
                    fn bindKeys(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsCalls> {
                        <bindKeysCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(HoprAnnouncementsCalls::bindKeys)
                    }
                    bindKeys
                },
                {
                    fn bindKeysAnnounceSafe(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsCalls> {
                        <bindKeysAnnounceSafeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprAnnouncementsCalls::bindKeysAnnounceSafe)
                    }
                    bindKeysAnnounceSafe
                },
                {
                    fn announce(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsCalls> {
                        <announceCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(HoprAnnouncementsCalls::announce)
                    }
                    announce
                },
                {
                    fn bindKeysAnnounce(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsCalls> {
                        <bindKeysAnnounceCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprAnnouncementsCalls::bindKeysAnnounce)
                    }
                    bindKeysAnnounce
                },
                {
                    fn announceSafe(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsCalls> {
                        <announceSafeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprAnnouncementsCalls::announceSafe)
                    }
                    announceSafe
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data)
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw_validate(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_VALIDATE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<HoprAnnouncementsCalls>] = &[
                {
                    fn revokeSafe(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsCalls> {
                        <revokeSafeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprAnnouncementsCalls::revokeSafe)
                    }
                    revokeSafe
                },
                {
                    fn multicall(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsCalls> {
                        <multicallCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprAnnouncementsCalls::multicall)
                    }
                    multicall
                },
                {
                    fn revoke(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsCalls> {
                        <revokeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprAnnouncementsCalls::revoke)
                    }
                    revoke
                },
                {
                    fn bindKeysSafe(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsCalls> {
                        <bindKeysSafeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprAnnouncementsCalls::bindKeysSafe)
                    }
                    bindKeysSafe
                },
                {
                    fn bindKeys(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsCalls> {
                        <bindKeysCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprAnnouncementsCalls::bindKeys)
                    }
                    bindKeys
                },
                {
                    fn bindKeysAnnounceSafe(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsCalls> {
                        <bindKeysAnnounceSafeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprAnnouncementsCalls::bindKeysAnnounceSafe)
                    }
                    bindKeysAnnounceSafe
                },
                {
                    fn announce(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsCalls> {
                        <announceCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprAnnouncementsCalls::announce)
                    }
                    announce
                },
                {
                    fn bindKeysAnnounce(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsCalls> {
                        <bindKeysAnnounceCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprAnnouncementsCalls::bindKeysAnnounce)
                    }
                    bindKeysAnnounce
                },
                {
                    fn announceSafe(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsCalls> {
                        <announceSafeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprAnnouncementsCalls::announceSafe)
                    }
                    announceSafe
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_VALIDATE_SHIMS[idx](data)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::announce(inner) => {
                    <announceCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::announceSafe(inner) => {
                    <announceSafeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::bindKeys(inner) => {
                    <bindKeysCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::bindKeysAnnounce(inner) => {
                    <bindKeysAnnounceCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::bindKeysAnnounceSafe(inner) => {
                    <bindKeysAnnounceSafeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::bindKeysSafe(inner) => {
                    <bindKeysSafeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::multicall(inner) => {
                    <multicallCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::revoke(inner) => {
                    <revokeCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::revokeSafe(inner) => {
                    <revokeSafeCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::announce(inner) => {
                    <announceCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::announceSafe(inner) => {
                    <announceSafeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::bindKeys(inner) => {
                    <bindKeysCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::bindKeysAnnounce(inner) => {
                    <bindKeysAnnounceCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::bindKeysAnnounceSafe(inner) => {
                    <bindKeysAnnounceSafeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::bindKeysSafe(inner) => {
                    <bindKeysSafeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::multicall(inner) => {
                    <multicallCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::revoke(inner) => {
                    <revokeCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::revokeSafe(inner) => {
                    <revokeSafeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`HoprAnnouncements`](self) custom errors.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub enum HoprAnnouncementsErrors {
        #[allow(missing_docs)]
        AlreadyInitialized(AlreadyInitialized),
        #[allow(missing_docs)]
        ContractNotResponsible(ContractNotResponsible),
        #[allow(missing_docs)]
        InvalidSafeAddress(InvalidSafeAddress),
        #[allow(missing_docs)]
        MultiSigUninitialized(MultiSigUninitialized),
    }
    #[automatically_derived]
    impl HoprAnnouncementsErrors {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [13u8, 193u8, 73u8, 240u8],
            [69u8, 74u8, 32u8, 200u8],
            [142u8, 157u8, 124u8, 94u8],
            [172u8, 213u8, 168u8, 35u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for HoprAnnouncementsErrors {
        const NAME: &'static str = "HoprAnnouncementsErrors";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 4usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::AlreadyInitialized(_) => {
                    <AlreadyInitialized as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ContractNotResponsible(_) => {
                    <ContractNotResponsible as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidSafeAddress(_) => {
                    <InvalidSafeAddress as alloy_sol_types::SolError>::SELECTOR
                }
                Self::MultiSigUninitialized(_) => {
                    <MultiSigUninitialized as alloy_sol_types::SolError>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<HoprAnnouncementsErrors>] = &[
                {
                    fn AlreadyInitialized(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsErrors> {
                        <AlreadyInitialized as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(HoprAnnouncementsErrors::AlreadyInitialized)
                    }
                    AlreadyInitialized
                },
                {
                    fn MultiSigUninitialized(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsErrors> {
                        <MultiSigUninitialized as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(HoprAnnouncementsErrors::MultiSigUninitialized)
                    }
                    MultiSigUninitialized
                },
                {
                    fn InvalidSafeAddress(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsErrors> {
                        <InvalidSafeAddress as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(HoprAnnouncementsErrors::InvalidSafeAddress)
                    }
                    InvalidSafeAddress
                },
                {
                    fn ContractNotResponsible(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsErrors> {
                        <ContractNotResponsible as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(HoprAnnouncementsErrors::ContractNotResponsible)
                    }
                    ContractNotResponsible
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data)
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw_validate(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_VALIDATE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<HoprAnnouncementsErrors>] = &[
                {
                    fn AlreadyInitialized(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsErrors> {
                        <AlreadyInitialized as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprAnnouncementsErrors::AlreadyInitialized)
                    }
                    AlreadyInitialized
                },
                {
                    fn MultiSigUninitialized(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsErrors> {
                        <MultiSigUninitialized as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprAnnouncementsErrors::MultiSigUninitialized)
                    }
                    MultiSigUninitialized
                },
                {
                    fn InvalidSafeAddress(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsErrors> {
                        <InvalidSafeAddress as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprAnnouncementsErrors::InvalidSafeAddress)
                    }
                    InvalidSafeAddress
                },
                {
                    fn ContractNotResponsible(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprAnnouncementsErrors> {
                        <ContractNotResponsible as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprAnnouncementsErrors::ContractNotResponsible)
                    }
                    ContractNotResponsible
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_VALIDATE_SHIMS[idx](data)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::AlreadyInitialized(inner) => {
                    <AlreadyInitialized as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ContractNotResponsible(inner) => {
                    <ContractNotResponsible as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidSafeAddress(inner) => {
                    <InvalidSafeAddress as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::MultiSigUninitialized(inner) => {
                    <MultiSigUninitialized as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::AlreadyInitialized(inner) => {
                    <AlreadyInitialized as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ContractNotResponsible(inner) => {
                    <ContractNotResponsible as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidSafeAddress(inner) => {
                    <InvalidSafeAddress as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::MultiSigUninitialized(inner) => {
                    <MultiSigUninitialized as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`HoprAnnouncements`](self) events.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub enum HoprAnnouncementsEvents {
        #[allow(missing_docs)]
        AddressAnnouncement(AddressAnnouncement),
        #[allow(missing_docs)]
        KeyBinding(KeyBinding),
        #[allow(missing_docs)]
        RevokeAnnouncement(RevokeAnnouncement),
    }
    #[automatically_derived]
    impl HoprAnnouncementsEvents {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                164u8, 222u8, 48u8, 165u8, 40u8, 190u8, 202u8, 223u8, 130u8, 100u8,
                157u8, 19u8, 149u8, 192u8, 227u8, 13u8, 209u8, 138u8, 227u8, 91u8, 90u8,
                150u8, 206u8, 113u8, 233u8, 41u8, 91u8, 177u8, 75u8, 201u8, 243u8, 188u8,
            ],
            [
                191u8, 73u8, 204u8, 212u8, 26u8, 65u8, 24u8, 199u8, 225u8, 231u8, 33u8,
                67u8, 186u8, 216u8, 68u8, 229u8, 246u8, 237u8, 18u8, 191u8, 96u8, 202u8,
                166u8, 66u8, 216u8, 141u8, 25u8, 202u8, 16u8, 36u8, 76u8, 54u8,
            ],
            [
                196u8, 223u8, 91u8, 161u8, 104u8, 20u8, 131u8, 138u8, 178u8, 97u8, 136u8,
                41u8, 214u8, 143u8, 134u8, 35u8, 187u8, 137u8, 115u8, 2u8, 242u8, 77u8,
                189u8, 186u8, 34u8, 121u8, 219u8, 228u8, 90u8, 219u8, 61u8, 20u8,
            ],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for HoprAnnouncementsEvents {
        const NAME: &'static str = "HoprAnnouncementsEvents";
        const COUNT: usize = 3usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(
                    <AddressAnnouncement as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <AddressAnnouncement as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::AddressAnnouncement)
                }
                Some(<KeyBinding as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <KeyBinding as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::KeyBinding)
                }
                Some(
                    <RevokeAnnouncement as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <RevokeAnnouncement as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::RevokeAnnouncement)
                }
                _ => {
                    alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                        name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                        log: alloy_sol_types::private::Box::new(
                            alloy_sol_types::private::LogData::new_unchecked(
                                topics.to_vec(),
                                data.to_vec().into(),
                            ),
                        ),
                    })
                }
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData for HoprAnnouncementsEvents {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::AddressAnnouncement(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::KeyBinding(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RevokeAnnouncement(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::AddressAnnouncement(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::KeyBinding(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RevokeAnnouncement(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`HoprAnnouncements`](self) contract instance.

See the [wrapper's documentation](`HoprAnnouncementsInstance`) for more details.*/
    #[inline]
    pub const fn new<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> HoprAnnouncementsInstance<P, N> {
        HoprAnnouncementsInstance::<P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        safeRegistry: alloy::sol_types::private::Address,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<HoprAnnouncementsInstance<P, N>>,
    > {
        HoprAnnouncementsInstance::<P, N>::deploy(provider, safeRegistry)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        safeRegistry: alloy::sol_types::private::Address,
    ) -> alloy_contract::RawCallBuilder<P, N> {
        HoprAnnouncementsInstance::<P, N>::deploy_builder(provider, safeRegistry)
    }
    /**A [`HoprAnnouncements`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`HoprAnnouncements`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct HoprAnnouncementsInstance<P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network: ::core::marker::PhantomData<N>,
    }
    #[automatically_derived]
    impl<P, N> ::core::fmt::Debug for HoprAnnouncementsInstance<P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("HoprAnnouncementsInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > HoprAnnouncementsInstance<P, N> {
        /**Creates a new wrapper around an on-chain [`HoprAnnouncements`](self) contract instance.

See the [wrapper's documentation](`HoprAnnouncementsInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
            safeRegistry: alloy::sol_types::private::Address,
        ) -> alloy_contract::Result<HoprAnnouncementsInstance<P, N>> {
            let call_builder = Self::deploy_builder(provider, safeRegistry);
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(
            provider: P,
            safeRegistry: alloy::sol_types::private::Address,
        ) -> alloy_contract::RawCallBuilder<P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                [
                    &BYTECODE[..],
                    &alloy_sol_types::SolConstructor::abi_encode(
                        &constructorCall { safeRegistry },
                    )[..],
                ]
                    .concat()
                    .into(),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<P: ::core::clone::Clone, N> HoprAnnouncementsInstance<&P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> HoprAnnouncementsInstance<P, N> {
            HoprAnnouncementsInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > HoprAnnouncementsInstance<P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<&P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`announce`] function.
        pub fn announce(
            &self,
            baseMultiaddr: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<&P, announceCall, N> {
            self.call_builder(&announceCall { baseMultiaddr })
        }
        ///Creates a new call builder for the [`announceSafe`] function.
        pub fn announceSafe(
            &self,
            selfAddress: alloy::sol_types::private::Address,
            baseMultiaddr: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<&P, announceSafeCall, N> {
            self.call_builder(
                &announceSafeCall {
                    selfAddress,
                    baseMultiaddr,
                },
            )
        }
        ///Creates a new call builder for the [`bindKeys`] function.
        pub fn bindKeys(
            &self,
            ed25519_sig_0: alloy::sol_types::private::FixedBytes<32>,
            ed25519_sig_1: alloy::sol_types::private::FixedBytes<32>,
            ed25519_pub_key: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, bindKeysCall, N> {
            self.call_builder(
                &bindKeysCall {
                    ed25519_sig_0,
                    ed25519_sig_1,
                    ed25519_pub_key,
                },
            )
        }
        ///Creates a new call builder for the [`bindKeysAnnounce`] function.
        pub fn bindKeysAnnounce(
            &self,
            ed25519_sig_0: alloy::sol_types::private::FixedBytes<32>,
            ed25519_sig_1: alloy::sol_types::private::FixedBytes<32>,
            ed25519_pub_key: alloy::sol_types::private::FixedBytes<32>,
            baseMultiaddr: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<&P, bindKeysAnnounceCall, N> {
            self.call_builder(
                &bindKeysAnnounceCall {
                    ed25519_sig_0,
                    ed25519_sig_1,
                    ed25519_pub_key,
                    baseMultiaddr,
                },
            )
        }
        ///Creates a new call builder for the [`bindKeysAnnounceSafe`] function.
        pub fn bindKeysAnnounceSafe(
            &self,
            selfAddress: alloy::sol_types::private::Address,
            ed25519_sig_0: alloy::sol_types::private::FixedBytes<32>,
            ed25519_sig_1: alloy::sol_types::private::FixedBytes<32>,
            ed25519_pub_key: alloy::sol_types::private::FixedBytes<32>,
            baseMultiaddr: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<&P, bindKeysAnnounceSafeCall, N> {
            self.call_builder(
                &bindKeysAnnounceSafeCall {
                    selfAddress,
                    ed25519_sig_0,
                    ed25519_sig_1,
                    ed25519_pub_key,
                    baseMultiaddr,
                },
            )
        }
        ///Creates a new call builder for the [`bindKeysSafe`] function.
        pub fn bindKeysSafe(
            &self,
            selfAddress: alloy::sol_types::private::Address,
            ed25519_sig_0: alloy::sol_types::private::FixedBytes<32>,
            ed25519_sig_1: alloy::sol_types::private::FixedBytes<32>,
            ed25519_pub_key: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, bindKeysSafeCall, N> {
            self.call_builder(
                &bindKeysSafeCall {
                    selfAddress,
                    ed25519_sig_0,
                    ed25519_sig_1,
                    ed25519_pub_key,
                },
            )
        }
        ///Creates a new call builder for the [`multicall`] function.
        pub fn multicall(
            &self,
            data: alloy::sol_types::private::Vec<alloy::sol_types::private::Bytes>,
        ) -> alloy_contract::SolCallBuilder<&P, multicallCall, N> {
            self.call_builder(&multicallCall { data })
        }
        ///Creates a new call builder for the [`revoke`] function.
        pub fn revoke(&self) -> alloy_contract::SolCallBuilder<&P, revokeCall, N> {
            self.call_builder(&revokeCall)
        }
        ///Creates a new call builder for the [`revokeSafe`] function.
        pub fn revokeSafe(
            &self,
            selfAddress: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, revokeSafeCall, N> {
            self.call_builder(&revokeSafeCall { selfAddress })
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > HoprAnnouncementsInstance<P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<&P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        ///Creates a new event filter for the [`AddressAnnouncement`] event.
        pub fn AddressAnnouncement_filter(
            &self,
        ) -> alloy_contract::Event<&P, AddressAnnouncement, N> {
            self.event_filter::<AddressAnnouncement>()
        }
        ///Creates a new event filter for the [`KeyBinding`] event.
        pub fn KeyBinding_filter(&self) -> alloy_contract::Event<&P, KeyBinding, N> {
            self.event_filter::<KeyBinding>()
        }
        ///Creates a new event filter for the [`RevokeAnnouncement`] event.
        pub fn RevokeAnnouncement_filter(
            &self,
        ) -> alloy_contract::Event<&P, RevokeAnnouncement, N> {
            self.event_filter::<RevokeAnnouncement>()
        }
    }
}
