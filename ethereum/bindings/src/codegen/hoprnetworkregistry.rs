/**

Generated by the following Solidity interface...
```solidity
interface HoprNetworkRegistry {
    error ArrayLengthNotMatch();
    error CannotOperateForNode(address nodeAddress);
    error GloballyDisabledRegistry();
    error GloballyEnabledRegistry();
    error NodeAlreadyRegisterd(address nodeAddress);
    error NodeNotYetRegisterd(address nodeAddress);
    error NodeRegisterdToOtherAccount(address nodeAddress);
    error NotEnoughAllowanceToRegisterNode();

    event Deregistered(address indexed stakingAccount, address indexed nodeAddress);
    event DeregisteredByManager(address indexed stakingAccount, address indexed nodeAddress);
    event EligibilityUpdated(address indexed stakingAccount, bool indexed eligibility);
    event NetworkRegistryStatusUpdated(bool indexed isEnabled);
    event Registered(address indexed stakingAccount, address indexed nodeAddress);
    event RegisteredByManager(address indexed stakingAccount, address indexed nodeAddress);
    event RequirementUpdated(address indexed requirementImplementation);
    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);
    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);

    constructor(address _requirementImplementation, address _newOwner, address _manager);

    function DEFAULT_ADMIN_ROLE() external view returns (bytes32);
    function MANAGER_ROLE() external view returns (bytes32);
    function countRegisterdNodesPerAccount(address) external view returns (uint256);
    function disableRegistry() external;
    function enableRegistry() external;
    function enabled() external view returns (bool);
    function getRoleAdmin(bytes32 role) external view returns (bytes32);
    function getRoleMember(bytes32 role, uint256 index) external view returns (address);
    function getRoleMemberCount(bytes32 role) external view returns (uint256);
    function grantRole(bytes32 role, address account) external;
    function hasRole(bytes32 role, address account) external view returns (bool);
    function isAccountEligible(address stakingAccount) external view returns (bool);
    function isNodeRegisteredAndEligible(address nodeAddress) external view returns (bool);
    function isNodeRegisteredByAccount(address nodeAddress, address account) external view returns (bool);
    function managerDeregister(address[] memory nodeAddresses) external;
    function managerForceSync(address[] memory stakingAccounts, bool[] memory eligibilities) external;
    function managerRegister(address[] memory stakingAccounts, address[] memory nodeAddresses) external;
    function managerSync(address[] memory stakingAccounts) external;
    function maxAdditionalRegistrations(address stakingAccount) external view returns (uint256);
    function nodeRegisterdToAccount(address) external view returns (address);
    function renounceRole(bytes32 role, address account) external;
    function requirementImplementation() external view returns (address);
    function revokeRole(bytes32 role, address account) external;
    function selfDeregister(address[] memory nodeAddresses) external;
    function selfRegister(address[] memory nodeAddresses) external;
    function selfSync() external;
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
    function updateRequirementImplementation(address _requirementImplementation) external;
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [
      {
        "name": "_requirementImplementation",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "_newOwner",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "_manager",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "DEFAULT_ADMIN_ROLE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "MANAGER_ROLE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "countRegisterdNodesPerAccount",
    "inputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "disableRegistry",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "enableRegistry",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "enabled",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getRoleAdmin",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getRoleMember",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "index",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getRoleMemberCount",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "grantRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "hasRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "isAccountEligible",
    "inputs": [
      {
        "name": "stakingAccount",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "isNodeRegisteredAndEligible",
    "inputs": [
      {
        "name": "nodeAddress",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "isNodeRegisteredByAccount",
    "inputs": [
      {
        "name": "nodeAddress",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "managerDeregister",
    "inputs": [
      {
        "name": "nodeAddresses",
        "type": "address[]",
        "internalType": "address[]"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "managerForceSync",
    "inputs": [
      {
        "name": "stakingAccounts",
        "type": "address[]",
        "internalType": "address[]"
      },
      {
        "name": "eligibilities",
        "type": "bool[]",
        "internalType": "bool[]"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "managerRegister",
    "inputs": [
      {
        "name": "stakingAccounts",
        "type": "address[]",
        "internalType": "address[]"
      },
      {
        "name": "nodeAddresses",
        "type": "address[]",
        "internalType": "address[]"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "managerSync",
    "inputs": [
      {
        "name": "stakingAccounts",
        "type": "address[]",
        "internalType": "address[]"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "maxAdditionalRegistrations",
    "inputs": [
      {
        "name": "stakingAccount",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "nodeRegisterdToAccount",
    "inputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "renounceRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "requirementImplementation",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "contract IHoprNetworkRegistryRequirement"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "revokeRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "selfDeregister",
    "inputs": [
      {
        "name": "nodeAddresses",
        "type": "address[]",
        "internalType": "address[]"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "selfRegister",
    "inputs": [
      {
        "name": "nodeAddresses",
        "type": "address[]",
        "internalType": "address[]"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "selfSync",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "supportsInterface",
    "inputs": [
      {
        "name": "interfaceId",
        "type": "bytes4",
        "internalType": "bytes4"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "updateRequirementImplementation",
    "inputs": [
      {
        "name": "_requirementImplementation",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "event",
    "name": "Deregistered",
    "inputs": [
      {
        "name": "stakingAccount",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "nodeAddress",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "DeregisteredByManager",
    "inputs": [
      {
        "name": "stakingAccount",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "nodeAddress",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "EligibilityUpdated",
    "inputs": [
      {
        "name": "stakingAccount",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "eligibility",
        "type": "bool",
        "indexed": true,
        "internalType": "bool"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "NetworkRegistryStatusUpdated",
    "inputs": [
      {
        "name": "isEnabled",
        "type": "bool",
        "indexed": true,
        "internalType": "bool"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Registered",
    "inputs": [
      {
        "name": "stakingAccount",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "nodeAddress",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RegisteredByManager",
    "inputs": [
      {
        "name": "stakingAccount",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "nodeAddress",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RequirementUpdated",
    "inputs": [
      {
        "name": "requirementImplementation",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RoleAdminChanged",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "previousAdminRole",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "newAdminRole",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RoleGranted",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "sender",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RoleRevoked",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "sender",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "error",
    "name": "ArrayLengthNotMatch",
    "inputs": []
  },
  {
    "type": "error",
    "name": "CannotOperateForNode",
    "inputs": [
      {
        "name": "nodeAddress",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "GloballyDisabledRegistry",
    "inputs": []
  },
  {
    "type": "error",
    "name": "GloballyEnabledRegistry",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NodeAlreadyRegisterd",
    "inputs": [
      {
        "name": "nodeAddress",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "NodeNotYetRegisterd",
    "inputs": [
      {
        "name": "nodeAddress",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "NodeRegisterdToOtherAccount",
    "inputs": [
      {
        "name": "nodeAddress",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "NotEnoughAllowanceToRegisterNode",
    "inputs": []
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod HoprNetworkRegistry {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x60806040523480156200001157600080fd5b5060405162001e3f38038062001e3f83398101604081905262000034916200026a565b6200004160008362000100565b6200005c60008051602062001e1f8339815191528362000100565b6200007760008051602062001e1f8339815191528262000100565b600280546001600160a01b0319166001600160a01b0385169081179091556005805460ff191660011790556040517f8ac4b2eb7749f75c5b99b898e547fd615dd7a424e68356ea196b7dae742d6c3290600090a26040516001907f8bc85f25e3e933978f099408b3bb3eb7630b76f7455f2e205bcbc0a780e17e7290600090a2505050620002b4565b6200010c828262000110565b5050565b6200011c82826200013b565b6000828152600160205260409020620001369082620001db565b505050565b6000828152602081815260408083206001600160a01b038516845290915290205460ff166200010c576000828152602081815260408083206001600160a01b03851684529091529020805460ff19166001179055620001973390565b6001600160a01b0316816001600160a01b0316837f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d60405160405180910390a45050565b6000620001f2836001600160a01b038416620001fb565b90505b92915050565b60008181526001830160205260408120546200024457508154600181810184556000848152602080822090930184905584548482528286019093526040902091909155620001f5565b506000620001f5565b80516001600160a01b03811681146200026557600080fd5b919050565b6000806000606084860312156200028057600080fd5b6200028b846200024d565b92506200029b602085016200024d565b9150620002ab604085016200024d565b90509250925092565b611b5b80620002c46000396000f3fe608060405234801561001057600080fd5b50600436106101c45760003560e01c80639010d07c116100f9578063ca15c87311610097578063cfb3735f11610071578063cfb3735f146103da578063d547741f146103e2578063e3d2a071146103f5578063ec87621c1461040857600080fd5b8063ca15c873146103ac578063caf5f501146103bf578063cbebafe0146103d257600080fd5b8063a05e0f6d116100d3578063a05e0f6d14610355578063a217fddf14610368578063a5605da514610370578063c7ecab8f1461038357600080fd5b80639010d07c1461030f57806391d148541461033a5780639c7f643b1461034d57600080fd5b806336568abe116101665780634eb1805c116101405780634eb1805c146102c35780636ffbf988146102d657806376593a39146102e95780638d753b2d146102fc57600080fd5b806336568abe1461027d5780633fa584571461029057806341b64965146102b057600080fd5b806327b040a1116101a257806327b040a11461022f5780632a2deee2146102445780632c33cafb146102575780632f2ff15d1461026a57600080fd5b806301ffc9a7146101c9578063238dafe0146101f1578063248a9ca3146101fe575b600080fd5b6101dc6101d736600461162b565b61041d565b60405190151581526020015b60405180910390f35b6005546101dc9060ff1681565b61022161020c366004611655565b60009081526020819052604090206001015490565b6040519081526020016101e8565b61024261023d36600461168a565b610448565b005b61022161025236600461168a565b6104ab565b6102426102653660046116f1565b61055d565b610242610278366004611733565b6105c7565b61024261028b366004611733565b6105f1565b61022161029e36600461168a565b60036020526000908152604090205481565b6102426102be3660046116f1565b610674565b6101dc6102d136600461168a565b610797565b6101dc6102e436600461168a565b6107e8565b6102426102f73660046116f1565b6107f3565b61024261030a36600461175f565b610988565b61032261031d3660046117cb565b610b02565b6040516001600160a01b0390911681526020016101e8565b6101dc610348366004611733565b610b1a565b610242610b43565b6102426103633660046116f1565b610b71565b610221600081565b6101dc61037e3660046117ed565b610cc4565b61032261039136600461168a565b6004602052600090815260409020546001600160a01b031681565b6102216103ba366004611655565b610d13565b6102426103cd366004611846565b610d2a565b610242610e44565b610242610eb7565b6102426103f0366004611733565b610f2f565b600254610322906001600160a01b031681565b610221600080516020611ae683398151915281565b60006001600160e01b03198216635a05180f60e01b1480610442575061044282610f54565b92915050565b600080516020611ae683398151915261046081610f89565b600280546001600160a01b0319166001600160a01b0384169081179091556040517f8ac4b2eb7749f75c5b99b898e547fd615dd7a424e68356ea196b7dae742d6c3290600090a25050565b6002546040516359aa274160e11b81526001600160a01b038381166004830152600092839291169063b3544e8290602401602060405180830381865afa1580156104f9573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061051d9190611934565b6001600160a01b038416600090815260036020526040902054909150808211156105535761054b8183611963565b949350505050565b5060009392505050565b600080516020611ae683398151915261057581610f89565b60005b828110156105c1576105af84848381811061059557610595611976565b90506020020160208101906105aa919061168a565b610f96565b806105b98161198c565b915050610578565b50505050565b6000828152602081905260409020600101546105e281610f89565b6105ec8383610ff3565b505050565b6001600160a01b03811633146106665760405162461bcd60e51b815260206004820152602f60248201527f416363657373436f6e74726f6c3a2063616e206f6e6c792072656e6f756e636560448201526e103937b632b9903337b91039b2b63360891b60648201526084015b60405180910390fd5b6106708282611015565b5050565b600080516020611ae683398151915261068c81610f89565b60005b828110156105c15760008484838181106106ab576106ab611976565b90506020020160208101906106c0919061168a565b6001600160a01b03808216600090815260046020526040902054919250168061070757604051631638791560e31b81526001600160a01b038316600482015260240161065d565b6001600160a01b038116600090815260036020526040812080549161072b836119a5565b90915550506001600160a01b0380831660008181526004602052604080822080546001600160a01b03191690555191928416917f91760a1001f531ec2bee8602be55ad2b1159465edff5bbcd41d20703742a4d429190a35050808061078f9061198c565b91505061068f565b60006001600160a01b0382166107af57506000919050565b6001600160a01b0380831660009081526004602052604090205416806107d85750600092915050565b6107e181611037565b9392505050565b600061044282611037565b60055460ff166108165760405163c42638bb60e01b815260040160405180910390fd5b60005b8181101561094157600083838381811061083557610835611976565b905060200201602081019061084a919061168a565b6001600160a01b038082166000908152600460205260409020549192501661087233836110ed565b6001600160a01b0381166108f85733600090815260036020526040812080549161089b8361198c565b90915550506001600160a01b03821660008181526004602052604080822080546001600160a01b03191633908117909155905190917f0a31ee9d46a828884b81003c8498156ea6aa15b9b54bdd0ef0b533d9eba57e5591a361092c565b6001600160a01b038116331461092c57604051635b533ba160e01b81526001600160a01b038316600482015260240161065d565b505080806109399061198c565b915050610819565b5061094b33611037565b610968576040516303ee6f5760e21b815260040160405180910390fd5b6040516001903390600080516020611b0683398151915290600090a35050565b600080516020611ae68339815191526109a081610f89565b8382146109c05760405163ed882f7160e01b815260040160405180910390fd5b60005b84811015610afa5760008484838181106109df576109df611976565b90506020020160208101906109f4919061168a565b90506000878784818110610a0a57610a0a611976565b9050602002016020810190610a1f919061168a565b6001600160a01b038381166000908152600460205260409020549192501615610a6657604051635b533ba160e01b81526001600160a01b038316600482015260240161065d565b6001600160a01b0381166000908152600360205260408120805491610a8a8361198c565b90915550506001600160a01b0382811660008181526004602052604080822080546001600160a01b0319169486169485179055519192917f04e1eaa4da18f7e742a4edbbe9ede36cdf75f793bb03ab2158c0877f1caf2b939190a350508080610af29061198c565b9150506109c3565b505050505050565b60008281526001602052604081206107e1908361118f565b6000918252602082815260408084206001600160a01b0393909316845291905290205460ff1690565b60055460ff16610b665760405163c42638bb60e01b815260040160405180910390fd5b610b6f33610f96565b565b60055460ff16610b945760405163c42638bb60e01b815260040160405180910390fd5b60005b81811015610cba576000838383818110610bb357610bb3611976565b9050602002016020810190610bc8919061168a565b6001600160a01b0380821660009081526004602052604090205491925016610bf033836110ed565b336001600160a01b03821603610c7257336000908152600360205260408120805491610c1b836119a5565b90915550506001600160a01b03821660008181526004602052604080822080546001600160a01b03191690555133917f159a8ae948fcc6e7f8b5495c0d73e91598440af8a62817246c09edc2c28dba8a91a3610ca5565b6001600160a01b03811615610ca55760405163bf4fdd7360e01b81526001600160a01b038316600482015260240161065d565b50508080610cb29061198c565b915050610b97565b5061067033610f96565b60006001600160a01b0383161580610ce357506001600160a01b038216155b15610cf057506000610442565b506001600160a01b03918216600090815260046020526040902054821691161490565b60008181526001602052604081206104429061119b565b600080516020611ae6833981519152610d4281610f89565b81518314610d635760405163ed882f7160e01b815260040160405180910390fd5b60005b83811015610e3d57828181518110610d8057610d80611976565b602002602001015115610dde576001858583818110610da157610da1611976565b9050602002016020810190610db6919061168a565b6001600160a01b0316600080516020611b0683398151915260405160405180910390a3610e2b565b6000858583818110610df257610df2611976565b9050602002016020810190610e07919061168a565b6001600160a01b0316600080516020611b0683398151915260405160405180910390a35b80610e358161198c565b915050610d66565b5050505050565b600080516020611ae6833981519152610e5c81610f89565b60055460ff16610e7f5760405163c42638bb60e01b815260040160405180910390fd5b6005805460ff191690556040516000907f8bc85f25e3e933978f099408b3bb3eb7630b76f7455f2e205bcbc0a780e17e72908290a250565b600080516020611ae6833981519152610ecf81610f89565b60055460ff1615610ef35760405163ed1a0c7760e01b815260040160405180910390fd5b6005805460ff191660019081179091556040517f8bc85f25e3e933978f099408b3bb3eb7630b76f7455f2e205bcbc0a780e17e7290600090a250565b600082815260208190526040902060010154610f4a81610f89565b6105ec8383611015565b60006001600160e01b03198216637965db0b60e01b148061044257506301ffc9a760e01b6001600160e01b0319831614610442565b610f9381336111a5565b50565b610f9f81611037565b15610fcc576040516001906001600160a01b03831690600080516020611b0683398151915290600090a350565b6040516000906001600160a01b03831690600080516020611b06833981519152908390a350565b610ffd82826111fe565b60008281526001602052604090206105ec9082611282565b61101f8282611297565b60008281526001602052604090206105ec90826112fc565b6002546040516359aa274160e11b81526001600160a01b038381166004830152600092839291169063b3544e8290602401602060405180830381865afa158015611085573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110a99190611934565b9050806000036110bc5750600092915050565b6001600160a01b03831660009081526003602052604090205481106110e45750600192915050565b50600092915050565b600254604051633616b41160e21b81526001600160a01b0384811660048301528381166024830152600092169063d85ad04490604401602060405180830381865afa158015611140573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061116491906119bc565b9050806105ec57604051630741496760e01b81526001600160a01b038316600482015260240161065d565b60006107e18383611311565b6000610442825490565b6111af8282610b1a565b610670576111bc8161133b565b6111c783602061134d565b6040516020016111d89291906119fd565b60408051601f198184030181529082905262461bcd60e51b825261065d91600401611a72565b6112088282610b1a565b610670576000828152602081815260408083206001600160a01b03851684529091529020805460ff1916600117905561123e3390565b6001600160a01b0316816001600160a01b0316837f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d60405160405180910390a45050565b60006107e1836001600160a01b0384166114e9565b6112a18282610b1a565b15610670576000828152602081815260408083206001600160a01b0385168085529252808320805460ff1916905551339285917ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b9190a45050565b60006107e1836001600160a01b038416611538565b600082600001828154811061132857611328611976565b9060005260206000200154905092915050565b60606104426001600160a01b03831660145b6060600061135c836002611aa5565b611367906002611abc565b67ffffffffffffffff81111561137f5761137f611817565b6040519080825280601f01601f1916602001820160405280156113a9576020820181803683370190505b509050600360fc1b816000815181106113c4576113c4611976565b60200101906001600160f81b031916908160001a905350600f60fb1b816001815181106113f3576113f3611976565b60200101906001600160f81b031916908160001a9053506000611417846002611aa5565b611422906001611abc565b90505b600181111561149a576f181899199a1a9b1b9c1cb0b131b232b360811b85600f166010811061145657611456611976565b1a60f81b82828151811061146c5761146c611976565b60200101906001600160f81b031916908160001a90535060049490941c93611493816119a5565b9050611425565b5083156107e15760405162461bcd60e51b815260206004820181905260248201527f537472696e67733a20686578206c656e67746820696e73756666696369656e74604482015260640161065d565b600081815260018301602052604081205461153057508154600181810184556000848152602080822090930184905584548482528286019093526040902091909155610442565b506000610442565b6000818152600183016020526040812054801561162157600061155c600183611963565b855490915060009061157090600190611963565b90508181146115d557600086600001828154811061159057611590611976565b90600052602060002001549050808760000184815481106115b3576115b3611976565b6000918252602080832090910192909255918252600188019052604090208390555b85548690806115e6576115e6611acf565b600190038181906000526020600020016000905590558560010160008681526020019081526020016000206000905560019350505050610442565b6000915050610442565b60006020828403121561163d57600080fd5b81356001600160e01b0319811681146107e157600080fd5b60006020828403121561166757600080fd5b5035919050565b80356001600160a01b038116811461168557600080fd5b919050565b60006020828403121561169c57600080fd5b6107e18261166e565b60008083601f8401126116b757600080fd5b50813567ffffffffffffffff8111156116cf57600080fd5b6020830191508360208260051b85010111156116ea57600080fd5b9250929050565b6000806020838503121561170457600080fd5b823567ffffffffffffffff81111561171b57600080fd5b611727858286016116a5565b90969095509350505050565b6000806040838503121561174657600080fd5b823591506117566020840161166e565b90509250929050565b6000806000806040858703121561177557600080fd5b843567ffffffffffffffff8082111561178d57600080fd5b611799888389016116a5565b909650945060208701359150808211156117b257600080fd5b506117bf878288016116a5565b95989497509550505050565b600080604083850312156117de57600080fd5b50508035926020909101359150565b6000806040838503121561180057600080fd5b6118098361166e565b91506117566020840161166e565b634e487b7160e01b600052604160045260246000fd5b8015158114610f9357600080fd5b80356116858161182d565b60008060006040848603121561185b57600080fd5b833567ffffffffffffffff8082111561187357600080fd5b61187f878388016116a5565b909550935060209150858201358181111561189957600080fd5b8601601f810188136118aa57600080fd5b8035828111156118bc576118bc611817565b8060051b604051601f19603f830116810181811086821117156118e1576118e1611817565b60405291825284820193508281018501918a8311156118ff57600080fd5b928501925b82841015611924576119158461183b565b85529385019392850192611904565b8096505050505050509250925092565b60006020828403121561194657600080fd5b5051919050565b634e487b7160e01b600052601160045260246000fd5b818103818111156104425761044261194d565b634e487b7160e01b600052603260045260246000fd5b60006001820161199e5761199e61194d565b5060010190565b6000816119b4576119b461194d565b506000190190565b6000602082840312156119ce57600080fd5b81516107e18161182d565b60005b838110156119f45781810151838201526020016119dc565b50506000910152565b7f416363657373436f6e74726f6c3a206163636f756e7420000000000000000000815260008351611a358160178501602088016119d9565b7001034b99036b4b9b9b4b733903937b6329607d1b6017918401918201528351611a668160288401602088016119d9565b01602801949350505050565b6020815260008251806020840152611a918160408501602087016119d9565b601f01601f19169190910160400192915050565b80820281158282048414176104425761044261194d565b808201808211156104425761044261194d565b634e487b7160e01b600052603160045260246000fdfe241ecf16d79d0f8dbfb92cbc07fe17840425976cf0667f022fe9877caa831b08e2994f8d6f600ad473dba82c0a890ab7affacb860d3365f474baa3dc04a2e557a2646970667358221220efa42e41a8018e7a78d1440f415c580cebafee75b43c8942fe5067dac9dc192364736f6c63430008130033241ecf16d79d0f8dbfb92cbc07fe17840425976cf0667f022fe9877caa831b08
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R4\x80\x15b\0\0\x11W`\0\x80\xFD[P`@Qb\0\x1E?8\x03\x80b\0\x1E?\x839\x81\x01`@\x81\x90Rb\0\x004\x91b\0\x02jV[b\0\0A`\0\x83b\0\x01\0V[b\0\0\\`\0\x80Q` b\0\x1E\x1F\x839\x81Q\x91R\x83b\0\x01\0V[b\0\0w`\0\x80Q` b\0\x1E\x1F\x839\x81Q\x91R\x82b\0\x01\0V[`\x02\x80T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x85\x16\x90\x81\x17\x90\x91U`\x05\x80T`\xFF\x19\x16`\x01\x17\x90U`@Q\x7F\x8A\xC4\xB2\xEBwI\xF7\\[\x99\xB8\x98\xE5G\xFDa]\xD7\xA4$\xE6\x83V\xEA\x19k}\xAEt-l2\x90`\0\x90\xA2`@Q`\x01\x90\x7F\x8B\xC8_%\xE3\xE93\x97\x8F\t\x94\x08\xB3\xBB>\xB7c\x0Bv\xF7E_. [\xCB\xC0\xA7\x80\xE1~r\x90`\0\x90\xA2PPPb\0\x02\xB4V[b\0\x01\x0C\x82\x82b\0\x01\x10V[PPV[b\0\x01\x1C\x82\x82b\0\x01;V[`\0\x82\x81R`\x01` R`@\x90 b\0\x016\x90\x82b\0\x01\xDBV[PPPV[`\0\x82\x81R` \x81\x81R`@\x80\x83 `\x01`\x01`\xA0\x1B\x03\x85\x16\x84R\x90\x91R\x90 T`\xFF\x16b\0\x01\x0CW`\0\x82\x81R` \x81\x81R`@\x80\x83 `\x01`\x01`\xA0\x1B\x03\x85\x16\x84R\x90\x91R\x90 \x80T`\xFF\x19\x16`\x01\x17\x90Ub\0\x01\x973\x90V[`\x01`\x01`\xA0\x1B\x03\x16\x81`\x01`\x01`\xA0\x1B\x03\x16\x83\x7F/\x87\x88\x11~~\xFF\x1D\x82\xE9&\xECyI\x01\xD1|x\x02JP'\t@0E@\xA73eo\r`@Q`@Q\x80\x91\x03\x90\xA4PPV[`\0b\0\x01\xF2\x83`\x01`\x01`\xA0\x1B\x03\x84\x16b\0\x01\xFBV[\x90P[\x92\x91PPV[`\0\x81\x81R`\x01\x83\x01` R`@\x81 Tb\0\x02DWP\x81T`\x01\x81\x81\x01\x84U`\0\x84\x81R` \x80\x82 \x90\x93\x01\x84\x90U\x84T\x84\x82R\x82\x86\x01\x90\x93R`@\x90 \x91\x90\x91Ub\0\x01\xF5V[P`\0b\0\x01\xF5V[\x80Q`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14b\0\x02eW`\0\x80\xFD[\x91\x90PV[`\0\x80`\0``\x84\x86\x03\x12\x15b\0\x02\x80W`\0\x80\xFD[b\0\x02\x8B\x84b\0\x02MV[\x92Pb\0\x02\x9B` \x85\x01b\0\x02MV[\x91Pb\0\x02\xAB`@\x85\x01b\0\x02MV[\x90P\x92P\x92P\x92V[a\x1B[\x80b\0\x02\xC4`\09`\0\xF3\xFE`\x80`@R4\x80\x15a\0\x10W`\0\x80\xFD[P`\x046\x10a\x01\xC4W`\x005`\xE0\x1C\x80c\x90\x10\xD0|\x11a\0\xF9W\x80c\xCA\x15\xC8s\x11a\0\x97W\x80c\xCF\xB3s_\x11a\0qW\x80c\xCF\xB3s_\x14a\x03\xDAW\x80c\xD5Gt\x1F\x14a\x03\xE2W\x80c\xE3\xD2\xA0q\x14a\x03\xF5W\x80c\xEC\x87b\x1C\x14a\x04\x08W`\0\x80\xFD[\x80c\xCA\x15\xC8s\x14a\x03\xACW\x80c\xCA\xF5\xF5\x01\x14a\x03\xBFW\x80c\xCB\xEB\xAF\xE0\x14a\x03\xD2W`\0\x80\xFD[\x80c\xA0^\x0Fm\x11a\0\xD3W\x80c\xA0^\x0Fm\x14a\x03UW\x80c\xA2\x17\xFD\xDF\x14a\x03hW\x80c\xA5`]\xA5\x14a\x03pW\x80c\xC7\xEC\xAB\x8F\x14a\x03\x83W`\0\x80\xFD[\x80c\x90\x10\xD0|\x14a\x03\x0FW\x80c\x91\xD1HT\x14a\x03:W\x80c\x9C\x7Fd;\x14a\x03MW`\0\x80\xFD[\x80c6V\x8A\xBE\x11a\x01fW\x80cN\xB1\x80\\\x11a\x01@W\x80cN\xB1\x80\\\x14a\x02\xC3W\x80co\xFB\xF9\x88\x14a\x02\xD6W\x80cvY:9\x14a\x02\xE9W\x80c\x8Du;-\x14a\x02\xFCW`\0\x80\xFD[\x80c6V\x8A\xBE\x14a\x02}W\x80c?\xA5\x84W\x14a\x02\x90W\x80cA\xB6Ie\x14a\x02\xB0W`\0\x80\xFD[\x80c'\xB0@\xA1\x11a\x01\xA2W\x80c'\xB0@\xA1\x14a\x02/W\x80c*-\xEE\xE2\x14a\x02DW\x80c,3\xCA\xFB\x14a\x02WW\x80c//\xF1]\x14a\x02jW`\0\x80\xFD[\x80c\x01\xFF\xC9\xA7\x14a\x01\xC9W\x80c#\x8D\xAF\xE0\x14a\x01\xF1W\x80c$\x8A\x9C\xA3\x14a\x01\xFEW[`\0\x80\xFD[a\x01\xDCa\x01\xD76`\x04a\x16+V[a\x04\x1DV[`@Q\x90\x15\x15\x81R` \x01[`@Q\x80\x91\x03\x90\xF3[`\x05Ta\x01\xDC\x90`\xFF\x16\x81V[a\x02!a\x02\x0C6`\x04a\x16UV[`\0\x90\x81R` \x81\x90R`@\x90 `\x01\x01T\x90V[`@Q\x90\x81R` \x01a\x01\xE8V[a\x02Ba\x02=6`\x04a\x16\x8AV[a\x04HV[\0[a\x02!a\x02R6`\x04a\x16\x8AV[a\x04\xABV[a\x02Ba\x02e6`\x04a\x16\xF1V[a\x05]V[a\x02Ba\x02x6`\x04a\x173V[a\x05\xC7V[a\x02Ba\x02\x8B6`\x04a\x173V[a\x05\xF1V[a\x02!a\x02\x9E6`\x04a\x16\x8AV[`\x03` R`\0\x90\x81R`@\x90 T\x81V[a\x02Ba\x02\xBE6`\x04a\x16\xF1V[a\x06tV[a\x01\xDCa\x02\xD16`\x04a\x16\x8AV[a\x07\x97V[a\x01\xDCa\x02\xE46`\x04a\x16\x8AV[a\x07\xE8V[a\x02Ba\x02\xF76`\x04a\x16\xF1V[a\x07\xF3V[a\x02Ba\x03\n6`\x04a\x17_V[a\t\x88V[a\x03\"a\x03\x1D6`\x04a\x17\xCBV[a\x0B\x02V[`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R` \x01a\x01\xE8V[a\x01\xDCa\x03H6`\x04a\x173V[a\x0B\x1AV[a\x02Ba\x0BCV[a\x02Ba\x03c6`\x04a\x16\xF1V[a\x0BqV[a\x02!`\0\x81V[a\x01\xDCa\x03~6`\x04a\x17\xEDV[a\x0C\xC4V[a\x03\"a\x03\x916`\x04a\x16\x8AV[`\x04` R`\0\x90\x81R`@\x90 T`\x01`\x01`\xA0\x1B\x03\x16\x81V[a\x02!a\x03\xBA6`\x04a\x16UV[a\r\x13V[a\x02Ba\x03\xCD6`\x04a\x18FV[a\r*V[a\x02Ba\x0EDV[a\x02Ba\x0E\xB7V[a\x02Ba\x03\xF06`\x04a\x173V[a\x0F/V[`\x02Ta\x03\"\x90`\x01`\x01`\xA0\x1B\x03\x16\x81V[a\x02!`\0\x80Q` a\x1A\xE6\x839\x81Q\x91R\x81V[`\0`\x01`\x01`\xE0\x1B\x03\x19\x82\x16cZ\x05\x18\x0F`\xE0\x1B\x14\x80a\x04BWPa\x04B\x82a\x0FTV[\x92\x91PPV[`\0\x80Q` a\x1A\xE6\x839\x81Q\x91Ra\x04`\x81a\x0F\x89V[`\x02\x80T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x84\x16\x90\x81\x17\x90\x91U`@Q\x7F\x8A\xC4\xB2\xEBwI\xF7\\[\x99\xB8\x98\xE5G\xFDa]\xD7\xA4$\xE6\x83V\xEA\x19k}\xAEt-l2\x90`\0\x90\xA2PPV[`\x02T`@QcY\xAA'A`\xE1\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x83\x81\x16`\x04\x83\x01R`\0\x92\x83\x92\x91\x16\x90c\xB3TN\x82\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x04\xF9W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x05\x1D\x91\x90a\x194V[`\x01`\x01`\xA0\x1B\x03\x84\x16`\0\x90\x81R`\x03` R`@\x90 T\x90\x91P\x80\x82\x11\x15a\x05SWa\x05K\x81\x83a\x19cV[\x94\x93PPPPV[P`\0\x93\x92PPPV[`\0\x80Q` a\x1A\xE6\x839\x81Q\x91Ra\x05u\x81a\x0F\x89V[`\0[\x82\x81\x10\x15a\x05\xC1Wa\x05\xAF\x84\x84\x83\x81\x81\x10a\x05\x95Wa\x05\x95a\x19vV[\x90P` \x02\x01` \x81\x01\x90a\x05\xAA\x91\x90a\x16\x8AV[a\x0F\x96V[\x80a\x05\xB9\x81a\x19\x8CV[\x91PPa\x05xV[PPPPV[`\0\x82\x81R` \x81\x90R`@\x90 `\x01\x01Ta\x05\xE2\x81a\x0F\x89V[a\x05\xEC\x83\x83a\x0F\xF3V[PPPV[`\x01`\x01`\xA0\x1B\x03\x81\x163\x14a\x06fW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`/`$\x82\x01R\x7FAccessControl: can only renounce`D\x82\x01Rn\x1097\xB62\xB9\x9037\xB9\x109\xB2\xB63`\x89\x1B`d\x82\x01R`\x84\x01[`@Q\x80\x91\x03\x90\xFD[a\x06p\x82\x82a\x10\x15V[PPV[`\0\x80Q` a\x1A\xE6\x839\x81Q\x91Ra\x06\x8C\x81a\x0F\x89V[`\0[\x82\x81\x10\x15a\x05\xC1W`\0\x84\x84\x83\x81\x81\x10a\x06\xABWa\x06\xABa\x19vV[\x90P` \x02\x01` \x81\x01\x90a\x06\xC0\x91\x90a\x16\x8AV[`\x01`\x01`\xA0\x1B\x03\x80\x82\x16`\0\x90\x81R`\x04` R`@\x90 T\x91\x92P\x16\x80a\x07\x07W`@Qc\x168y\x15`\xE3\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x83\x16`\x04\x82\x01R`$\x01a\x06]V[`\x01`\x01`\xA0\x1B\x03\x81\x16`\0\x90\x81R`\x03` R`@\x81 \x80T\x91a\x07+\x83a\x19\xA5V[\x90\x91UPP`\x01`\x01`\xA0\x1B\x03\x80\x83\x16`\0\x81\x81R`\x04` R`@\x80\x82 \x80T`\x01`\x01`\xA0\x1B\x03\x19\x16\x90UQ\x91\x92\x84\x16\x91\x7F\x91v\n\x10\x01\xF51\xEC+\xEE\x86\x02\xBEU\xAD+\x11YF^\xDF\xF5\xBB\xCDA\xD2\x07\x03t*MB\x91\x90\xA3PP\x80\x80a\x07\x8F\x90a\x19\x8CV[\x91PPa\x06\x8FV[`\0`\x01`\x01`\xA0\x1B\x03\x82\x16a\x07\xAFWP`\0\x91\x90PV[`\x01`\x01`\xA0\x1B\x03\x80\x83\x16`\0\x90\x81R`\x04` R`@\x90 T\x16\x80a\x07\xD8WP`\0\x92\x91PPV[a\x07\xE1\x81a\x107V[\x93\x92PPPV[`\0a\x04B\x82a\x107V[`\x05T`\xFF\x16a\x08\x16W`@Qc\xC4&8\xBB`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\0[\x81\x81\x10\x15a\tAW`\0\x83\x83\x83\x81\x81\x10a\x085Wa\x085a\x19vV[\x90P` \x02\x01` \x81\x01\x90a\x08J\x91\x90a\x16\x8AV[`\x01`\x01`\xA0\x1B\x03\x80\x82\x16`\0\x90\x81R`\x04` R`@\x90 T\x91\x92P\x16a\x08r3\x83a\x10\xEDV[`\x01`\x01`\xA0\x1B\x03\x81\x16a\x08\xF8W3`\0\x90\x81R`\x03` R`@\x81 \x80T\x91a\x08\x9B\x83a\x19\x8CV[\x90\x91UPP`\x01`\x01`\xA0\x1B\x03\x82\x16`\0\x81\x81R`\x04` R`@\x80\x82 \x80T`\x01`\x01`\xA0\x1B\x03\x19\x163\x90\x81\x17\x90\x91U\x90Q\x90\x91\x7F\n1\xEE\x9DF\xA8(\x88K\x81\0<\x84\x98\x15n\xA6\xAA\x15\xB9\xB5K\xDD\x0E\xF0\xB53\xD9\xEB\xA5~U\x91\xA3a\t,V[`\x01`\x01`\xA0\x1B\x03\x81\x163\x14a\t,W`@Qc[S;\xA1`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x83\x16`\x04\x82\x01R`$\x01a\x06]V[PP\x80\x80a\t9\x90a\x19\x8CV[\x91PPa\x08\x19V[Pa\tK3a\x107V[a\thW`@Qc\x03\xEEoW`\xE2\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`@Q`\x01\x903\x90`\0\x80Q` a\x1B\x06\x839\x81Q\x91R\x90`\0\x90\xA3PPV[`\0\x80Q` a\x1A\xE6\x839\x81Q\x91Ra\t\xA0\x81a\x0F\x89V[\x83\x82\x14a\t\xC0W`@Qc\xED\x88/q`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\0[\x84\x81\x10\x15a\n\xFAW`\0\x84\x84\x83\x81\x81\x10a\t\xDFWa\t\xDFa\x19vV[\x90P` \x02\x01` \x81\x01\x90a\t\xF4\x91\x90a\x16\x8AV[\x90P`\0\x87\x87\x84\x81\x81\x10a\n\nWa\n\na\x19vV[\x90P` \x02\x01` \x81\x01\x90a\n\x1F\x91\x90a\x16\x8AV[`\x01`\x01`\xA0\x1B\x03\x83\x81\x16`\0\x90\x81R`\x04` R`@\x90 T\x91\x92P\x16\x15a\nfW`@Qc[S;\xA1`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x83\x16`\x04\x82\x01R`$\x01a\x06]V[`\x01`\x01`\xA0\x1B\x03\x81\x16`\0\x90\x81R`\x03` R`@\x81 \x80T\x91a\n\x8A\x83a\x19\x8CV[\x90\x91UPP`\x01`\x01`\xA0\x1B\x03\x82\x81\x16`\0\x81\x81R`\x04` R`@\x80\x82 \x80T`\x01`\x01`\xA0\x1B\x03\x19\x16\x94\x86\x16\x94\x85\x17\x90UQ\x91\x92\x91\x7F\x04\xE1\xEA\xA4\xDA\x18\xF7\xE7B\xA4\xED\xBB\xE9\xED\xE3l\xDFu\xF7\x93\xBB\x03\xAB!X\xC0\x87\x7F\x1C\xAF+\x93\x91\x90\xA3PP\x80\x80a\n\xF2\x90a\x19\x8CV[\x91PPa\t\xC3V[PPPPPPV[`\0\x82\x81R`\x01` R`@\x81 a\x07\xE1\x90\x83a\x11\x8FV[`\0\x91\x82R` \x82\x81R`@\x80\x84 `\x01`\x01`\xA0\x1B\x03\x93\x90\x93\x16\x84R\x91\x90R\x90 T`\xFF\x16\x90V[`\x05T`\xFF\x16a\x0BfW`@Qc\xC4&8\xBB`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x0Bo3a\x0F\x96V[V[`\x05T`\xFF\x16a\x0B\x94W`@Qc\xC4&8\xBB`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\0[\x81\x81\x10\x15a\x0C\xBAW`\0\x83\x83\x83\x81\x81\x10a\x0B\xB3Wa\x0B\xB3a\x19vV[\x90P` \x02\x01` \x81\x01\x90a\x0B\xC8\x91\x90a\x16\x8AV[`\x01`\x01`\xA0\x1B\x03\x80\x82\x16`\0\x90\x81R`\x04` R`@\x90 T\x91\x92P\x16a\x0B\xF03\x83a\x10\xEDV[3`\x01`\x01`\xA0\x1B\x03\x82\x16\x03a\x0CrW3`\0\x90\x81R`\x03` R`@\x81 \x80T\x91a\x0C\x1B\x83a\x19\xA5V[\x90\x91UPP`\x01`\x01`\xA0\x1B\x03\x82\x16`\0\x81\x81R`\x04` R`@\x80\x82 \x80T`\x01`\x01`\xA0\x1B\x03\x19\x16\x90UQ3\x91\x7F\x15\x9A\x8A\xE9H\xFC\xC6\xE7\xF8\xB5I\\\rs\xE9\x15\x98D\n\xF8\xA6(\x17$l\t\xED\xC2\xC2\x8D\xBA\x8A\x91\xA3a\x0C\xA5V[`\x01`\x01`\xA0\x1B\x03\x81\x16\x15a\x0C\xA5W`@Qc\xBFO\xDDs`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x83\x16`\x04\x82\x01R`$\x01a\x06]V[PP\x80\x80a\x0C\xB2\x90a\x19\x8CV[\x91PPa\x0B\x97V[Pa\x06p3a\x0F\x96V[`\0`\x01`\x01`\xA0\x1B\x03\x83\x16\x15\x80a\x0C\xE3WP`\x01`\x01`\xA0\x1B\x03\x82\x16\x15[\x15a\x0C\xF0WP`\0a\x04BV[P`\x01`\x01`\xA0\x1B\x03\x91\x82\x16`\0\x90\x81R`\x04` R`@\x90 T\x82\x16\x91\x16\x14\x90V[`\0\x81\x81R`\x01` R`@\x81 a\x04B\x90a\x11\x9BV[`\0\x80Q` a\x1A\xE6\x839\x81Q\x91Ra\rB\x81a\x0F\x89V[\x81Q\x83\x14a\rcW`@Qc\xED\x88/q`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\0[\x83\x81\x10\x15a\x0E=W\x82\x81\x81Q\x81\x10a\r\x80Wa\r\x80a\x19vV[` \x02` \x01\x01Q\x15a\r\xDEW`\x01\x85\x85\x83\x81\x81\x10a\r\xA1Wa\r\xA1a\x19vV[\x90P` \x02\x01` \x81\x01\x90a\r\xB6\x91\x90a\x16\x8AV[`\x01`\x01`\xA0\x1B\x03\x16`\0\x80Q` a\x1B\x06\x839\x81Q\x91R`@Q`@Q\x80\x91\x03\x90\xA3a\x0E+V[`\0\x85\x85\x83\x81\x81\x10a\r\xF2Wa\r\xF2a\x19vV[\x90P` \x02\x01` \x81\x01\x90a\x0E\x07\x91\x90a\x16\x8AV[`\x01`\x01`\xA0\x1B\x03\x16`\0\x80Q` a\x1B\x06\x839\x81Q\x91R`@Q`@Q\x80\x91\x03\x90\xA3[\x80a\x0E5\x81a\x19\x8CV[\x91PPa\rfV[PPPPPV[`\0\x80Q` a\x1A\xE6\x839\x81Q\x91Ra\x0E\\\x81a\x0F\x89V[`\x05T`\xFF\x16a\x0E\x7FW`@Qc\xC4&8\xBB`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x05\x80T`\xFF\x19\x16\x90U`@Q`\0\x90\x7F\x8B\xC8_%\xE3\xE93\x97\x8F\t\x94\x08\xB3\xBB>\xB7c\x0Bv\xF7E_. [\xCB\xC0\xA7\x80\xE1~r\x90\x82\x90\xA2PV[`\0\x80Q` a\x1A\xE6\x839\x81Q\x91Ra\x0E\xCF\x81a\x0F\x89V[`\x05T`\xFF\x16\x15a\x0E\xF3W`@Qc\xED\x1A\x0Cw`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x05\x80T`\xFF\x19\x16`\x01\x90\x81\x17\x90\x91U`@Q\x7F\x8B\xC8_%\xE3\xE93\x97\x8F\t\x94\x08\xB3\xBB>\xB7c\x0Bv\xF7E_. [\xCB\xC0\xA7\x80\xE1~r\x90`\0\x90\xA2PV[`\0\x82\x81R` \x81\x90R`@\x90 `\x01\x01Ta\x0FJ\x81a\x0F\x89V[a\x05\xEC\x83\x83a\x10\x15V[`\0`\x01`\x01`\xE0\x1B\x03\x19\x82\x16cye\xDB\x0B`\xE0\x1B\x14\x80a\x04BWPc\x01\xFF\xC9\xA7`\xE0\x1B`\x01`\x01`\xE0\x1B\x03\x19\x83\x16\x14a\x04BV[a\x0F\x93\x813a\x11\xA5V[PV[a\x0F\x9F\x81a\x107V[\x15a\x0F\xCCW`@Q`\x01\x90`\x01`\x01`\xA0\x1B\x03\x83\x16\x90`\0\x80Q` a\x1B\x06\x839\x81Q\x91R\x90`\0\x90\xA3PV[`@Q`\0\x90`\x01`\x01`\xA0\x1B\x03\x83\x16\x90`\0\x80Q` a\x1B\x06\x839\x81Q\x91R\x90\x83\x90\xA3PV[a\x0F\xFD\x82\x82a\x11\xFEV[`\0\x82\x81R`\x01` R`@\x90 a\x05\xEC\x90\x82a\x12\x82V[a\x10\x1F\x82\x82a\x12\x97V[`\0\x82\x81R`\x01` R`@\x90 a\x05\xEC\x90\x82a\x12\xFCV[`\x02T`@QcY\xAA'A`\xE1\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x83\x81\x16`\x04\x83\x01R`\0\x92\x83\x92\x91\x16\x90c\xB3TN\x82\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x10\x85W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x10\xA9\x91\x90a\x194V[\x90P\x80`\0\x03a\x10\xBCWP`\0\x92\x91PPV[`\x01`\x01`\xA0\x1B\x03\x83\x16`\0\x90\x81R`\x03` R`@\x90 T\x81\x10a\x10\xE4WP`\x01\x92\x91PPV[P`\0\x92\x91PPV[`\x02T`@Qc6\x16\xB4\x11`\xE2\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x84\x81\x16`\x04\x83\x01R\x83\x81\x16`$\x83\x01R`\0\x92\x16\x90c\xD8Z\xD0D\x90`D\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x11@W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x11d\x91\x90a\x19\xBCV[\x90P\x80a\x05\xECW`@Qc\x07AIg`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x83\x16`\x04\x82\x01R`$\x01a\x06]V[`\0a\x07\xE1\x83\x83a\x13\x11V[`\0a\x04B\x82T\x90V[a\x11\xAF\x82\x82a\x0B\x1AV[a\x06pWa\x11\xBC\x81a\x13;V[a\x11\xC7\x83` a\x13MV[`@Q` \x01a\x11\xD8\x92\x91\x90a\x19\xFDV[`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x90\x82\x90RbF\x1B\xCD`\xE5\x1B\x82Ra\x06]\x91`\x04\x01a\x1ArV[a\x12\x08\x82\x82a\x0B\x1AV[a\x06pW`\0\x82\x81R` \x81\x81R`@\x80\x83 `\x01`\x01`\xA0\x1B\x03\x85\x16\x84R\x90\x91R\x90 \x80T`\xFF\x19\x16`\x01\x17\x90Ua\x12>3\x90V[`\x01`\x01`\xA0\x1B\x03\x16\x81`\x01`\x01`\xA0\x1B\x03\x16\x83\x7F/\x87\x88\x11~~\xFF\x1D\x82\xE9&\xECyI\x01\xD1|x\x02JP'\t@0E@\xA73eo\r`@Q`@Q\x80\x91\x03\x90\xA4PPV[`\0a\x07\xE1\x83`\x01`\x01`\xA0\x1B\x03\x84\x16a\x14\xE9V[a\x12\xA1\x82\x82a\x0B\x1AV[\x15a\x06pW`\0\x82\x81R` \x81\x81R`@\x80\x83 `\x01`\x01`\xA0\x1B\x03\x85\x16\x80\x85R\x92R\x80\x83 \x80T`\xFF\x19\x16\x90UQ3\x92\x85\x91\x7F\xF69\x1F\\2\xD9\xC6\x9D*G\xEAg\x0BD)t\xB595\xD1\xED\xC7\xFDd\xEB!\xE0G\xA89\x17\x1B\x91\x90\xA4PPV[`\0a\x07\xE1\x83`\x01`\x01`\xA0\x1B\x03\x84\x16a\x158V[`\0\x82`\0\x01\x82\x81T\x81\x10a\x13(Wa\x13(a\x19vV[\x90`\0R` `\0 \x01T\x90P\x92\x91PPV[``a\x04B`\x01`\x01`\xA0\x1B\x03\x83\x16`\x14[```\0a\x13\\\x83`\x02a\x1A\xA5V[a\x13g\x90`\x02a\x1A\xBCV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x13\x7FWa\x13\x7Fa\x18\x17V[`@Q\x90\x80\x82R\x80`\x1F\x01`\x1F\x19\x16` \x01\x82\x01`@R\x80\x15a\x13\xA9W` \x82\x01\x81\x806\x837\x01\x90P[P\x90P`\x03`\xFC\x1B\x81`\0\x81Q\x81\x10a\x13\xC4Wa\x13\xC4a\x19vV[` \x01\x01\x90`\x01`\x01`\xF8\x1B\x03\x19\x16\x90\x81`\0\x1A\x90SP`\x0F`\xFB\x1B\x81`\x01\x81Q\x81\x10a\x13\xF3Wa\x13\xF3a\x19vV[` \x01\x01\x90`\x01`\x01`\xF8\x1B\x03\x19\x16\x90\x81`\0\x1A\x90SP`\0a\x14\x17\x84`\x02a\x1A\xA5V[a\x14\"\x90`\x01a\x1A\xBCV[\x90P[`\x01\x81\x11\x15a\x14\x9AWo\x18\x18\x99\x19\x9A\x1A\x9B\x1B\x9C\x1C\xB0\xB11\xB22\xB3`\x81\x1B\x85`\x0F\x16`\x10\x81\x10a\x14VWa\x14Va\x19vV[\x1A`\xF8\x1B\x82\x82\x81Q\x81\x10a\x14lWa\x14la\x19vV[` \x01\x01\x90`\x01`\x01`\xF8\x1B\x03\x19\x16\x90\x81`\0\x1A\x90SP`\x04\x94\x90\x94\x1C\x93a\x14\x93\x81a\x19\xA5V[\x90Pa\x14%V[P\x83\x15a\x07\xE1W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01\x81\x90R`$\x82\x01R\x7FStrings: hex length insufficient`D\x82\x01R`d\x01a\x06]V[`\0\x81\x81R`\x01\x83\x01` R`@\x81 Ta\x150WP\x81T`\x01\x81\x81\x01\x84U`\0\x84\x81R` \x80\x82 \x90\x93\x01\x84\x90U\x84T\x84\x82R\x82\x86\x01\x90\x93R`@\x90 \x91\x90\x91Ua\x04BV[P`\0a\x04BV[`\0\x81\x81R`\x01\x83\x01` R`@\x81 T\x80\x15a\x16!W`\0a\x15\\`\x01\x83a\x19cV[\x85T\x90\x91P`\0\x90a\x15p\x90`\x01\x90a\x19cV[\x90P\x81\x81\x14a\x15\xD5W`\0\x86`\0\x01\x82\x81T\x81\x10a\x15\x90Wa\x15\x90a\x19vV[\x90`\0R` `\0 \x01T\x90P\x80\x87`\0\x01\x84\x81T\x81\x10a\x15\xB3Wa\x15\xB3a\x19vV[`\0\x91\x82R` \x80\x83 \x90\x91\x01\x92\x90\x92U\x91\x82R`\x01\x88\x01\x90R`@\x90 \x83\x90U[\x85T\x86\x90\x80a\x15\xE6Wa\x15\xE6a\x1A\xCFV[`\x01\x90\x03\x81\x81\x90`\0R` `\0 \x01`\0\x90U\x90U\x85`\x01\x01`\0\x86\x81R` \x01\x90\x81R` \x01`\0 `\0\x90U`\x01\x93PPPPa\x04BV[`\0\x91PPa\x04BV[`\0` \x82\x84\x03\x12\x15a\x16=W`\0\x80\xFD[\x815`\x01`\x01`\xE0\x1B\x03\x19\x81\x16\x81\x14a\x07\xE1W`\0\x80\xFD[`\0` \x82\x84\x03\x12\x15a\x16gW`\0\x80\xFD[P5\x91\x90PV[\x805`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a\x16\x85W`\0\x80\xFD[\x91\x90PV[`\0` \x82\x84\x03\x12\x15a\x16\x9CW`\0\x80\xFD[a\x07\xE1\x82a\x16nV[`\0\x80\x83`\x1F\x84\x01\x12a\x16\xB7W`\0\x80\xFD[P\x815g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x16\xCFW`\0\x80\xFD[` \x83\x01\x91P\x83` \x82`\x05\x1B\x85\x01\x01\x11\x15a\x16\xEAW`\0\x80\xFD[\x92P\x92\x90PV[`\0\x80` \x83\x85\x03\x12\x15a\x17\x04W`\0\x80\xFD[\x825g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x17\x1BW`\0\x80\xFD[a\x17'\x85\x82\x86\x01a\x16\xA5V[\x90\x96\x90\x95P\x93PPPPV[`\0\x80`@\x83\x85\x03\x12\x15a\x17FW`\0\x80\xFD[\x825\x91Pa\x17V` \x84\x01a\x16nV[\x90P\x92P\x92\x90PV[`\0\x80`\0\x80`@\x85\x87\x03\x12\x15a\x17uW`\0\x80\xFD[\x845g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x82\x11\x15a\x17\x8DW`\0\x80\xFD[a\x17\x99\x88\x83\x89\x01a\x16\xA5V[\x90\x96P\x94P` \x87\x015\x91P\x80\x82\x11\x15a\x17\xB2W`\0\x80\xFD[Pa\x17\xBF\x87\x82\x88\x01a\x16\xA5V[\x95\x98\x94\x97P\x95PPPPV[`\0\x80`@\x83\x85\x03\x12\x15a\x17\xDEW`\0\x80\xFD[PP\x805\x92` \x90\x91\x015\x91PV[`\0\x80`@\x83\x85\x03\x12\x15a\x18\0W`\0\x80\xFD[a\x18\t\x83a\x16nV[\x91Pa\x17V` \x84\x01a\x16nV[cNH{q`\xE0\x1B`\0R`A`\x04R`$`\0\xFD[\x80\x15\x15\x81\x14a\x0F\x93W`\0\x80\xFD[\x805a\x16\x85\x81a\x18-V[`\0\x80`\0`@\x84\x86\x03\x12\x15a\x18[W`\0\x80\xFD[\x835g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x82\x11\x15a\x18sW`\0\x80\xFD[a\x18\x7F\x87\x83\x88\x01a\x16\xA5V[\x90\x95P\x93P` \x91P\x85\x82\x015\x81\x81\x11\x15a\x18\x99W`\0\x80\xFD[\x86\x01`\x1F\x81\x01\x88\x13a\x18\xAAW`\0\x80\xFD[\x805\x82\x81\x11\x15a\x18\xBCWa\x18\xBCa\x18\x17V[\x80`\x05\x1B`@Q`\x1F\x19`?\x83\x01\x16\x81\x01\x81\x81\x10\x86\x82\x11\x17\x15a\x18\xE1Wa\x18\xE1a\x18\x17V[`@R\x91\x82R\x84\x82\x01\x93P\x82\x81\x01\x85\x01\x91\x8A\x83\x11\x15a\x18\xFFW`\0\x80\xFD[\x92\x85\x01\x92[\x82\x84\x10\x15a\x19$Wa\x19\x15\x84a\x18;V[\x85R\x93\x85\x01\x93\x92\x85\x01\x92a\x19\x04V[\x80\x96PPPPPPP\x92P\x92P\x92V[`\0` \x82\x84\x03\x12\x15a\x19FW`\0\x80\xFD[PQ\x91\x90PV[cNH{q`\xE0\x1B`\0R`\x11`\x04R`$`\0\xFD[\x81\x81\x03\x81\x81\x11\x15a\x04BWa\x04Ba\x19MV[cNH{q`\xE0\x1B`\0R`2`\x04R`$`\0\xFD[`\0`\x01\x82\x01a\x19\x9EWa\x19\x9Ea\x19MV[P`\x01\x01\x90V[`\0\x81a\x19\xB4Wa\x19\xB4a\x19MV[P`\0\x19\x01\x90V[`\0` \x82\x84\x03\x12\x15a\x19\xCEW`\0\x80\xFD[\x81Qa\x07\xE1\x81a\x18-V[`\0[\x83\x81\x10\x15a\x19\xF4W\x81\x81\x01Q\x83\x82\x01R` \x01a\x19\xDCV[PP`\0\x91\x01RV[\x7FAccessControl: account \0\0\0\0\0\0\0\0\0\x81R`\0\x83Qa\x1A5\x81`\x17\x85\x01` \x88\x01a\x19\xD9V[p\x01\x03K\x99\x03kK\x9B\x9BKs9\x03\x93{c)`}\x1B`\x17\x91\x84\x01\x91\x82\x01R\x83Qa\x1Af\x81`(\x84\x01` \x88\x01a\x19\xD9V[\x01`(\x01\x94\x93PPPPV[` \x81R`\0\x82Q\x80` \x84\x01Ra\x1A\x91\x81`@\x85\x01` \x87\x01a\x19\xD9V[`\x1F\x01`\x1F\x19\x16\x91\x90\x91\x01`@\x01\x92\x91PPV[\x80\x82\x02\x81\x15\x82\x82\x04\x84\x14\x17a\x04BWa\x04Ba\x19MV[\x80\x82\x01\x80\x82\x11\x15a\x04BWa\x04Ba\x19MV[cNH{q`\xE0\x1B`\0R`1`\x04R`$`\0\xFD\xFE$\x1E\xCF\x16\xD7\x9D\x0F\x8D\xBF\xB9,\xBC\x07\xFE\x17\x84\x04%\x97l\xF0f\x7F\x02/\xE9\x87|\xAA\x83\x1B\x08\xE2\x99O\x8Do`\n\xD4s\xDB\xA8,\n\x89\n\xB7\xAF\xFA\xCB\x86\r3e\xF4t\xBA\xA3\xDC\x04\xA2\xE5W\xA2dipfsX\"\x12 \xEF\xA4.A\xA8\x01\x8Ezx\xD1D\x0FA\\X\x0C\xEB\xAF\xEEu\xB4<\x89B\xFEPg\xDA\xC9\xDC\x19#dsolcC\0\x08\x13\x003$\x1E\xCF\x16\xD7\x9D\x0F\x8D\xBF\xB9,\xBC\x07\xFE\x17\x84\x04%\x97l\xF0f\x7F\x02/\xE9\x87|\xAA\x83\x1B\x08",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x608060405234801561001057600080fd5b50600436106101c45760003560e01c80639010d07c116100f9578063ca15c87311610097578063cfb3735f11610071578063cfb3735f146103da578063d547741f146103e2578063e3d2a071146103f5578063ec87621c1461040857600080fd5b8063ca15c873146103ac578063caf5f501146103bf578063cbebafe0146103d257600080fd5b8063a05e0f6d116100d3578063a05e0f6d14610355578063a217fddf14610368578063a5605da514610370578063c7ecab8f1461038357600080fd5b80639010d07c1461030f57806391d148541461033a5780639c7f643b1461034d57600080fd5b806336568abe116101665780634eb1805c116101405780634eb1805c146102c35780636ffbf988146102d657806376593a39146102e95780638d753b2d146102fc57600080fd5b806336568abe1461027d5780633fa584571461029057806341b64965146102b057600080fd5b806327b040a1116101a257806327b040a11461022f5780632a2deee2146102445780632c33cafb146102575780632f2ff15d1461026a57600080fd5b806301ffc9a7146101c9578063238dafe0146101f1578063248a9ca3146101fe575b600080fd5b6101dc6101d736600461162b565b61041d565b60405190151581526020015b60405180910390f35b6005546101dc9060ff1681565b61022161020c366004611655565b60009081526020819052604090206001015490565b6040519081526020016101e8565b61024261023d36600461168a565b610448565b005b61022161025236600461168a565b6104ab565b6102426102653660046116f1565b61055d565b610242610278366004611733565b6105c7565b61024261028b366004611733565b6105f1565b61022161029e36600461168a565b60036020526000908152604090205481565b6102426102be3660046116f1565b610674565b6101dc6102d136600461168a565b610797565b6101dc6102e436600461168a565b6107e8565b6102426102f73660046116f1565b6107f3565b61024261030a36600461175f565b610988565b61032261031d3660046117cb565b610b02565b6040516001600160a01b0390911681526020016101e8565b6101dc610348366004611733565b610b1a565b610242610b43565b6102426103633660046116f1565b610b71565b610221600081565b6101dc61037e3660046117ed565b610cc4565b61032261039136600461168a565b6004602052600090815260409020546001600160a01b031681565b6102216103ba366004611655565b610d13565b6102426103cd366004611846565b610d2a565b610242610e44565b610242610eb7565b6102426103f0366004611733565b610f2f565b600254610322906001600160a01b031681565b610221600080516020611ae683398151915281565b60006001600160e01b03198216635a05180f60e01b1480610442575061044282610f54565b92915050565b600080516020611ae683398151915261046081610f89565b600280546001600160a01b0319166001600160a01b0384169081179091556040517f8ac4b2eb7749f75c5b99b898e547fd615dd7a424e68356ea196b7dae742d6c3290600090a25050565b6002546040516359aa274160e11b81526001600160a01b038381166004830152600092839291169063b3544e8290602401602060405180830381865afa1580156104f9573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061051d9190611934565b6001600160a01b038416600090815260036020526040902054909150808211156105535761054b8183611963565b949350505050565b5060009392505050565b600080516020611ae683398151915261057581610f89565b60005b828110156105c1576105af84848381811061059557610595611976565b90506020020160208101906105aa919061168a565b610f96565b806105b98161198c565b915050610578565b50505050565b6000828152602081905260409020600101546105e281610f89565b6105ec8383610ff3565b505050565b6001600160a01b03811633146106665760405162461bcd60e51b815260206004820152602f60248201527f416363657373436f6e74726f6c3a2063616e206f6e6c792072656e6f756e636560448201526e103937b632b9903337b91039b2b63360891b60648201526084015b60405180910390fd5b6106708282611015565b5050565b600080516020611ae683398151915261068c81610f89565b60005b828110156105c15760008484838181106106ab576106ab611976565b90506020020160208101906106c0919061168a565b6001600160a01b03808216600090815260046020526040902054919250168061070757604051631638791560e31b81526001600160a01b038316600482015260240161065d565b6001600160a01b038116600090815260036020526040812080549161072b836119a5565b90915550506001600160a01b0380831660008181526004602052604080822080546001600160a01b03191690555191928416917f91760a1001f531ec2bee8602be55ad2b1159465edff5bbcd41d20703742a4d429190a35050808061078f9061198c565b91505061068f565b60006001600160a01b0382166107af57506000919050565b6001600160a01b0380831660009081526004602052604090205416806107d85750600092915050565b6107e181611037565b9392505050565b600061044282611037565b60055460ff166108165760405163c42638bb60e01b815260040160405180910390fd5b60005b8181101561094157600083838381811061083557610835611976565b905060200201602081019061084a919061168a565b6001600160a01b038082166000908152600460205260409020549192501661087233836110ed565b6001600160a01b0381166108f85733600090815260036020526040812080549161089b8361198c565b90915550506001600160a01b03821660008181526004602052604080822080546001600160a01b03191633908117909155905190917f0a31ee9d46a828884b81003c8498156ea6aa15b9b54bdd0ef0b533d9eba57e5591a361092c565b6001600160a01b038116331461092c57604051635b533ba160e01b81526001600160a01b038316600482015260240161065d565b505080806109399061198c565b915050610819565b5061094b33611037565b610968576040516303ee6f5760e21b815260040160405180910390fd5b6040516001903390600080516020611b0683398151915290600090a35050565b600080516020611ae68339815191526109a081610f89565b8382146109c05760405163ed882f7160e01b815260040160405180910390fd5b60005b84811015610afa5760008484838181106109df576109df611976565b90506020020160208101906109f4919061168a565b90506000878784818110610a0a57610a0a611976565b9050602002016020810190610a1f919061168a565b6001600160a01b038381166000908152600460205260409020549192501615610a6657604051635b533ba160e01b81526001600160a01b038316600482015260240161065d565b6001600160a01b0381166000908152600360205260408120805491610a8a8361198c565b90915550506001600160a01b0382811660008181526004602052604080822080546001600160a01b0319169486169485179055519192917f04e1eaa4da18f7e742a4edbbe9ede36cdf75f793bb03ab2158c0877f1caf2b939190a350508080610af29061198c565b9150506109c3565b505050505050565b60008281526001602052604081206107e1908361118f565b6000918252602082815260408084206001600160a01b0393909316845291905290205460ff1690565b60055460ff16610b665760405163c42638bb60e01b815260040160405180910390fd5b610b6f33610f96565b565b60055460ff16610b945760405163c42638bb60e01b815260040160405180910390fd5b60005b81811015610cba576000838383818110610bb357610bb3611976565b9050602002016020810190610bc8919061168a565b6001600160a01b0380821660009081526004602052604090205491925016610bf033836110ed565b336001600160a01b03821603610c7257336000908152600360205260408120805491610c1b836119a5565b90915550506001600160a01b03821660008181526004602052604080822080546001600160a01b03191690555133917f159a8ae948fcc6e7f8b5495c0d73e91598440af8a62817246c09edc2c28dba8a91a3610ca5565b6001600160a01b03811615610ca55760405163bf4fdd7360e01b81526001600160a01b038316600482015260240161065d565b50508080610cb29061198c565b915050610b97565b5061067033610f96565b60006001600160a01b0383161580610ce357506001600160a01b038216155b15610cf057506000610442565b506001600160a01b03918216600090815260046020526040902054821691161490565b60008181526001602052604081206104429061119b565b600080516020611ae6833981519152610d4281610f89565b81518314610d635760405163ed882f7160e01b815260040160405180910390fd5b60005b83811015610e3d57828181518110610d8057610d80611976565b602002602001015115610dde576001858583818110610da157610da1611976565b9050602002016020810190610db6919061168a565b6001600160a01b0316600080516020611b0683398151915260405160405180910390a3610e2b565b6000858583818110610df257610df2611976565b9050602002016020810190610e07919061168a565b6001600160a01b0316600080516020611b0683398151915260405160405180910390a35b80610e358161198c565b915050610d66565b5050505050565b600080516020611ae6833981519152610e5c81610f89565b60055460ff16610e7f5760405163c42638bb60e01b815260040160405180910390fd5b6005805460ff191690556040516000907f8bc85f25e3e933978f099408b3bb3eb7630b76f7455f2e205bcbc0a780e17e72908290a250565b600080516020611ae6833981519152610ecf81610f89565b60055460ff1615610ef35760405163ed1a0c7760e01b815260040160405180910390fd5b6005805460ff191660019081179091556040517f8bc85f25e3e933978f099408b3bb3eb7630b76f7455f2e205bcbc0a780e17e7290600090a250565b600082815260208190526040902060010154610f4a81610f89565b6105ec8383611015565b60006001600160e01b03198216637965db0b60e01b148061044257506301ffc9a760e01b6001600160e01b0319831614610442565b610f9381336111a5565b50565b610f9f81611037565b15610fcc576040516001906001600160a01b03831690600080516020611b0683398151915290600090a350565b6040516000906001600160a01b03831690600080516020611b06833981519152908390a350565b610ffd82826111fe565b60008281526001602052604090206105ec9082611282565b61101f8282611297565b60008281526001602052604090206105ec90826112fc565b6002546040516359aa274160e11b81526001600160a01b038381166004830152600092839291169063b3544e8290602401602060405180830381865afa158015611085573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110a99190611934565b9050806000036110bc5750600092915050565b6001600160a01b03831660009081526003602052604090205481106110e45750600192915050565b50600092915050565b600254604051633616b41160e21b81526001600160a01b0384811660048301528381166024830152600092169063d85ad04490604401602060405180830381865afa158015611140573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061116491906119bc565b9050806105ec57604051630741496760e01b81526001600160a01b038316600482015260240161065d565b60006107e18383611311565b6000610442825490565b6111af8282610b1a565b610670576111bc8161133b565b6111c783602061134d565b6040516020016111d89291906119fd565b60408051601f198184030181529082905262461bcd60e51b825261065d91600401611a72565b6112088282610b1a565b610670576000828152602081815260408083206001600160a01b03851684529091529020805460ff1916600117905561123e3390565b6001600160a01b0316816001600160a01b0316837f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d60405160405180910390a45050565b60006107e1836001600160a01b0384166114e9565b6112a18282610b1a565b15610670576000828152602081815260408083206001600160a01b0385168085529252808320805460ff1916905551339285917ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b9190a45050565b60006107e1836001600160a01b038416611538565b600082600001828154811061132857611328611976565b9060005260206000200154905092915050565b60606104426001600160a01b03831660145b6060600061135c836002611aa5565b611367906002611abc565b67ffffffffffffffff81111561137f5761137f611817565b6040519080825280601f01601f1916602001820160405280156113a9576020820181803683370190505b509050600360fc1b816000815181106113c4576113c4611976565b60200101906001600160f81b031916908160001a905350600f60fb1b816001815181106113f3576113f3611976565b60200101906001600160f81b031916908160001a9053506000611417846002611aa5565b611422906001611abc565b90505b600181111561149a576f181899199a1a9b1b9c1cb0b131b232b360811b85600f166010811061145657611456611976565b1a60f81b82828151811061146c5761146c611976565b60200101906001600160f81b031916908160001a90535060049490941c93611493816119a5565b9050611425565b5083156107e15760405162461bcd60e51b815260206004820181905260248201527f537472696e67733a20686578206c656e67746820696e73756666696369656e74604482015260640161065d565b600081815260018301602052604081205461153057508154600181810184556000848152602080822090930184905584548482528286019093526040902091909155610442565b506000610442565b6000818152600183016020526040812054801561162157600061155c600183611963565b855490915060009061157090600190611963565b90508181146115d557600086600001828154811061159057611590611976565b90600052602060002001549050808760000184815481106115b3576115b3611976565b6000918252602080832090910192909255918252600188019052604090208390555b85548690806115e6576115e6611acf565b600190038181906000526020600020016000905590558560010160008681526020019081526020016000206000905560019350505050610442565b6000915050610442565b60006020828403121561163d57600080fd5b81356001600160e01b0319811681146107e157600080fd5b60006020828403121561166757600080fd5b5035919050565b80356001600160a01b038116811461168557600080fd5b919050565b60006020828403121561169c57600080fd5b6107e18261166e565b60008083601f8401126116b757600080fd5b50813567ffffffffffffffff8111156116cf57600080fd5b6020830191508360208260051b85010111156116ea57600080fd5b9250929050565b6000806020838503121561170457600080fd5b823567ffffffffffffffff81111561171b57600080fd5b611727858286016116a5565b90969095509350505050565b6000806040838503121561174657600080fd5b823591506117566020840161166e565b90509250929050565b6000806000806040858703121561177557600080fd5b843567ffffffffffffffff8082111561178d57600080fd5b611799888389016116a5565b909650945060208701359150808211156117b257600080fd5b506117bf878288016116a5565b95989497509550505050565b600080604083850312156117de57600080fd5b50508035926020909101359150565b6000806040838503121561180057600080fd5b6118098361166e565b91506117566020840161166e565b634e487b7160e01b600052604160045260246000fd5b8015158114610f9357600080fd5b80356116858161182d565b60008060006040848603121561185b57600080fd5b833567ffffffffffffffff8082111561187357600080fd5b61187f878388016116a5565b909550935060209150858201358181111561189957600080fd5b8601601f810188136118aa57600080fd5b8035828111156118bc576118bc611817565b8060051b604051601f19603f830116810181811086821117156118e1576118e1611817565b60405291825284820193508281018501918a8311156118ff57600080fd5b928501925b82841015611924576119158461183b565b85529385019392850192611904565b8096505050505050509250925092565b60006020828403121561194657600080fd5b5051919050565b634e487b7160e01b600052601160045260246000fd5b818103818111156104425761044261194d565b634e487b7160e01b600052603260045260246000fd5b60006001820161199e5761199e61194d565b5060010190565b6000816119b4576119b461194d565b506000190190565b6000602082840312156119ce57600080fd5b81516107e18161182d565b60005b838110156119f45781810151838201526020016119dc565b50506000910152565b7f416363657373436f6e74726f6c3a206163636f756e7420000000000000000000815260008351611a358160178501602088016119d9565b7001034b99036b4b9b9b4b733903937b6329607d1b6017918401918201528351611a668160288401602088016119d9565b01602801949350505050565b6020815260008251806020840152611a918160408501602087016119d9565b601f01601f19169190910160400192915050565b80820281158282048414176104425761044261194d565b808201808211156104425761044261194d565b634e487b7160e01b600052603160045260246000fdfe241ecf16d79d0f8dbfb92cbc07fe17840425976cf0667f022fe9877caa831b08e2994f8d6f600ad473dba82c0a890ab7affacb860d3365f474baa3dc04a2e557a2646970667358221220efa42e41a8018e7a78d1440f415c580cebafee75b43c8942fe5067dac9dc192364736f6c63430008130033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R4\x80\x15a\0\x10W`\0\x80\xFD[P`\x046\x10a\x01\xC4W`\x005`\xE0\x1C\x80c\x90\x10\xD0|\x11a\0\xF9W\x80c\xCA\x15\xC8s\x11a\0\x97W\x80c\xCF\xB3s_\x11a\0qW\x80c\xCF\xB3s_\x14a\x03\xDAW\x80c\xD5Gt\x1F\x14a\x03\xE2W\x80c\xE3\xD2\xA0q\x14a\x03\xF5W\x80c\xEC\x87b\x1C\x14a\x04\x08W`\0\x80\xFD[\x80c\xCA\x15\xC8s\x14a\x03\xACW\x80c\xCA\xF5\xF5\x01\x14a\x03\xBFW\x80c\xCB\xEB\xAF\xE0\x14a\x03\xD2W`\0\x80\xFD[\x80c\xA0^\x0Fm\x11a\0\xD3W\x80c\xA0^\x0Fm\x14a\x03UW\x80c\xA2\x17\xFD\xDF\x14a\x03hW\x80c\xA5`]\xA5\x14a\x03pW\x80c\xC7\xEC\xAB\x8F\x14a\x03\x83W`\0\x80\xFD[\x80c\x90\x10\xD0|\x14a\x03\x0FW\x80c\x91\xD1HT\x14a\x03:W\x80c\x9C\x7Fd;\x14a\x03MW`\0\x80\xFD[\x80c6V\x8A\xBE\x11a\x01fW\x80cN\xB1\x80\\\x11a\x01@W\x80cN\xB1\x80\\\x14a\x02\xC3W\x80co\xFB\xF9\x88\x14a\x02\xD6W\x80cvY:9\x14a\x02\xE9W\x80c\x8Du;-\x14a\x02\xFCW`\0\x80\xFD[\x80c6V\x8A\xBE\x14a\x02}W\x80c?\xA5\x84W\x14a\x02\x90W\x80cA\xB6Ie\x14a\x02\xB0W`\0\x80\xFD[\x80c'\xB0@\xA1\x11a\x01\xA2W\x80c'\xB0@\xA1\x14a\x02/W\x80c*-\xEE\xE2\x14a\x02DW\x80c,3\xCA\xFB\x14a\x02WW\x80c//\xF1]\x14a\x02jW`\0\x80\xFD[\x80c\x01\xFF\xC9\xA7\x14a\x01\xC9W\x80c#\x8D\xAF\xE0\x14a\x01\xF1W\x80c$\x8A\x9C\xA3\x14a\x01\xFEW[`\0\x80\xFD[a\x01\xDCa\x01\xD76`\x04a\x16+V[a\x04\x1DV[`@Q\x90\x15\x15\x81R` \x01[`@Q\x80\x91\x03\x90\xF3[`\x05Ta\x01\xDC\x90`\xFF\x16\x81V[a\x02!a\x02\x0C6`\x04a\x16UV[`\0\x90\x81R` \x81\x90R`@\x90 `\x01\x01T\x90V[`@Q\x90\x81R` \x01a\x01\xE8V[a\x02Ba\x02=6`\x04a\x16\x8AV[a\x04HV[\0[a\x02!a\x02R6`\x04a\x16\x8AV[a\x04\xABV[a\x02Ba\x02e6`\x04a\x16\xF1V[a\x05]V[a\x02Ba\x02x6`\x04a\x173V[a\x05\xC7V[a\x02Ba\x02\x8B6`\x04a\x173V[a\x05\xF1V[a\x02!a\x02\x9E6`\x04a\x16\x8AV[`\x03` R`\0\x90\x81R`@\x90 T\x81V[a\x02Ba\x02\xBE6`\x04a\x16\xF1V[a\x06tV[a\x01\xDCa\x02\xD16`\x04a\x16\x8AV[a\x07\x97V[a\x01\xDCa\x02\xE46`\x04a\x16\x8AV[a\x07\xE8V[a\x02Ba\x02\xF76`\x04a\x16\xF1V[a\x07\xF3V[a\x02Ba\x03\n6`\x04a\x17_V[a\t\x88V[a\x03\"a\x03\x1D6`\x04a\x17\xCBV[a\x0B\x02V[`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R` \x01a\x01\xE8V[a\x01\xDCa\x03H6`\x04a\x173V[a\x0B\x1AV[a\x02Ba\x0BCV[a\x02Ba\x03c6`\x04a\x16\xF1V[a\x0BqV[a\x02!`\0\x81V[a\x01\xDCa\x03~6`\x04a\x17\xEDV[a\x0C\xC4V[a\x03\"a\x03\x916`\x04a\x16\x8AV[`\x04` R`\0\x90\x81R`@\x90 T`\x01`\x01`\xA0\x1B\x03\x16\x81V[a\x02!a\x03\xBA6`\x04a\x16UV[a\r\x13V[a\x02Ba\x03\xCD6`\x04a\x18FV[a\r*V[a\x02Ba\x0EDV[a\x02Ba\x0E\xB7V[a\x02Ba\x03\xF06`\x04a\x173V[a\x0F/V[`\x02Ta\x03\"\x90`\x01`\x01`\xA0\x1B\x03\x16\x81V[a\x02!`\0\x80Q` a\x1A\xE6\x839\x81Q\x91R\x81V[`\0`\x01`\x01`\xE0\x1B\x03\x19\x82\x16cZ\x05\x18\x0F`\xE0\x1B\x14\x80a\x04BWPa\x04B\x82a\x0FTV[\x92\x91PPV[`\0\x80Q` a\x1A\xE6\x839\x81Q\x91Ra\x04`\x81a\x0F\x89V[`\x02\x80T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x84\x16\x90\x81\x17\x90\x91U`@Q\x7F\x8A\xC4\xB2\xEBwI\xF7\\[\x99\xB8\x98\xE5G\xFDa]\xD7\xA4$\xE6\x83V\xEA\x19k}\xAEt-l2\x90`\0\x90\xA2PPV[`\x02T`@QcY\xAA'A`\xE1\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x83\x81\x16`\x04\x83\x01R`\0\x92\x83\x92\x91\x16\x90c\xB3TN\x82\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x04\xF9W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x05\x1D\x91\x90a\x194V[`\x01`\x01`\xA0\x1B\x03\x84\x16`\0\x90\x81R`\x03` R`@\x90 T\x90\x91P\x80\x82\x11\x15a\x05SWa\x05K\x81\x83a\x19cV[\x94\x93PPPPV[P`\0\x93\x92PPPV[`\0\x80Q` a\x1A\xE6\x839\x81Q\x91Ra\x05u\x81a\x0F\x89V[`\0[\x82\x81\x10\x15a\x05\xC1Wa\x05\xAF\x84\x84\x83\x81\x81\x10a\x05\x95Wa\x05\x95a\x19vV[\x90P` \x02\x01` \x81\x01\x90a\x05\xAA\x91\x90a\x16\x8AV[a\x0F\x96V[\x80a\x05\xB9\x81a\x19\x8CV[\x91PPa\x05xV[PPPPV[`\0\x82\x81R` \x81\x90R`@\x90 `\x01\x01Ta\x05\xE2\x81a\x0F\x89V[a\x05\xEC\x83\x83a\x0F\xF3V[PPPV[`\x01`\x01`\xA0\x1B\x03\x81\x163\x14a\x06fW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`/`$\x82\x01R\x7FAccessControl: can only renounce`D\x82\x01Rn\x1097\xB62\xB9\x9037\xB9\x109\xB2\xB63`\x89\x1B`d\x82\x01R`\x84\x01[`@Q\x80\x91\x03\x90\xFD[a\x06p\x82\x82a\x10\x15V[PPV[`\0\x80Q` a\x1A\xE6\x839\x81Q\x91Ra\x06\x8C\x81a\x0F\x89V[`\0[\x82\x81\x10\x15a\x05\xC1W`\0\x84\x84\x83\x81\x81\x10a\x06\xABWa\x06\xABa\x19vV[\x90P` \x02\x01` \x81\x01\x90a\x06\xC0\x91\x90a\x16\x8AV[`\x01`\x01`\xA0\x1B\x03\x80\x82\x16`\0\x90\x81R`\x04` R`@\x90 T\x91\x92P\x16\x80a\x07\x07W`@Qc\x168y\x15`\xE3\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x83\x16`\x04\x82\x01R`$\x01a\x06]V[`\x01`\x01`\xA0\x1B\x03\x81\x16`\0\x90\x81R`\x03` R`@\x81 \x80T\x91a\x07+\x83a\x19\xA5V[\x90\x91UPP`\x01`\x01`\xA0\x1B\x03\x80\x83\x16`\0\x81\x81R`\x04` R`@\x80\x82 \x80T`\x01`\x01`\xA0\x1B\x03\x19\x16\x90UQ\x91\x92\x84\x16\x91\x7F\x91v\n\x10\x01\xF51\xEC+\xEE\x86\x02\xBEU\xAD+\x11YF^\xDF\xF5\xBB\xCDA\xD2\x07\x03t*MB\x91\x90\xA3PP\x80\x80a\x07\x8F\x90a\x19\x8CV[\x91PPa\x06\x8FV[`\0`\x01`\x01`\xA0\x1B\x03\x82\x16a\x07\xAFWP`\0\x91\x90PV[`\x01`\x01`\xA0\x1B\x03\x80\x83\x16`\0\x90\x81R`\x04` R`@\x90 T\x16\x80a\x07\xD8WP`\0\x92\x91PPV[a\x07\xE1\x81a\x107V[\x93\x92PPPV[`\0a\x04B\x82a\x107V[`\x05T`\xFF\x16a\x08\x16W`@Qc\xC4&8\xBB`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\0[\x81\x81\x10\x15a\tAW`\0\x83\x83\x83\x81\x81\x10a\x085Wa\x085a\x19vV[\x90P` \x02\x01` \x81\x01\x90a\x08J\x91\x90a\x16\x8AV[`\x01`\x01`\xA0\x1B\x03\x80\x82\x16`\0\x90\x81R`\x04` R`@\x90 T\x91\x92P\x16a\x08r3\x83a\x10\xEDV[`\x01`\x01`\xA0\x1B\x03\x81\x16a\x08\xF8W3`\0\x90\x81R`\x03` R`@\x81 \x80T\x91a\x08\x9B\x83a\x19\x8CV[\x90\x91UPP`\x01`\x01`\xA0\x1B\x03\x82\x16`\0\x81\x81R`\x04` R`@\x80\x82 \x80T`\x01`\x01`\xA0\x1B\x03\x19\x163\x90\x81\x17\x90\x91U\x90Q\x90\x91\x7F\n1\xEE\x9DF\xA8(\x88K\x81\0<\x84\x98\x15n\xA6\xAA\x15\xB9\xB5K\xDD\x0E\xF0\xB53\xD9\xEB\xA5~U\x91\xA3a\t,V[`\x01`\x01`\xA0\x1B\x03\x81\x163\x14a\t,W`@Qc[S;\xA1`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x83\x16`\x04\x82\x01R`$\x01a\x06]V[PP\x80\x80a\t9\x90a\x19\x8CV[\x91PPa\x08\x19V[Pa\tK3a\x107V[a\thW`@Qc\x03\xEEoW`\xE2\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`@Q`\x01\x903\x90`\0\x80Q` a\x1B\x06\x839\x81Q\x91R\x90`\0\x90\xA3PPV[`\0\x80Q` a\x1A\xE6\x839\x81Q\x91Ra\t\xA0\x81a\x0F\x89V[\x83\x82\x14a\t\xC0W`@Qc\xED\x88/q`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\0[\x84\x81\x10\x15a\n\xFAW`\0\x84\x84\x83\x81\x81\x10a\t\xDFWa\t\xDFa\x19vV[\x90P` \x02\x01` \x81\x01\x90a\t\xF4\x91\x90a\x16\x8AV[\x90P`\0\x87\x87\x84\x81\x81\x10a\n\nWa\n\na\x19vV[\x90P` \x02\x01` \x81\x01\x90a\n\x1F\x91\x90a\x16\x8AV[`\x01`\x01`\xA0\x1B\x03\x83\x81\x16`\0\x90\x81R`\x04` R`@\x90 T\x91\x92P\x16\x15a\nfW`@Qc[S;\xA1`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x83\x16`\x04\x82\x01R`$\x01a\x06]V[`\x01`\x01`\xA0\x1B\x03\x81\x16`\0\x90\x81R`\x03` R`@\x81 \x80T\x91a\n\x8A\x83a\x19\x8CV[\x90\x91UPP`\x01`\x01`\xA0\x1B\x03\x82\x81\x16`\0\x81\x81R`\x04` R`@\x80\x82 \x80T`\x01`\x01`\xA0\x1B\x03\x19\x16\x94\x86\x16\x94\x85\x17\x90UQ\x91\x92\x91\x7F\x04\xE1\xEA\xA4\xDA\x18\xF7\xE7B\xA4\xED\xBB\xE9\xED\xE3l\xDFu\xF7\x93\xBB\x03\xAB!X\xC0\x87\x7F\x1C\xAF+\x93\x91\x90\xA3PP\x80\x80a\n\xF2\x90a\x19\x8CV[\x91PPa\t\xC3V[PPPPPPV[`\0\x82\x81R`\x01` R`@\x81 a\x07\xE1\x90\x83a\x11\x8FV[`\0\x91\x82R` \x82\x81R`@\x80\x84 `\x01`\x01`\xA0\x1B\x03\x93\x90\x93\x16\x84R\x91\x90R\x90 T`\xFF\x16\x90V[`\x05T`\xFF\x16a\x0BfW`@Qc\xC4&8\xBB`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x0Bo3a\x0F\x96V[V[`\x05T`\xFF\x16a\x0B\x94W`@Qc\xC4&8\xBB`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\0[\x81\x81\x10\x15a\x0C\xBAW`\0\x83\x83\x83\x81\x81\x10a\x0B\xB3Wa\x0B\xB3a\x19vV[\x90P` \x02\x01` \x81\x01\x90a\x0B\xC8\x91\x90a\x16\x8AV[`\x01`\x01`\xA0\x1B\x03\x80\x82\x16`\0\x90\x81R`\x04` R`@\x90 T\x91\x92P\x16a\x0B\xF03\x83a\x10\xEDV[3`\x01`\x01`\xA0\x1B\x03\x82\x16\x03a\x0CrW3`\0\x90\x81R`\x03` R`@\x81 \x80T\x91a\x0C\x1B\x83a\x19\xA5V[\x90\x91UPP`\x01`\x01`\xA0\x1B\x03\x82\x16`\0\x81\x81R`\x04` R`@\x80\x82 \x80T`\x01`\x01`\xA0\x1B\x03\x19\x16\x90UQ3\x91\x7F\x15\x9A\x8A\xE9H\xFC\xC6\xE7\xF8\xB5I\\\rs\xE9\x15\x98D\n\xF8\xA6(\x17$l\t\xED\xC2\xC2\x8D\xBA\x8A\x91\xA3a\x0C\xA5V[`\x01`\x01`\xA0\x1B\x03\x81\x16\x15a\x0C\xA5W`@Qc\xBFO\xDDs`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x83\x16`\x04\x82\x01R`$\x01a\x06]V[PP\x80\x80a\x0C\xB2\x90a\x19\x8CV[\x91PPa\x0B\x97V[Pa\x06p3a\x0F\x96V[`\0`\x01`\x01`\xA0\x1B\x03\x83\x16\x15\x80a\x0C\xE3WP`\x01`\x01`\xA0\x1B\x03\x82\x16\x15[\x15a\x0C\xF0WP`\0a\x04BV[P`\x01`\x01`\xA0\x1B\x03\x91\x82\x16`\0\x90\x81R`\x04` R`@\x90 T\x82\x16\x91\x16\x14\x90V[`\0\x81\x81R`\x01` R`@\x81 a\x04B\x90a\x11\x9BV[`\0\x80Q` a\x1A\xE6\x839\x81Q\x91Ra\rB\x81a\x0F\x89V[\x81Q\x83\x14a\rcW`@Qc\xED\x88/q`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\0[\x83\x81\x10\x15a\x0E=W\x82\x81\x81Q\x81\x10a\r\x80Wa\r\x80a\x19vV[` \x02` \x01\x01Q\x15a\r\xDEW`\x01\x85\x85\x83\x81\x81\x10a\r\xA1Wa\r\xA1a\x19vV[\x90P` \x02\x01` \x81\x01\x90a\r\xB6\x91\x90a\x16\x8AV[`\x01`\x01`\xA0\x1B\x03\x16`\0\x80Q` a\x1B\x06\x839\x81Q\x91R`@Q`@Q\x80\x91\x03\x90\xA3a\x0E+V[`\0\x85\x85\x83\x81\x81\x10a\r\xF2Wa\r\xF2a\x19vV[\x90P` \x02\x01` \x81\x01\x90a\x0E\x07\x91\x90a\x16\x8AV[`\x01`\x01`\xA0\x1B\x03\x16`\0\x80Q` a\x1B\x06\x839\x81Q\x91R`@Q`@Q\x80\x91\x03\x90\xA3[\x80a\x0E5\x81a\x19\x8CV[\x91PPa\rfV[PPPPPV[`\0\x80Q` a\x1A\xE6\x839\x81Q\x91Ra\x0E\\\x81a\x0F\x89V[`\x05T`\xFF\x16a\x0E\x7FW`@Qc\xC4&8\xBB`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x05\x80T`\xFF\x19\x16\x90U`@Q`\0\x90\x7F\x8B\xC8_%\xE3\xE93\x97\x8F\t\x94\x08\xB3\xBB>\xB7c\x0Bv\xF7E_. [\xCB\xC0\xA7\x80\xE1~r\x90\x82\x90\xA2PV[`\0\x80Q` a\x1A\xE6\x839\x81Q\x91Ra\x0E\xCF\x81a\x0F\x89V[`\x05T`\xFF\x16\x15a\x0E\xF3W`@Qc\xED\x1A\x0Cw`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x05\x80T`\xFF\x19\x16`\x01\x90\x81\x17\x90\x91U`@Q\x7F\x8B\xC8_%\xE3\xE93\x97\x8F\t\x94\x08\xB3\xBB>\xB7c\x0Bv\xF7E_. [\xCB\xC0\xA7\x80\xE1~r\x90`\0\x90\xA2PV[`\0\x82\x81R` \x81\x90R`@\x90 `\x01\x01Ta\x0FJ\x81a\x0F\x89V[a\x05\xEC\x83\x83a\x10\x15V[`\0`\x01`\x01`\xE0\x1B\x03\x19\x82\x16cye\xDB\x0B`\xE0\x1B\x14\x80a\x04BWPc\x01\xFF\xC9\xA7`\xE0\x1B`\x01`\x01`\xE0\x1B\x03\x19\x83\x16\x14a\x04BV[a\x0F\x93\x813a\x11\xA5V[PV[a\x0F\x9F\x81a\x107V[\x15a\x0F\xCCW`@Q`\x01\x90`\x01`\x01`\xA0\x1B\x03\x83\x16\x90`\0\x80Q` a\x1B\x06\x839\x81Q\x91R\x90`\0\x90\xA3PV[`@Q`\0\x90`\x01`\x01`\xA0\x1B\x03\x83\x16\x90`\0\x80Q` a\x1B\x06\x839\x81Q\x91R\x90\x83\x90\xA3PV[a\x0F\xFD\x82\x82a\x11\xFEV[`\0\x82\x81R`\x01` R`@\x90 a\x05\xEC\x90\x82a\x12\x82V[a\x10\x1F\x82\x82a\x12\x97V[`\0\x82\x81R`\x01` R`@\x90 a\x05\xEC\x90\x82a\x12\xFCV[`\x02T`@QcY\xAA'A`\xE1\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x83\x81\x16`\x04\x83\x01R`\0\x92\x83\x92\x91\x16\x90c\xB3TN\x82\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x10\x85W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x10\xA9\x91\x90a\x194V[\x90P\x80`\0\x03a\x10\xBCWP`\0\x92\x91PPV[`\x01`\x01`\xA0\x1B\x03\x83\x16`\0\x90\x81R`\x03` R`@\x90 T\x81\x10a\x10\xE4WP`\x01\x92\x91PPV[P`\0\x92\x91PPV[`\x02T`@Qc6\x16\xB4\x11`\xE2\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x84\x81\x16`\x04\x83\x01R\x83\x81\x16`$\x83\x01R`\0\x92\x16\x90c\xD8Z\xD0D\x90`D\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x11@W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x11d\x91\x90a\x19\xBCV[\x90P\x80a\x05\xECW`@Qc\x07AIg`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x83\x16`\x04\x82\x01R`$\x01a\x06]V[`\0a\x07\xE1\x83\x83a\x13\x11V[`\0a\x04B\x82T\x90V[a\x11\xAF\x82\x82a\x0B\x1AV[a\x06pWa\x11\xBC\x81a\x13;V[a\x11\xC7\x83` a\x13MV[`@Q` \x01a\x11\xD8\x92\x91\x90a\x19\xFDV[`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x90\x82\x90RbF\x1B\xCD`\xE5\x1B\x82Ra\x06]\x91`\x04\x01a\x1ArV[a\x12\x08\x82\x82a\x0B\x1AV[a\x06pW`\0\x82\x81R` \x81\x81R`@\x80\x83 `\x01`\x01`\xA0\x1B\x03\x85\x16\x84R\x90\x91R\x90 \x80T`\xFF\x19\x16`\x01\x17\x90Ua\x12>3\x90V[`\x01`\x01`\xA0\x1B\x03\x16\x81`\x01`\x01`\xA0\x1B\x03\x16\x83\x7F/\x87\x88\x11~~\xFF\x1D\x82\xE9&\xECyI\x01\xD1|x\x02JP'\t@0E@\xA73eo\r`@Q`@Q\x80\x91\x03\x90\xA4PPV[`\0a\x07\xE1\x83`\x01`\x01`\xA0\x1B\x03\x84\x16a\x14\xE9V[a\x12\xA1\x82\x82a\x0B\x1AV[\x15a\x06pW`\0\x82\x81R` \x81\x81R`@\x80\x83 `\x01`\x01`\xA0\x1B\x03\x85\x16\x80\x85R\x92R\x80\x83 \x80T`\xFF\x19\x16\x90UQ3\x92\x85\x91\x7F\xF69\x1F\\2\xD9\xC6\x9D*G\xEAg\x0BD)t\xB595\xD1\xED\xC7\xFDd\xEB!\xE0G\xA89\x17\x1B\x91\x90\xA4PPV[`\0a\x07\xE1\x83`\x01`\x01`\xA0\x1B\x03\x84\x16a\x158V[`\0\x82`\0\x01\x82\x81T\x81\x10a\x13(Wa\x13(a\x19vV[\x90`\0R` `\0 \x01T\x90P\x92\x91PPV[``a\x04B`\x01`\x01`\xA0\x1B\x03\x83\x16`\x14[```\0a\x13\\\x83`\x02a\x1A\xA5V[a\x13g\x90`\x02a\x1A\xBCV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x13\x7FWa\x13\x7Fa\x18\x17V[`@Q\x90\x80\x82R\x80`\x1F\x01`\x1F\x19\x16` \x01\x82\x01`@R\x80\x15a\x13\xA9W` \x82\x01\x81\x806\x837\x01\x90P[P\x90P`\x03`\xFC\x1B\x81`\0\x81Q\x81\x10a\x13\xC4Wa\x13\xC4a\x19vV[` \x01\x01\x90`\x01`\x01`\xF8\x1B\x03\x19\x16\x90\x81`\0\x1A\x90SP`\x0F`\xFB\x1B\x81`\x01\x81Q\x81\x10a\x13\xF3Wa\x13\xF3a\x19vV[` \x01\x01\x90`\x01`\x01`\xF8\x1B\x03\x19\x16\x90\x81`\0\x1A\x90SP`\0a\x14\x17\x84`\x02a\x1A\xA5V[a\x14\"\x90`\x01a\x1A\xBCV[\x90P[`\x01\x81\x11\x15a\x14\x9AWo\x18\x18\x99\x19\x9A\x1A\x9B\x1B\x9C\x1C\xB0\xB11\xB22\xB3`\x81\x1B\x85`\x0F\x16`\x10\x81\x10a\x14VWa\x14Va\x19vV[\x1A`\xF8\x1B\x82\x82\x81Q\x81\x10a\x14lWa\x14la\x19vV[` \x01\x01\x90`\x01`\x01`\xF8\x1B\x03\x19\x16\x90\x81`\0\x1A\x90SP`\x04\x94\x90\x94\x1C\x93a\x14\x93\x81a\x19\xA5V[\x90Pa\x14%V[P\x83\x15a\x07\xE1W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01\x81\x90R`$\x82\x01R\x7FStrings: hex length insufficient`D\x82\x01R`d\x01a\x06]V[`\0\x81\x81R`\x01\x83\x01` R`@\x81 Ta\x150WP\x81T`\x01\x81\x81\x01\x84U`\0\x84\x81R` \x80\x82 \x90\x93\x01\x84\x90U\x84T\x84\x82R\x82\x86\x01\x90\x93R`@\x90 \x91\x90\x91Ua\x04BV[P`\0a\x04BV[`\0\x81\x81R`\x01\x83\x01` R`@\x81 T\x80\x15a\x16!W`\0a\x15\\`\x01\x83a\x19cV[\x85T\x90\x91P`\0\x90a\x15p\x90`\x01\x90a\x19cV[\x90P\x81\x81\x14a\x15\xD5W`\0\x86`\0\x01\x82\x81T\x81\x10a\x15\x90Wa\x15\x90a\x19vV[\x90`\0R` `\0 \x01T\x90P\x80\x87`\0\x01\x84\x81T\x81\x10a\x15\xB3Wa\x15\xB3a\x19vV[`\0\x91\x82R` \x80\x83 \x90\x91\x01\x92\x90\x92U\x91\x82R`\x01\x88\x01\x90R`@\x90 \x83\x90U[\x85T\x86\x90\x80a\x15\xE6Wa\x15\xE6a\x1A\xCFV[`\x01\x90\x03\x81\x81\x90`\0R` `\0 \x01`\0\x90U\x90U\x85`\x01\x01`\0\x86\x81R` \x01\x90\x81R` \x01`\0 `\0\x90U`\x01\x93PPPPa\x04BV[`\0\x91PPa\x04BV[`\0` \x82\x84\x03\x12\x15a\x16=W`\0\x80\xFD[\x815`\x01`\x01`\xE0\x1B\x03\x19\x81\x16\x81\x14a\x07\xE1W`\0\x80\xFD[`\0` \x82\x84\x03\x12\x15a\x16gW`\0\x80\xFD[P5\x91\x90PV[\x805`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a\x16\x85W`\0\x80\xFD[\x91\x90PV[`\0` \x82\x84\x03\x12\x15a\x16\x9CW`\0\x80\xFD[a\x07\xE1\x82a\x16nV[`\0\x80\x83`\x1F\x84\x01\x12a\x16\xB7W`\0\x80\xFD[P\x815g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x16\xCFW`\0\x80\xFD[` \x83\x01\x91P\x83` \x82`\x05\x1B\x85\x01\x01\x11\x15a\x16\xEAW`\0\x80\xFD[\x92P\x92\x90PV[`\0\x80` \x83\x85\x03\x12\x15a\x17\x04W`\0\x80\xFD[\x825g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x17\x1BW`\0\x80\xFD[a\x17'\x85\x82\x86\x01a\x16\xA5V[\x90\x96\x90\x95P\x93PPPPV[`\0\x80`@\x83\x85\x03\x12\x15a\x17FW`\0\x80\xFD[\x825\x91Pa\x17V` \x84\x01a\x16nV[\x90P\x92P\x92\x90PV[`\0\x80`\0\x80`@\x85\x87\x03\x12\x15a\x17uW`\0\x80\xFD[\x845g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x82\x11\x15a\x17\x8DW`\0\x80\xFD[a\x17\x99\x88\x83\x89\x01a\x16\xA5V[\x90\x96P\x94P` \x87\x015\x91P\x80\x82\x11\x15a\x17\xB2W`\0\x80\xFD[Pa\x17\xBF\x87\x82\x88\x01a\x16\xA5V[\x95\x98\x94\x97P\x95PPPPV[`\0\x80`@\x83\x85\x03\x12\x15a\x17\xDEW`\0\x80\xFD[PP\x805\x92` \x90\x91\x015\x91PV[`\0\x80`@\x83\x85\x03\x12\x15a\x18\0W`\0\x80\xFD[a\x18\t\x83a\x16nV[\x91Pa\x17V` \x84\x01a\x16nV[cNH{q`\xE0\x1B`\0R`A`\x04R`$`\0\xFD[\x80\x15\x15\x81\x14a\x0F\x93W`\0\x80\xFD[\x805a\x16\x85\x81a\x18-V[`\0\x80`\0`@\x84\x86\x03\x12\x15a\x18[W`\0\x80\xFD[\x835g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x82\x11\x15a\x18sW`\0\x80\xFD[a\x18\x7F\x87\x83\x88\x01a\x16\xA5V[\x90\x95P\x93P` \x91P\x85\x82\x015\x81\x81\x11\x15a\x18\x99W`\0\x80\xFD[\x86\x01`\x1F\x81\x01\x88\x13a\x18\xAAW`\0\x80\xFD[\x805\x82\x81\x11\x15a\x18\xBCWa\x18\xBCa\x18\x17V[\x80`\x05\x1B`@Q`\x1F\x19`?\x83\x01\x16\x81\x01\x81\x81\x10\x86\x82\x11\x17\x15a\x18\xE1Wa\x18\xE1a\x18\x17V[`@R\x91\x82R\x84\x82\x01\x93P\x82\x81\x01\x85\x01\x91\x8A\x83\x11\x15a\x18\xFFW`\0\x80\xFD[\x92\x85\x01\x92[\x82\x84\x10\x15a\x19$Wa\x19\x15\x84a\x18;V[\x85R\x93\x85\x01\x93\x92\x85\x01\x92a\x19\x04V[\x80\x96PPPPPPP\x92P\x92P\x92V[`\0` \x82\x84\x03\x12\x15a\x19FW`\0\x80\xFD[PQ\x91\x90PV[cNH{q`\xE0\x1B`\0R`\x11`\x04R`$`\0\xFD[\x81\x81\x03\x81\x81\x11\x15a\x04BWa\x04Ba\x19MV[cNH{q`\xE0\x1B`\0R`2`\x04R`$`\0\xFD[`\0`\x01\x82\x01a\x19\x9EWa\x19\x9Ea\x19MV[P`\x01\x01\x90V[`\0\x81a\x19\xB4Wa\x19\xB4a\x19MV[P`\0\x19\x01\x90V[`\0` \x82\x84\x03\x12\x15a\x19\xCEW`\0\x80\xFD[\x81Qa\x07\xE1\x81a\x18-V[`\0[\x83\x81\x10\x15a\x19\xF4W\x81\x81\x01Q\x83\x82\x01R` \x01a\x19\xDCV[PP`\0\x91\x01RV[\x7FAccessControl: account \0\0\0\0\0\0\0\0\0\x81R`\0\x83Qa\x1A5\x81`\x17\x85\x01` \x88\x01a\x19\xD9V[p\x01\x03K\x99\x03kK\x9B\x9BKs9\x03\x93{c)`}\x1B`\x17\x91\x84\x01\x91\x82\x01R\x83Qa\x1Af\x81`(\x84\x01` \x88\x01a\x19\xD9V[\x01`(\x01\x94\x93PPPPV[` \x81R`\0\x82Q\x80` \x84\x01Ra\x1A\x91\x81`@\x85\x01` \x87\x01a\x19\xD9V[`\x1F\x01`\x1F\x19\x16\x91\x90\x91\x01`@\x01\x92\x91PPV[\x80\x82\x02\x81\x15\x82\x82\x04\x84\x14\x17a\x04BWa\x04Ba\x19MV[\x80\x82\x01\x80\x82\x11\x15a\x04BWa\x04Ba\x19MV[cNH{q`\xE0\x1B`\0R`1`\x04R`$`\0\xFD\xFE$\x1E\xCF\x16\xD7\x9D\x0F\x8D\xBF\xB9,\xBC\x07\xFE\x17\x84\x04%\x97l\xF0f\x7F\x02/\xE9\x87|\xAA\x83\x1B\x08\xE2\x99O\x8Do`\n\xD4s\xDB\xA8,\n\x89\n\xB7\xAF\xFA\xCB\x86\r3e\xF4t\xBA\xA3\xDC\x04\xA2\xE5W\xA2dipfsX\"\x12 \xEF\xA4.A\xA8\x01\x8Ezx\xD1D\x0FA\\X\x0C\xEB\xAF\xEEu\xB4<\x89B\xFEPg\xDA\xC9\xDC\x19#dsolcC\0\x08\x13\x003",
    );
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ArrayLengthNotMatch()` and selector `0xed882f71`.
```solidity
error ArrayLengthNotMatch();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ArrayLengthNotMatch;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ArrayLengthNotMatch> for UnderlyingRustTuple<'_> {
            fn from(value: ArrayLengthNotMatch) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ArrayLengthNotMatch {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ArrayLengthNotMatch {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ArrayLengthNotMatch()";
            const SELECTOR: [u8; 4] = [237u8, 136u8, 47u8, 113u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `CannotOperateForNode(address)` and selector `0x07414967`.
```solidity
error CannotOperateForNode(address nodeAddress);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct CannotOperateForNode {
        #[allow(missing_docs)]
        pub nodeAddress: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<CannotOperateForNode> for UnderlyingRustTuple<'_> {
            fn from(value: CannotOperateForNode) -> Self {
                (value.nodeAddress,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for CannotOperateForNode {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { nodeAddress: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for CannotOperateForNode {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "CannotOperateForNode(address)";
            const SELECTOR: [u8; 4] = [7u8, 65u8, 73u8, 103u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.nodeAddress,
                    ),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `GloballyDisabledRegistry()` and selector `0xc42638bb`.
```solidity
error GloballyDisabledRegistry();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct GloballyDisabledRegistry;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<GloballyDisabledRegistry>
        for UnderlyingRustTuple<'_> {
            fn from(value: GloballyDisabledRegistry) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for GloballyDisabledRegistry {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for GloballyDisabledRegistry {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "GloballyDisabledRegistry()";
            const SELECTOR: [u8; 4] = [196u8, 38u8, 56u8, 187u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `GloballyEnabledRegistry()` and selector `0xed1a0c77`.
```solidity
error GloballyEnabledRegistry();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct GloballyEnabledRegistry;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<GloballyEnabledRegistry> for UnderlyingRustTuple<'_> {
            fn from(value: GloballyEnabledRegistry) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for GloballyEnabledRegistry {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for GloballyEnabledRegistry {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "GloballyEnabledRegistry()";
            const SELECTOR: [u8; 4] = [237u8, 26u8, 12u8, 119u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NodeAlreadyRegisterd(address)` and selector `0x5b533ba1`.
```solidity
error NodeAlreadyRegisterd(address nodeAddress);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NodeAlreadyRegisterd {
        #[allow(missing_docs)]
        pub nodeAddress: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NodeAlreadyRegisterd> for UnderlyingRustTuple<'_> {
            fn from(value: NodeAlreadyRegisterd) -> Self {
                (value.nodeAddress,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NodeAlreadyRegisterd {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { nodeAddress: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NodeAlreadyRegisterd {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NodeAlreadyRegisterd(address)";
            const SELECTOR: [u8; 4] = [91u8, 83u8, 59u8, 161u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.nodeAddress,
                    ),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NodeNotYetRegisterd(address)` and selector `0xb1c3c8a8`.
```solidity
error NodeNotYetRegisterd(address nodeAddress);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NodeNotYetRegisterd {
        #[allow(missing_docs)]
        pub nodeAddress: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NodeNotYetRegisterd> for UnderlyingRustTuple<'_> {
            fn from(value: NodeNotYetRegisterd) -> Self {
                (value.nodeAddress,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NodeNotYetRegisterd {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { nodeAddress: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NodeNotYetRegisterd {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NodeNotYetRegisterd(address)";
            const SELECTOR: [u8; 4] = [177u8, 195u8, 200u8, 168u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.nodeAddress,
                    ),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NodeRegisterdToOtherAccount(address)` and selector `0xbf4fdd73`.
```solidity
error NodeRegisterdToOtherAccount(address nodeAddress);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NodeRegisterdToOtherAccount {
        #[allow(missing_docs)]
        pub nodeAddress: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NodeRegisterdToOtherAccount>
        for UnderlyingRustTuple<'_> {
            fn from(value: NodeRegisterdToOtherAccount) -> Self {
                (value.nodeAddress,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for NodeRegisterdToOtherAccount {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { nodeAddress: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NodeRegisterdToOtherAccount {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NodeRegisterdToOtherAccount(address)";
            const SELECTOR: [u8; 4] = [191u8, 79u8, 221u8, 115u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.nodeAddress,
                    ),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NotEnoughAllowanceToRegisterNode()` and selector `0x0fb9bd5c`.
```solidity
error NotEnoughAllowanceToRegisterNode();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotEnoughAllowanceToRegisterNode;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotEnoughAllowanceToRegisterNode>
        for UnderlyingRustTuple<'_> {
            fn from(value: NotEnoughAllowanceToRegisterNode) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for NotEnoughAllowanceToRegisterNode {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotEnoughAllowanceToRegisterNode {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotEnoughAllowanceToRegisterNode()";
            const SELECTOR: [u8; 4] = [15u8, 185u8, 189u8, 92u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `Deregistered(address,address)` and selector `0x159a8ae948fcc6e7f8b5495c0d73e91598440af8a62817246c09edc2c28dba8a`.
```solidity
event Deregistered(address indexed stakingAccount, address indexed nodeAddress);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Deregistered {
        #[allow(missing_docs)]
        pub stakingAccount: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub nodeAddress: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Deregistered {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "Deregistered(address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                21u8, 154u8, 138u8, 233u8, 72u8, 252u8, 198u8, 231u8, 248u8, 181u8, 73u8,
                92u8, 13u8, 115u8, 233u8, 21u8, 152u8, 68u8, 10u8, 248u8, 166u8, 40u8,
                23u8, 36u8, 108u8, 9u8, 237u8, 194u8, 194u8, 141u8, 186u8, 138u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    stakingAccount: topics.1,
                    nodeAddress: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.stakingAccount.clone(),
                    self.nodeAddress.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.stakingAccount,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.nodeAddress,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Deregistered {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Deregistered> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Deregistered) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `DeregisteredByManager(address,address)` and selector `0x91760a1001f531ec2bee8602be55ad2b1159465edff5bbcd41d20703742a4d42`.
```solidity
event DeregisteredByManager(address indexed stakingAccount, address indexed nodeAddress);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct DeregisteredByManager {
        #[allow(missing_docs)]
        pub stakingAccount: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub nodeAddress: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for DeregisteredByManager {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "DeregisteredByManager(address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                145u8, 118u8, 10u8, 16u8, 1u8, 245u8, 49u8, 236u8, 43u8, 238u8, 134u8,
                2u8, 190u8, 85u8, 173u8, 43u8, 17u8, 89u8, 70u8, 94u8, 223u8, 245u8,
                187u8, 205u8, 65u8, 210u8, 7u8, 3u8, 116u8, 42u8, 77u8, 66u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    stakingAccount: topics.1,
                    nodeAddress: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.stakingAccount.clone(),
                    self.nodeAddress.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.stakingAccount,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.nodeAddress,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for DeregisteredByManager {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&DeregisteredByManager> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &DeregisteredByManager) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `EligibilityUpdated(address,bool)` and selector `0xe2994f8d6f600ad473dba82c0a890ab7affacb860d3365f474baa3dc04a2e557`.
```solidity
event EligibilityUpdated(address indexed stakingAccount, bool indexed eligibility);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct EligibilityUpdated {
        #[allow(missing_docs)]
        pub stakingAccount: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub eligibility: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for EligibilityUpdated {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bool,
            );
            const SIGNATURE: &'static str = "EligibilityUpdated(address,bool)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                226u8, 153u8, 79u8, 141u8, 111u8, 96u8, 10u8, 212u8, 115u8, 219u8, 168u8,
                44u8, 10u8, 137u8, 10u8, 183u8, 175u8, 250u8, 203u8, 134u8, 13u8, 51u8,
                101u8, 244u8, 116u8, 186u8, 163u8, 220u8, 4u8, 162u8, 229u8, 87u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    stakingAccount: topics.1,
                    eligibility: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.stakingAccount.clone(),
                    self.eligibility.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.stakingAccount,
                );
                out[2usize] = <alloy::sol_types::sol_data::Bool as alloy_sol_types::EventTopic>::encode_topic(
                    &self.eligibility,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for EligibilityUpdated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&EligibilityUpdated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &EligibilityUpdated) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `NetworkRegistryStatusUpdated(bool)` and selector `0x8bc85f25e3e933978f099408b3bb3eb7630b76f7455f2e205bcbc0a780e17e72`.
```solidity
event NetworkRegistryStatusUpdated(bool indexed isEnabled);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct NetworkRegistryStatusUpdated {
        #[allow(missing_docs)]
        pub isEnabled: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for NetworkRegistryStatusUpdated {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Bool,
            );
            const SIGNATURE: &'static str = "NetworkRegistryStatusUpdated(bool)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                139u8, 200u8, 95u8, 37u8, 227u8, 233u8, 51u8, 151u8, 143u8, 9u8, 148u8,
                8u8, 179u8, 187u8, 62u8, 183u8, 99u8, 11u8, 118u8, 247u8, 69u8, 95u8,
                46u8, 32u8, 91u8, 203u8, 192u8, 167u8, 128u8, 225u8, 126u8, 114u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { isEnabled: topics.1 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.isEnabled.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Bool as alloy_sol_types::EventTopic>::encode_topic(
                    &self.isEnabled,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for NetworkRegistryStatusUpdated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&NetworkRegistryStatusUpdated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &NetworkRegistryStatusUpdated,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `Registered(address,address)` and selector `0x0a31ee9d46a828884b81003c8498156ea6aa15b9b54bdd0ef0b533d9eba57e55`.
```solidity
event Registered(address indexed stakingAccount, address indexed nodeAddress);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Registered {
        #[allow(missing_docs)]
        pub stakingAccount: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub nodeAddress: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Registered {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "Registered(address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                10u8, 49u8, 238u8, 157u8, 70u8, 168u8, 40u8, 136u8, 75u8, 129u8, 0u8,
                60u8, 132u8, 152u8, 21u8, 110u8, 166u8, 170u8, 21u8, 185u8, 181u8, 75u8,
                221u8, 14u8, 240u8, 181u8, 51u8, 217u8, 235u8, 165u8, 126u8, 85u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    stakingAccount: topics.1,
                    nodeAddress: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.stakingAccount.clone(),
                    self.nodeAddress.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.stakingAccount,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.nodeAddress,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Registered {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Registered> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Registered) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `RegisteredByManager(address,address)` and selector `0x04e1eaa4da18f7e742a4edbbe9ede36cdf75f793bb03ab2158c0877f1caf2b93`.
```solidity
event RegisteredByManager(address indexed stakingAccount, address indexed nodeAddress);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RegisteredByManager {
        #[allow(missing_docs)]
        pub stakingAccount: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub nodeAddress: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RegisteredByManager {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "RegisteredByManager(address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                4u8, 225u8, 234u8, 164u8, 218u8, 24u8, 247u8, 231u8, 66u8, 164u8, 237u8,
                187u8, 233u8, 237u8, 227u8, 108u8, 223u8, 117u8, 247u8, 147u8, 187u8,
                3u8, 171u8, 33u8, 88u8, 192u8, 135u8, 127u8, 28u8, 175u8, 43u8, 147u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    stakingAccount: topics.1,
                    nodeAddress: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.stakingAccount.clone(),
                    self.nodeAddress.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.stakingAccount,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.nodeAddress,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RegisteredByManager {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RegisteredByManager> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RegisteredByManager) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `RequirementUpdated(address)` and selector `0x8ac4b2eb7749f75c5b99b898e547fd615dd7a424e68356ea196b7dae742d6c32`.
```solidity
event RequirementUpdated(address indexed requirementImplementation);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RequirementUpdated {
        #[allow(missing_docs)]
        pub requirementImplementation: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RequirementUpdated {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "RequirementUpdated(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                138u8, 196u8, 178u8, 235u8, 119u8, 73u8, 247u8, 92u8, 91u8, 153u8, 184u8,
                152u8, 229u8, 71u8, 253u8, 97u8, 93u8, 215u8, 164u8, 36u8, 230u8, 131u8,
                86u8, 234u8, 25u8, 107u8, 125u8, 174u8, 116u8, 45u8, 108u8, 50u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    requirementImplementation: topics.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.requirementImplementation.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.requirementImplementation,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RequirementUpdated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RequirementUpdated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RequirementUpdated) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `RoleAdminChanged(bytes32,bytes32,bytes32)` and selector `0xbd79b86ffe0ab8e8776151514217cd7cacd52c909f66475c3af44e129f0b00ff`.
```solidity
event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RoleAdminChanged {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub previousAdminRole: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub newAdminRole: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RoleAdminChanged {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            const SIGNATURE: &'static str = "RoleAdminChanged(bytes32,bytes32,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                189u8, 121u8, 184u8, 111u8, 254u8, 10u8, 184u8, 232u8, 119u8, 97u8, 81u8,
                81u8, 66u8, 23u8, 205u8, 124u8, 172u8, 213u8, 44u8, 144u8, 159u8, 102u8,
                71u8, 92u8, 58u8, 244u8, 78u8, 18u8, 159u8, 11u8, 0u8, 255u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    role: topics.1,
                    previousAdminRole: topics.2,
                    newAdminRole: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.role.clone(),
                    self.previousAdminRole.clone(),
                    self.newAdminRole.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.role);
                out[2usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.previousAdminRole);
                out[3usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.newAdminRole);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RoleAdminChanged {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RoleAdminChanged> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RoleAdminChanged) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `RoleGranted(bytes32,address,address)` and selector `0x2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d`.
```solidity
event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RoleGranted {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub sender: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RoleGranted {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "RoleGranted(bytes32,address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                47u8, 135u8, 136u8, 17u8, 126u8, 126u8, 255u8, 29u8, 130u8, 233u8, 38u8,
                236u8, 121u8, 73u8, 1u8, 209u8, 124u8, 120u8, 2u8, 74u8, 80u8, 39u8, 9u8,
                64u8, 48u8, 69u8, 64u8, 167u8, 51u8, 101u8, 111u8, 13u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    role: topics.1,
                    account: topics.2,
                    sender: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.role.clone(),
                    self.account.clone(),
                    self.sender.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.role);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.account,
                );
                out[3usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.sender,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RoleGranted {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RoleGranted> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RoleGranted) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `RoleRevoked(bytes32,address,address)` and selector `0xf6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b`.
```solidity
event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RoleRevoked {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub sender: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RoleRevoked {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "RoleRevoked(bytes32,address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                246u8, 57u8, 31u8, 92u8, 50u8, 217u8, 198u8, 157u8, 42u8, 71u8, 234u8,
                103u8, 11u8, 68u8, 41u8, 116u8, 181u8, 57u8, 53u8, 209u8, 237u8, 199u8,
                253u8, 100u8, 235u8, 33u8, 224u8, 71u8, 168u8, 57u8, 23u8, 27u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    role: topics.1,
                    account: topics.2,
                    sender: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.role.clone(),
                    self.account.clone(),
                    self.sender.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.role);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.account,
                );
                out[3usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.sender,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RoleRevoked {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RoleRevoked> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RoleRevoked) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Constructor`.
```solidity
constructor(address _requirementImplementation, address _newOwner, address _manager);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct constructorCall {
        #[allow(missing_docs)]
        pub _requirementImplementation: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub _newOwner: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub _manager: alloy::sol_types::private::Address,
    }
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<constructorCall> for UnderlyingRustTuple<'_> {
                fn from(value: constructorCall) -> Self {
                    (value._requirementImplementation, value._newOwner, value._manager)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for constructorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _requirementImplementation: tuple.0,
                        _newOwner: tuple.1,
                        _manager: tuple.2,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolConstructor for constructorCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._requirementImplementation,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._newOwner,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._manager,
                    ),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `DEFAULT_ADMIN_ROLE()` and selector `0xa217fddf`.
```solidity
function DEFAULT_ADMIN_ROLE() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DEFAULT_ADMIN_ROLECall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`DEFAULT_ADMIN_ROLE()`](DEFAULT_ADMIN_ROLECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DEFAULT_ADMIN_ROLEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DEFAULT_ADMIN_ROLECall>
            for UnderlyingRustTuple<'_> {
                fn from(value: DEFAULT_ADMIN_ROLECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DEFAULT_ADMIN_ROLECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DEFAULT_ADMIN_ROLEReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: DEFAULT_ADMIN_ROLEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DEFAULT_ADMIN_ROLEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for DEFAULT_ADMIN_ROLECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "DEFAULT_ADMIN_ROLE()";
            const SELECTOR: [u8; 4] = [162u8, 23u8, 253u8, 223u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: DEFAULT_ADMIN_ROLEReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: DEFAULT_ADMIN_ROLEReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `MANAGER_ROLE()` and selector `0xec87621c`.
```solidity
function MANAGER_ROLE() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct MANAGER_ROLECall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`MANAGER_ROLE()`](MANAGER_ROLECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct MANAGER_ROLEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<MANAGER_ROLECall> for UnderlyingRustTuple<'_> {
                fn from(value: MANAGER_ROLECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for MANAGER_ROLECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<MANAGER_ROLEReturn> for UnderlyingRustTuple<'_> {
                fn from(value: MANAGER_ROLEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for MANAGER_ROLEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for MANAGER_ROLECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "MANAGER_ROLE()";
            const SELECTOR: [u8; 4] = [236u8, 135u8, 98u8, 28u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: MANAGER_ROLEReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: MANAGER_ROLEReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `countRegisterdNodesPerAccount(address)` and selector `0x3fa58457`.
```solidity
function countRegisterdNodesPerAccount(address) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct countRegisterdNodesPerAccountCall(pub alloy::sol_types::private::Address);
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`countRegisterdNodesPerAccount(address)`](countRegisterdNodesPerAccountCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct countRegisterdNodesPerAccountReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<countRegisterdNodesPerAccountCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: countRegisterdNodesPerAccountCall) -> Self {
                    (value.0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for countRegisterdNodesPerAccountCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self(tuple.0)
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<countRegisterdNodesPerAccountReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: countRegisterdNodesPerAccountReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for countRegisterdNodesPerAccountReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for countRegisterdNodesPerAccountCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "countRegisterdNodesPerAccount(address)";
            const SELECTOR: [u8; 4] = [63u8, 165u8, 132u8, 87u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.0,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: countRegisterdNodesPerAccountReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: countRegisterdNodesPerAccountReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `disableRegistry()` and selector `0xcbebafe0`.
```solidity
function disableRegistry() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct disableRegistryCall;
    ///Container type for the return parameters of the [`disableRegistry()`](disableRegistryCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct disableRegistryReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<disableRegistryCall> for UnderlyingRustTuple<'_> {
                fn from(value: disableRegistryCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for disableRegistryCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<disableRegistryReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: disableRegistryReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for disableRegistryReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl disableRegistryReturn {
            fn _tokenize(
                &self,
            ) -> <disableRegistryCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for disableRegistryCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = disableRegistryReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "disableRegistry()";
            const SELECTOR: [u8; 4] = [203u8, 235u8, 175u8, 224u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                disableRegistryReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `enableRegistry()` and selector `0xcfb3735f`.
```solidity
function enableRegistry() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct enableRegistryCall;
    ///Container type for the return parameters of the [`enableRegistry()`](enableRegistryCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct enableRegistryReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<enableRegistryCall> for UnderlyingRustTuple<'_> {
                fn from(value: enableRegistryCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for enableRegistryCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<enableRegistryReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: enableRegistryReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for enableRegistryReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl enableRegistryReturn {
            fn _tokenize(
                &self,
            ) -> <enableRegistryCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for enableRegistryCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = enableRegistryReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "enableRegistry()";
            const SELECTOR: [u8; 4] = [207u8, 179u8, 115u8, 95u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                enableRegistryReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `enabled()` and selector `0x238dafe0`.
```solidity
function enabled() external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct enabledCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`enabled()`](enabledCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct enabledReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<enabledCall> for UnderlyingRustTuple<'_> {
                fn from(value: enabledCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for enabledCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<enabledReturn> for UnderlyingRustTuple<'_> {
                fn from(value: enabledReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for enabledReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for enabledCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bool;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "enabled()";
            const SELECTOR: [u8; 4] = [35u8, 141u8, 175u8, 224u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: enabledReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: enabledReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getRoleAdmin(bytes32)` and selector `0x248a9ca3`.
```solidity
function getRoleAdmin(bytes32 role) external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRoleAdminCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getRoleAdmin(bytes32)`](getRoleAdminCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRoleAdminReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRoleAdminCall> for UnderlyingRustTuple<'_> {
                fn from(value: getRoleAdminCall) -> Self {
                    (value.role,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getRoleAdminCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { role: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRoleAdminReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getRoleAdminReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getRoleAdminReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getRoleAdminCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getRoleAdmin(bytes32)";
            const SELECTOR: [u8; 4] = [36u8, 138u8, 156u8, 163u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getRoleAdminReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getRoleAdminReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getRoleMember(bytes32,uint256)` and selector `0x9010d07c`.
```solidity
function getRoleMember(bytes32 role, uint256 index) external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRoleMemberCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub index: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getRoleMember(bytes32,uint256)`](getRoleMemberCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRoleMemberReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRoleMemberCall> for UnderlyingRustTuple<'_> {
                fn from(value: getRoleMemberCall) -> Self {
                    (value.role, value.index)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getRoleMemberCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        index: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRoleMemberReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getRoleMemberReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getRoleMemberReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getRoleMemberCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getRoleMember(bytes32,uint256)";
            const SELECTOR: [u8; 4] = [144u8, 16u8, 208u8, 124u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.index),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getRoleMemberReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getRoleMemberReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getRoleMemberCount(bytes32)` and selector `0xca15c873`.
```solidity
function getRoleMemberCount(bytes32 role) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRoleMemberCountCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getRoleMemberCount(bytes32)`](getRoleMemberCountCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRoleMemberCountReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRoleMemberCountCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getRoleMemberCountCall) -> Self {
                    (value.role,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getRoleMemberCountCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { role: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRoleMemberCountReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getRoleMemberCountReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getRoleMemberCountReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getRoleMemberCountCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getRoleMemberCount(bytes32)";
            const SELECTOR: [u8; 4] = [202u8, 21u8, 200u8, 115u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getRoleMemberCountReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getRoleMemberCountReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `grantRole(bytes32,address)` and selector `0x2f2ff15d`.
```solidity
function grantRole(bytes32 role, address account) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct grantRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`grantRole(bytes32,address)`](grantRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct grantRoleReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<grantRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: grantRoleCall) -> Self {
                    (value.role, value.account)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for grantRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        account: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<grantRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: grantRoleReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for grantRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl grantRoleReturn {
            fn _tokenize(
                &self,
            ) -> <grantRoleCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for grantRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = grantRoleReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "grantRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [47u8, 47u8, 241u8, 93u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                grantRoleReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `hasRole(bytes32,address)` and selector `0x91d14854`.
```solidity
function hasRole(bytes32 role, address account) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct hasRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`hasRole(bytes32,address)`](hasRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct hasRoleReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<hasRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: hasRoleCall) -> Self {
                    (value.role, value.account)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for hasRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        account: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<hasRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: hasRoleReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for hasRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for hasRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bool;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "hasRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [145u8, 209u8, 72u8, 84u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: hasRoleReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: hasRoleReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `isAccountEligible(address)` and selector `0x6ffbf988`.
```solidity
function isAccountEligible(address stakingAccount) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isAccountEligibleCall {
        #[allow(missing_docs)]
        pub stakingAccount: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`isAccountEligible(address)`](isAccountEligibleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isAccountEligibleReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isAccountEligibleCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: isAccountEligibleCall) -> Self {
                    (value.stakingAccount,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for isAccountEligibleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { stakingAccount: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isAccountEligibleReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: isAccountEligibleReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for isAccountEligibleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for isAccountEligibleCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bool;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "isAccountEligible(address)";
            const SELECTOR: [u8; 4] = [111u8, 251u8, 249u8, 136u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.stakingAccount,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: isAccountEligibleReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: isAccountEligibleReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `isNodeRegisteredAndEligible(address)` and selector `0x4eb1805c`.
```solidity
function isNodeRegisteredAndEligible(address nodeAddress) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isNodeRegisteredAndEligibleCall {
        #[allow(missing_docs)]
        pub nodeAddress: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`isNodeRegisteredAndEligible(address)`](isNodeRegisteredAndEligibleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isNodeRegisteredAndEligibleReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isNodeRegisteredAndEligibleCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: isNodeRegisteredAndEligibleCall) -> Self {
                    (value.nodeAddress,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for isNodeRegisteredAndEligibleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { nodeAddress: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isNodeRegisteredAndEligibleReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: isNodeRegisteredAndEligibleReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for isNodeRegisteredAndEligibleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for isNodeRegisteredAndEligibleCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bool;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "isNodeRegisteredAndEligible(address)";
            const SELECTOR: [u8; 4] = [78u8, 177u8, 128u8, 92u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.nodeAddress,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: isNodeRegisteredAndEligibleReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: isNodeRegisteredAndEligibleReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `isNodeRegisteredByAccount(address,address)` and selector `0xa5605da5`.
```solidity
function isNodeRegisteredByAccount(address nodeAddress, address account) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isNodeRegisteredByAccountCall {
        #[allow(missing_docs)]
        pub nodeAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`isNodeRegisteredByAccount(address,address)`](isNodeRegisteredByAccountCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isNodeRegisteredByAccountReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isNodeRegisteredByAccountCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: isNodeRegisteredByAccountCall) -> Self {
                    (value.nodeAddress, value.account)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for isNodeRegisteredByAccountCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        nodeAddress: tuple.0,
                        account: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isNodeRegisteredByAccountReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: isNodeRegisteredByAccountReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for isNodeRegisteredByAccountReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for isNodeRegisteredByAccountCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bool;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "isNodeRegisteredByAccount(address,address)";
            const SELECTOR: [u8; 4] = [165u8, 96u8, 93u8, 165u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.nodeAddress,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: isNodeRegisteredByAccountReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: isNodeRegisteredByAccountReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `managerDeregister(address[])` and selector `0x41b64965`.
```solidity
function managerDeregister(address[] memory nodeAddresses) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct managerDeregisterCall {
        #[allow(missing_docs)]
        pub nodeAddresses: alloy::sol_types::private::Vec<
            alloy::sol_types::private::Address,
        >,
    }
    ///Container type for the return parameters of the [`managerDeregister(address[])`](managerDeregisterCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct managerDeregisterReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<managerDeregisterCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: managerDeregisterCall) -> Self {
                    (value.nodeAddresses,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for managerDeregisterCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { nodeAddresses: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<managerDeregisterReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: managerDeregisterReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for managerDeregisterReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl managerDeregisterReturn {
            fn _tokenize(
                &self,
            ) -> <managerDeregisterCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for managerDeregisterCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = managerDeregisterReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "managerDeregister(address[])";
            const SELECTOR: [u8; 4] = [65u8, 182u8, 73u8, 101u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Address,
                    > as alloy_sol_types::SolType>::tokenize(&self.nodeAddresses),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                managerDeregisterReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `managerForceSync(address[],bool[])` and selector `0xcaf5f501`.
```solidity
function managerForceSync(address[] memory stakingAccounts, bool[] memory eligibilities) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct managerForceSyncCall {
        #[allow(missing_docs)]
        pub stakingAccounts: alloy::sol_types::private::Vec<
            alloy::sol_types::private::Address,
        >,
        #[allow(missing_docs)]
        pub eligibilities: alloy::sol_types::private::Vec<bool>,
    }
    ///Container type for the return parameters of the [`managerForceSync(address[],bool[])`](managerForceSyncCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct managerForceSyncReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bool>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
                alloy::sol_types::private::Vec<bool>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<managerForceSyncCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: managerForceSyncCall) -> Self {
                    (value.stakingAccounts, value.eligibilities)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for managerForceSyncCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        stakingAccounts: tuple.0,
                        eligibilities: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<managerForceSyncReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: managerForceSyncReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for managerForceSyncReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl managerForceSyncReturn {
            fn _tokenize(
                &self,
            ) -> <managerForceSyncCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for managerForceSyncCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bool>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = managerForceSyncReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "managerForceSync(address[],bool[])";
            const SELECTOR: [u8; 4] = [202u8, 245u8, 245u8, 1u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Address,
                    > as alloy_sol_types::SolType>::tokenize(&self.stakingAccounts),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Bool,
                    > as alloy_sol_types::SolType>::tokenize(&self.eligibilities),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                managerForceSyncReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `managerRegister(address[],address[])` and selector `0x8d753b2d`.
```solidity
function managerRegister(address[] memory stakingAccounts, address[] memory nodeAddresses) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct managerRegisterCall {
        #[allow(missing_docs)]
        pub stakingAccounts: alloy::sol_types::private::Vec<
            alloy::sol_types::private::Address,
        >,
        #[allow(missing_docs)]
        pub nodeAddresses: alloy::sol_types::private::Vec<
            alloy::sol_types::private::Address,
        >,
    }
    ///Container type for the return parameters of the [`managerRegister(address[],address[])`](managerRegisterCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct managerRegisterReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
                alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<managerRegisterCall> for UnderlyingRustTuple<'_> {
                fn from(value: managerRegisterCall) -> Self {
                    (value.stakingAccounts, value.nodeAddresses)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for managerRegisterCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        stakingAccounts: tuple.0,
                        nodeAddresses: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<managerRegisterReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: managerRegisterReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for managerRegisterReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl managerRegisterReturn {
            fn _tokenize(
                &self,
            ) -> <managerRegisterCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for managerRegisterCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = managerRegisterReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "managerRegister(address[],address[])";
            const SELECTOR: [u8; 4] = [141u8, 117u8, 59u8, 45u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Address,
                    > as alloy_sol_types::SolType>::tokenize(&self.stakingAccounts),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Address,
                    > as alloy_sol_types::SolType>::tokenize(&self.nodeAddresses),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                managerRegisterReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `managerSync(address[])` and selector `0x2c33cafb`.
```solidity
function managerSync(address[] memory stakingAccounts) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct managerSyncCall {
        #[allow(missing_docs)]
        pub stakingAccounts: alloy::sol_types::private::Vec<
            alloy::sol_types::private::Address,
        >,
    }
    ///Container type for the return parameters of the [`managerSync(address[])`](managerSyncCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct managerSyncReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<managerSyncCall> for UnderlyingRustTuple<'_> {
                fn from(value: managerSyncCall) -> Self {
                    (value.stakingAccounts,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for managerSyncCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { stakingAccounts: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<managerSyncReturn> for UnderlyingRustTuple<'_> {
                fn from(value: managerSyncReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for managerSyncReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl managerSyncReturn {
            fn _tokenize(
                &self,
            ) -> <managerSyncCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for managerSyncCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = managerSyncReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "managerSync(address[])";
            const SELECTOR: [u8; 4] = [44u8, 51u8, 202u8, 251u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Address,
                    > as alloy_sol_types::SolType>::tokenize(&self.stakingAccounts),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                managerSyncReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `maxAdditionalRegistrations(address)` and selector `0x2a2deee2`.
```solidity
function maxAdditionalRegistrations(address stakingAccount) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct maxAdditionalRegistrationsCall {
        #[allow(missing_docs)]
        pub stakingAccount: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`maxAdditionalRegistrations(address)`](maxAdditionalRegistrationsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct maxAdditionalRegistrationsReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<maxAdditionalRegistrationsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: maxAdditionalRegistrationsCall) -> Self {
                    (value.stakingAccount,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for maxAdditionalRegistrationsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { stakingAccount: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<maxAdditionalRegistrationsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: maxAdditionalRegistrationsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for maxAdditionalRegistrationsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for maxAdditionalRegistrationsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "maxAdditionalRegistrations(address)";
            const SELECTOR: [u8; 4] = [42u8, 45u8, 238u8, 226u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.stakingAccount,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: maxAdditionalRegistrationsReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: maxAdditionalRegistrationsReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `nodeRegisterdToAccount(address)` and selector `0xc7ecab8f`.
```solidity
function nodeRegisterdToAccount(address) external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct nodeRegisterdToAccountCall(pub alloy::sol_types::private::Address);
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`nodeRegisterdToAccount(address)`](nodeRegisterdToAccountCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct nodeRegisterdToAccountReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<nodeRegisterdToAccountCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: nodeRegisterdToAccountCall) -> Self {
                    (value.0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for nodeRegisterdToAccountCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self(tuple.0)
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<nodeRegisterdToAccountReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: nodeRegisterdToAccountReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for nodeRegisterdToAccountReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for nodeRegisterdToAccountCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "nodeRegisterdToAccount(address)";
            const SELECTOR: [u8; 4] = [199u8, 236u8, 171u8, 143u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.0,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: nodeRegisterdToAccountReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: nodeRegisterdToAccountReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `renounceRole(bytes32,address)` and selector `0x36568abe`.
```solidity
function renounceRole(bytes32 role, address account) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`renounceRole(bytes32,address)`](renounceRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceRoleReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: renounceRoleCall) -> Self {
                    (value.role, value.account)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for renounceRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        account: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: renounceRoleReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for renounceRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl renounceRoleReturn {
            fn _tokenize(
                &self,
            ) -> <renounceRoleCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for renounceRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = renounceRoleReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "renounceRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [54u8, 86u8, 138u8, 190u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                renounceRoleReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `requirementImplementation()` and selector `0xe3d2a071`.
```solidity
function requirementImplementation() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct requirementImplementationCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`requirementImplementation()`](requirementImplementationCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct requirementImplementationReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<requirementImplementationCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: requirementImplementationCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for requirementImplementationCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<requirementImplementationReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: requirementImplementationReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for requirementImplementationReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for requirementImplementationCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "requirementImplementation()";
            const SELECTOR: [u8; 4] = [227u8, 210u8, 160u8, 113u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: requirementImplementationReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: requirementImplementationReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `revokeRole(bytes32,address)` and selector `0xd547741f`.
```solidity
function revokeRole(bytes32 role, address account) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct revokeRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`revokeRole(bytes32,address)`](revokeRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct revokeRoleReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<revokeRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: revokeRoleCall) -> Self {
                    (value.role, value.account)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for revokeRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        account: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<revokeRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: revokeRoleReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for revokeRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl revokeRoleReturn {
            fn _tokenize(
                &self,
            ) -> <revokeRoleCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for revokeRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = revokeRoleReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "revokeRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [213u8, 71u8, 116u8, 31u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                revokeRoleReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `selfDeregister(address[])` and selector `0xa05e0f6d`.
```solidity
function selfDeregister(address[] memory nodeAddresses) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct selfDeregisterCall {
        #[allow(missing_docs)]
        pub nodeAddresses: alloy::sol_types::private::Vec<
            alloy::sol_types::private::Address,
        >,
    }
    ///Container type for the return parameters of the [`selfDeregister(address[])`](selfDeregisterCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct selfDeregisterReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<selfDeregisterCall> for UnderlyingRustTuple<'_> {
                fn from(value: selfDeregisterCall) -> Self {
                    (value.nodeAddresses,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for selfDeregisterCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { nodeAddresses: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<selfDeregisterReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: selfDeregisterReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for selfDeregisterReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl selfDeregisterReturn {
            fn _tokenize(
                &self,
            ) -> <selfDeregisterCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for selfDeregisterCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = selfDeregisterReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "selfDeregister(address[])";
            const SELECTOR: [u8; 4] = [160u8, 94u8, 15u8, 109u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Address,
                    > as alloy_sol_types::SolType>::tokenize(&self.nodeAddresses),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                selfDeregisterReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `selfRegister(address[])` and selector `0x76593a39`.
```solidity
function selfRegister(address[] memory nodeAddresses) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct selfRegisterCall {
        #[allow(missing_docs)]
        pub nodeAddresses: alloy::sol_types::private::Vec<
            alloy::sol_types::private::Address,
        >,
    }
    ///Container type for the return parameters of the [`selfRegister(address[])`](selfRegisterCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct selfRegisterReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<selfRegisterCall> for UnderlyingRustTuple<'_> {
                fn from(value: selfRegisterCall) -> Self {
                    (value.nodeAddresses,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for selfRegisterCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { nodeAddresses: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<selfRegisterReturn> for UnderlyingRustTuple<'_> {
                fn from(value: selfRegisterReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for selfRegisterReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl selfRegisterReturn {
            fn _tokenize(
                &self,
            ) -> <selfRegisterCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for selfRegisterCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = selfRegisterReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "selfRegister(address[])";
            const SELECTOR: [u8; 4] = [118u8, 89u8, 58u8, 57u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Address,
                    > as alloy_sol_types::SolType>::tokenize(&self.nodeAddresses),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                selfRegisterReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `selfSync()` and selector `0x9c7f643b`.
```solidity
function selfSync() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct selfSyncCall;
    ///Container type for the return parameters of the [`selfSync()`](selfSyncCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct selfSyncReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<selfSyncCall> for UnderlyingRustTuple<'_> {
                fn from(value: selfSyncCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for selfSyncCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<selfSyncReturn> for UnderlyingRustTuple<'_> {
                fn from(value: selfSyncReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for selfSyncReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl selfSyncReturn {
            fn _tokenize(
                &self,
            ) -> <selfSyncCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for selfSyncCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = selfSyncReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "selfSync()";
            const SELECTOR: [u8; 4] = [156u8, 127u8, 100u8, 59u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                selfSyncReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `supportsInterface(bytes4)` and selector `0x01ffc9a7`.
```solidity
function supportsInterface(bytes4 interfaceId) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct supportsInterfaceCall {
        #[allow(missing_docs)]
        pub interfaceId: alloy::sol_types::private::FixedBytes<4>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`supportsInterface(bytes4)`](supportsInterfaceCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct supportsInterfaceReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<4>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<4>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<supportsInterfaceCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: supportsInterfaceCall) -> Self {
                    (value.interfaceId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for supportsInterfaceCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { interfaceId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<supportsInterfaceReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: supportsInterfaceReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for supportsInterfaceReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for supportsInterfaceCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<4>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bool;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "supportsInterface(bytes4)";
            const SELECTOR: [u8; 4] = [1u8, 255u8, 201u8, 167u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        4,
                    > as alloy_sol_types::SolType>::tokenize(&self.interfaceId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: supportsInterfaceReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: supportsInterfaceReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `updateRequirementImplementation(address)` and selector `0x27b040a1`.
```solidity
function updateRequirementImplementation(address _requirementImplementation) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct updateRequirementImplementationCall {
        #[allow(missing_docs)]
        pub _requirementImplementation: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`updateRequirementImplementation(address)`](updateRequirementImplementationCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct updateRequirementImplementationReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateRequirementImplementationCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: updateRequirementImplementationCall) -> Self {
                    (value._requirementImplementation,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for updateRequirementImplementationCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _requirementImplementation: tuple.0,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateRequirementImplementationReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: updateRequirementImplementationReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for updateRequirementImplementationReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl updateRequirementImplementationReturn {
            fn _tokenize(
                &self,
            ) -> <updateRequirementImplementationCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for updateRequirementImplementationCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = updateRequirementImplementationReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "updateRequirementImplementation(address)";
            const SELECTOR: [u8; 4] = [39u8, 176u8, 64u8, 161u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._requirementImplementation,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                updateRequirementImplementationReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`HoprNetworkRegistry`](self) function calls.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive()]
    pub enum HoprNetworkRegistryCalls {
        #[allow(missing_docs)]
        DEFAULT_ADMIN_ROLE(DEFAULT_ADMIN_ROLECall),
        #[allow(missing_docs)]
        MANAGER_ROLE(MANAGER_ROLECall),
        #[allow(missing_docs)]
        countRegisterdNodesPerAccount(countRegisterdNodesPerAccountCall),
        #[allow(missing_docs)]
        disableRegistry(disableRegistryCall),
        #[allow(missing_docs)]
        enableRegistry(enableRegistryCall),
        #[allow(missing_docs)]
        enabled(enabledCall),
        #[allow(missing_docs)]
        getRoleAdmin(getRoleAdminCall),
        #[allow(missing_docs)]
        getRoleMember(getRoleMemberCall),
        #[allow(missing_docs)]
        getRoleMemberCount(getRoleMemberCountCall),
        #[allow(missing_docs)]
        grantRole(grantRoleCall),
        #[allow(missing_docs)]
        hasRole(hasRoleCall),
        #[allow(missing_docs)]
        isAccountEligible(isAccountEligibleCall),
        #[allow(missing_docs)]
        isNodeRegisteredAndEligible(isNodeRegisteredAndEligibleCall),
        #[allow(missing_docs)]
        isNodeRegisteredByAccount(isNodeRegisteredByAccountCall),
        #[allow(missing_docs)]
        managerDeregister(managerDeregisterCall),
        #[allow(missing_docs)]
        managerForceSync(managerForceSyncCall),
        #[allow(missing_docs)]
        managerRegister(managerRegisterCall),
        #[allow(missing_docs)]
        managerSync(managerSyncCall),
        #[allow(missing_docs)]
        maxAdditionalRegistrations(maxAdditionalRegistrationsCall),
        #[allow(missing_docs)]
        nodeRegisterdToAccount(nodeRegisterdToAccountCall),
        #[allow(missing_docs)]
        renounceRole(renounceRoleCall),
        #[allow(missing_docs)]
        requirementImplementation(requirementImplementationCall),
        #[allow(missing_docs)]
        revokeRole(revokeRoleCall),
        #[allow(missing_docs)]
        selfDeregister(selfDeregisterCall),
        #[allow(missing_docs)]
        selfRegister(selfRegisterCall),
        #[allow(missing_docs)]
        selfSync(selfSyncCall),
        #[allow(missing_docs)]
        supportsInterface(supportsInterfaceCall),
        #[allow(missing_docs)]
        updateRequirementImplementation(updateRequirementImplementationCall),
    }
    #[automatically_derived]
    impl HoprNetworkRegistryCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [1u8, 255u8, 201u8, 167u8],
            [35u8, 141u8, 175u8, 224u8],
            [36u8, 138u8, 156u8, 163u8],
            [39u8, 176u8, 64u8, 161u8],
            [42u8, 45u8, 238u8, 226u8],
            [44u8, 51u8, 202u8, 251u8],
            [47u8, 47u8, 241u8, 93u8],
            [54u8, 86u8, 138u8, 190u8],
            [63u8, 165u8, 132u8, 87u8],
            [65u8, 182u8, 73u8, 101u8],
            [78u8, 177u8, 128u8, 92u8],
            [111u8, 251u8, 249u8, 136u8],
            [118u8, 89u8, 58u8, 57u8],
            [141u8, 117u8, 59u8, 45u8],
            [144u8, 16u8, 208u8, 124u8],
            [145u8, 209u8, 72u8, 84u8],
            [156u8, 127u8, 100u8, 59u8],
            [160u8, 94u8, 15u8, 109u8],
            [162u8, 23u8, 253u8, 223u8],
            [165u8, 96u8, 93u8, 165u8],
            [199u8, 236u8, 171u8, 143u8],
            [202u8, 21u8, 200u8, 115u8],
            [202u8, 245u8, 245u8, 1u8],
            [203u8, 235u8, 175u8, 224u8],
            [207u8, 179u8, 115u8, 95u8],
            [213u8, 71u8, 116u8, 31u8],
            [227u8, 210u8, 160u8, 113u8],
            [236u8, 135u8, 98u8, 28u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for HoprNetworkRegistryCalls {
        const NAME: &'static str = "HoprNetworkRegistryCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 28usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::DEFAULT_ADMIN_ROLE(_) => {
                    <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::MANAGER_ROLE(_) => {
                    <MANAGER_ROLECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::countRegisterdNodesPerAccount(_) => {
                    <countRegisterdNodesPerAccountCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::disableRegistry(_) => {
                    <disableRegistryCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::enableRegistry(_) => {
                    <enableRegistryCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::enabled(_) => <enabledCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::getRoleAdmin(_) => {
                    <getRoleAdminCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getRoleMember(_) => {
                    <getRoleMemberCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getRoleMemberCount(_) => {
                    <getRoleMemberCountCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::grantRole(_) => {
                    <grantRoleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::hasRole(_) => <hasRoleCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::isAccountEligible(_) => {
                    <isAccountEligibleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::isNodeRegisteredAndEligible(_) => {
                    <isNodeRegisteredAndEligibleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::isNodeRegisteredByAccount(_) => {
                    <isNodeRegisteredByAccountCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::managerDeregister(_) => {
                    <managerDeregisterCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::managerForceSync(_) => {
                    <managerForceSyncCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::managerRegister(_) => {
                    <managerRegisterCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::managerSync(_) => {
                    <managerSyncCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::maxAdditionalRegistrations(_) => {
                    <maxAdditionalRegistrationsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::nodeRegisterdToAccount(_) => {
                    <nodeRegisterdToAccountCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::renounceRole(_) => {
                    <renounceRoleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::requirementImplementation(_) => {
                    <requirementImplementationCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::revokeRole(_) => {
                    <revokeRoleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::selfDeregister(_) => {
                    <selfDeregisterCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::selfRegister(_) => {
                    <selfRegisterCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::selfSync(_) => <selfSyncCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::supportsInterface(_) => {
                    <supportsInterfaceCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::updateRequirementImplementation(_) => {
                    <updateRequirementImplementationCall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls>] = &[
                {
                    fn supportsInterface(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::supportsInterface)
                    }
                    supportsInterface
                },
                {
                    fn enabled(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <enabledCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(HoprNetworkRegistryCalls::enabled)
                    }
                    enabled
                },
                {
                    fn getRoleAdmin(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <getRoleAdminCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::getRoleAdmin)
                    }
                    getRoleAdmin
                },
                {
                    fn updateRequirementImplementation(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <updateRequirementImplementationCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(
                                HoprNetworkRegistryCalls::updateRequirementImplementation,
                            )
                    }
                    updateRequirementImplementation
                },
                {
                    fn maxAdditionalRegistrations(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <maxAdditionalRegistrationsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::maxAdditionalRegistrations)
                    }
                    maxAdditionalRegistrations
                },
                {
                    fn managerSync(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <managerSyncCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::managerSync)
                    }
                    managerSync
                },
                {
                    fn grantRole(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <grantRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(HoprNetworkRegistryCalls::grantRole)
                    }
                    grantRole
                },
                {
                    fn renounceRole(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <renounceRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::renounceRole)
                    }
                    renounceRole
                },
                {
                    fn countRegisterdNodesPerAccount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <countRegisterdNodesPerAccountCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::countRegisterdNodesPerAccount)
                    }
                    countRegisterdNodesPerAccount
                },
                {
                    fn managerDeregister(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <managerDeregisterCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::managerDeregister)
                    }
                    managerDeregister
                },
                {
                    fn isNodeRegisteredAndEligible(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <isNodeRegisteredAndEligibleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::isNodeRegisteredAndEligible)
                    }
                    isNodeRegisteredAndEligible
                },
                {
                    fn isAccountEligible(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <isAccountEligibleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::isAccountEligible)
                    }
                    isAccountEligible
                },
                {
                    fn selfRegister(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <selfRegisterCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::selfRegister)
                    }
                    selfRegister
                },
                {
                    fn managerRegister(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <managerRegisterCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::managerRegister)
                    }
                    managerRegister
                },
                {
                    fn getRoleMember(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <getRoleMemberCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::getRoleMember)
                    }
                    getRoleMember
                },
                {
                    fn hasRole(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <hasRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(HoprNetworkRegistryCalls::hasRole)
                    }
                    hasRole
                },
                {
                    fn selfSync(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <selfSyncCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(HoprNetworkRegistryCalls::selfSync)
                    }
                    selfSync
                },
                {
                    fn selfDeregister(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <selfDeregisterCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::selfDeregister)
                    }
                    selfDeregister
                },
                {
                    fn DEFAULT_ADMIN_ROLE(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::DEFAULT_ADMIN_ROLE)
                    }
                    DEFAULT_ADMIN_ROLE
                },
                {
                    fn isNodeRegisteredByAccount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <isNodeRegisteredByAccountCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::isNodeRegisteredByAccount)
                    }
                    isNodeRegisteredByAccount
                },
                {
                    fn nodeRegisterdToAccount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <nodeRegisterdToAccountCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::nodeRegisterdToAccount)
                    }
                    nodeRegisterdToAccount
                },
                {
                    fn getRoleMemberCount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <getRoleMemberCountCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::getRoleMemberCount)
                    }
                    getRoleMemberCount
                },
                {
                    fn managerForceSync(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <managerForceSyncCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::managerForceSync)
                    }
                    managerForceSync
                },
                {
                    fn disableRegistry(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <disableRegistryCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::disableRegistry)
                    }
                    disableRegistry
                },
                {
                    fn enableRegistry(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <enableRegistryCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::enableRegistry)
                    }
                    enableRegistry
                },
                {
                    fn revokeRole(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <revokeRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::revokeRole)
                    }
                    revokeRole
                },
                {
                    fn requirementImplementation(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <requirementImplementationCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::requirementImplementation)
                    }
                    requirementImplementation
                },
                {
                    fn MANAGER_ROLE(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <MANAGER_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::MANAGER_ROLE)
                    }
                    MANAGER_ROLE
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data)
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw_validate(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_VALIDATE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls>] = &[
                {
                    fn supportsInterface(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::supportsInterface)
                    }
                    supportsInterface
                },
                {
                    fn enabled(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <enabledCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::enabled)
                    }
                    enabled
                },
                {
                    fn getRoleAdmin(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <getRoleAdminCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::getRoleAdmin)
                    }
                    getRoleAdmin
                },
                {
                    fn updateRequirementImplementation(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <updateRequirementImplementationCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                HoprNetworkRegistryCalls::updateRequirementImplementation,
                            )
                    }
                    updateRequirementImplementation
                },
                {
                    fn maxAdditionalRegistrations(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <maxAdditionalRegistrationsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::maxAdditionalRegistrations)
                    }
                    maxAdditionalRegistrations
                },
                {
                    fn managerSync(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <managerSyncCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::managerSync)
                    }
                    managerSync
                },
                {
                    fn grantRole(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <grantRoleCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::grantRole)
                    }
                    grantRole
                },
                {
                    fn renounceRole(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <renounceRoleCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::renounceRole)
                    }
                    renounceRole
                },
                {
                    fn countRegisterdNodesPerAccount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <countRegisterdNodesPerAccountCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::countRegisterdNodesPerAccount)
                    }
                    countRegisterdNodesPerAccount
                },
                {
                    fn managerDeregister(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <managerDeregisterCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::managerDeregister)
                    }
                    managerDeregister
                },
                {
                    fn isNodeRegisteredAndEligible(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <isNodeRegisteredAndEligibleCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::isNodeRegisteredAndEligible)
                    }
                    isNodeRegisteredAndEligible
                },
                {
                    fn isAccountEligible(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <isAccountEligibleCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::isAccountEligible)
                    }
                    isAccountEligible
                },
                {
                    fn selfRegister(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <selfRegisterCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::selfRegister)
                    }
                    selfRegister
                },
                {
                    fn managerRegister(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <managerRegisterCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::managerRegister)
                    }
                    managerRegister
                },
                {
                    fn getRoleMember(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <getRoleMemberCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::getRoleMember)
                    }
                    getRoleMember
                },
                {
                    fn hasRole(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <hasRoleCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::hasRole)
                    }
                    hasRole
                },
                {
                    fn selfSync(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <selfSyncCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::selfSync)
                    }
                    selfSync
                },
                {
                    fn selfDeregister(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <selfDeregisterCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::selfDeregister)
                    }
                    selfDeregister
                },
                {
                    fn DEFAULT_ADMIN_ROLE(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::DEFAULT_ADMIN_ROLE)
                    }
                    DEFAULT_ADMIN_ROLE
                },
                {
                    fn isNodeRegisteredByAccount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <isNodeRegisteredByAccountCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::isNodeRegisteredByAccount)
                    }
                    isNodeRegisteredByAccount
                },
                {
                    fn nodeRegisterdToAccount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <nodeRegisterdToAccountCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::nodeRegisterdToAccount)
                    }
                    nodeRegisterdToAccount
                },
                {
                    fn getRoleMemberCount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <getRoleMemberCountCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::getRoleMemberCount)
                    }
                    getRoleMemberCount
                },
                {
                    fn managerForceSync(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <managerForceSyncCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::managerForceSync)
                    }
                    managerForceSync
                },
                {
                    fn disableRegistry(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <disableRegistryCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::disableRegistry)
                    }
                    disableRegistry
                },
                {
                    fn enableRegistry(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <enableRegistryCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::enableRegistry)
                    }
                    enableRegistry
                },
                {
                    fn revokeRole(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <revokeRoleCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::revokeRole)
                    }
                    revokeRole
                },
                {
                    fn requirementImplementation(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <requirementImplementationCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::requirementImplementation)
                    }
                    requirementImplementation
                },
                {
                    fn MANAGER_ROLE(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryCalls> {
                        <MANAGER_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNetworkRegistryCalls::MANAGER_ROLE)
                    }
                    MANAGER_ROLE
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_VALIDATE_SHIMS[idx](data)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::DEFAULT_ADMIN_ROLE(inner) => {
                    <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::MANAGER_ROLE(inner) => {
                    <MANAGER_ROLECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::countRegisterdNodesPerAccount(inner) => {
                    <countRegisterdNodesPerAccountCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::disableRegistry(inner) => {
                    <disableRegistryCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::enableRegistry(inner) => {
                    <enableRegistryCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::enabled(inner) => {
                    <enabledCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::getRoleAdmin(inner) => {
                    <getRoleAdminCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getRoleMember(inner) => {
                    <getRoleMemberCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getRoleMemberCount(inner) => {
                    <getRoleMemberCountCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::grantRole(inner) => {
                    <grantRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::hasRole(inner) => {
                    <hasRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::isAccountEligible(inner) => {
                    <isAccountEligibleCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::isNodeRegisteredAndEligible(inner) => {
                    <isNodeRegisteredAndEligibleCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::isNodeRegisteredByAccount(inner) => {
                    <isNodeRegisteredByAccountCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::managerDeregister(inner) => {
                    <managerDeregisterCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::managerForceSync(inner) => {
                    <managerForceSyncCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::managerRegister(inner) => {
                    <managerRegisterCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::managerSync(inner) => {
                    <managerSyncCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::maxAdditionalRegistrations(inner) => {
                    <maxAdditionalRegistrationsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::nodeRegisterdToAccount(inner) => {
                    <nodeRegisterdToAccountCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::renounceRole(inner) => {
                    <renounceRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::requirementImplementation(inner) => {
                    <requirementImplementationCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::revokeRole(inner) => {
                    <revokeRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::selfDeregister(inner) => {
                    <selfDeregisterCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::selfRegister(inner) => {
                    <selfRegisterCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::selfSync(inner) => {
                    <selfSyncCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::supportsInterface(inner) => {
                    <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::updateRequirementImplementation(inner) => {
                    <updateRequirementImplementationCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::DEFAULT_ADMIN_ROLE(inner) => {
                    <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::MANAGER_ROLE(inner) => {
                    <MANAGER_ROLECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::countRegisterdNodesPerAccount(inner) => {
                    <countRegisterdNodesPerAccountCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::disableRegistry(inner) => {
                    <disableRegistryCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::enableRegistry(inner) => {
                    <enableRegistryCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::enabled(inner) => {
                    <enabledCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::getRoleAdmin(inner) => {
                    <getRoleAdminCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getRoleMember(inner) => {
                    <getRoleMemberCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getRoleMemberCount(inner) => {
                    <getRoleMemberCountCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::grantRole(inner) => {
                    <grantRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::hasRole(inner) => {
                    <hasRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::isAccountEligible(inner) => {
                    <isAccountEligibleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::isNodeRegisteredAndEligible(inner) => {
                    <isNodeRegisteredAndEligibleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::isNodeRegisteredByAccount(inner) => {
                    <isNodeRegisteredByAccountCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::managerDeregister(inner) => {
                    <managerDeregisterCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::managerForceSync(inner) => {
                    <managerForceSyncCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::managerRegister(inner) => {
                    <managerRegisterCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::managerSync(inner) => {
                    <managerSyncCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::maxAdditionalRegistrations(inner) => {
                    <maxAdditionalRegistrationsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::nodeRegisterdToAccount(inner) => {
                    <nodeRegisterdToAccountCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::renounceRole(inner) => {
                    <renounceRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::requirementImplementation(inner) => {
                    <requirementImplementationCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::revokeRole(inner) => {
                    <revokeRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::selfDeregister(inner) => {
                    <selfDeregisterCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::selfRegister(inner) => {
                    <selfRegisterCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::selfSync(inner) => {
                    <selfSyncCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::supportsInterface(inner) => {
                    <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::updateRequirementImplementation(inner) => {
                    <updateRequirementImplementationCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`HoprNetworkRegistry`](self) custom errors.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub enum HoprNetworkRegistryErrors {
        #[allow(missing_docs)]
        ArrayLengthNotMatch(ArrayLengthNotMatch),
        #[allow(missing_docs)]
        CannotOperateForNode(CannotOperateForNode),
        #[allow(missing_docs)]
        GloballyDisabledRegistry(GloballyDisabledRegistry),
        #[allow(missing_docs)]
        GloballyEnabledRegistry(GloballyEnabledRegistry),
        #[allow(missing_docs)]
        NodeAlreadyRegisterd(NodeAlreadyRegisterd),
        #[allow(missing_docs)]
        NodeNotYetRegisterd(NodeNotYetRegisterd),
        #[allow(missing_docs)]
        NodeRegisterdToOtherAccount(NodeRegisterdToOtherAccount),
        #[allow(missing_docs)]
        NotEnoughAllowanceToRegisterNode(NotEnoughAllowanceToRegisterNode),
    }
    #[automatically_derived]
    impl HoprNetworkRegistryErrors {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [7u8, 65u8, 73u8, 103u8],
            [15u8, 185u8, 189u8, 92u8],
            [91u8, 83u8, 59u8, 161u8],
            [177u8, 195u8, 200u8, 168u8],
            [191u8, 79u8, 221u8, 115u8],
            [196u8, 38u8, 56u8, 187u8],
            [237u8, 26u8, 12u8, 119u8],
            [237u8, 136u8, 47u8, 113u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for HoprNetworkRegistryErrors {
        const NAME: &'static str = "HoprNetworkRegistryErrors";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 8usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::ArrayLengthNotMatch(_) => {
                    <ArrayLengthNotMatch as alloy_sol_types::SolError>::SELECTOR
                }
                Self::CannotOperateForNode(_) => {
                    <CannotOperateForNode as alloy_sol_types::SolError>::SELECTOR
                }
                Self::GloballyDisabledRegistry(_) => {
                    <GloballyDisabledRegistry as alloy_sol_types::SolError>::SELECTOR
                }
                Self::GloballyEnabledRegistry(_) => {
                    <GloballyEnabledRegistry as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NodeAlreadyRegisterd(_) => {
                    <NodeAlreadyRegisterd as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NodeNotYetRegisterd(_) => {
                    <NodeNotYetRegisterd as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NodeRegisterdToOtherAccount(_) => {
                    <NodeRegisterdToOtherAccount as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotEnoughAllowanceToRegisterNode(_) => {
                    <NotEnoughAllowanceToRegisterNode as alloy_sol_types::SolError>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<HoprNetworkRegistryErrors>] = &[
                {
                    fn CannotOperateForNode(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryErrors> {
                        <CannotOperateForNode as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNetworkRegistryErrors::CannotOperateForNode)
                    }
                    CannotOperateForNode
                },
                {
                    fn NotEnoughAllowanceToRegisterNode(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryErrors> {
                        <NotEnoughAllowanceToRegisterNode as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(
                                HoprNetworkRegistryErrors::NotEnoughAllowanceToRegisterNode,
                            )
                    }
                    NotEnoughAllowanceToRegisterNode
                },
                {
                    fn NodeAlreadyRegisterd(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryErrors> {
                        <NodeAlreadyRegisterd as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNetworkRegistryErrors::NodeAlreadyRegisterd)
                    }
                    NodeAlreadyRegisterd
                },
                {
                    fn NodeNotYetRegisterd(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryErrors> {
                        <NodeNotYetRegisterd as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNetworkRegistryErrors::NodeNotYetRegisterd)
                    }
                    NodeNotYetRegisterd
                },
                {
                    fn NodeRegisterdToOtherAccount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryErrors> {
                        <NodeRegisterdToOtherAccount as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNetworkRegistryErrors::NodeRegisterdToOtherAccount)
                    }
                    NodeRegisterdToOtherAccount
                },
                {
                    fn GloballyDisabledRegistry(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryErrors> {
                        <GloballyDisabledRegistry as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNetworkRegistryErrors::GloballyDisabledRegistry)
                    }
                    GloballyDisabledRegistry
                },
                {
                    fn GloballyEnabledRegistry(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryErrors> {
                        <GloballyEnabledRegistry as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNetworkRegistryErrors::GloballyEnabledRegistry)
                    }
                    GloballyEnabledRegistry
                },
                {
                    fn ArrayLengthNotMatch(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryErrors> {
                        <ArrayLengthNotMatch as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(HoprNetworkRegistryErrors::ArrayLengthNotMatch)
                    }
                    ArrayLengthNotMatch
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data)
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw_validate(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_VALIDATE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<HoprNetworkRegistryErrors>] = &[
                {
                    fn CannotOperateForNode(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryErrors> {
                        <CannotOperateForNode as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNetworkRegistryErrors::CannotOperateForNode)
                    }
                    CannotOperateForNode
                },
                {
                    fn NotEnoughAllowanceToRegisterNode(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryErrors> {
                        <NotEnoughAllowanceToRegisterNode as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                HoprNetworkRegistryErrors::NotEnoughAllowanceToRegisterNode,
                            )
                    }
                    NotEnoughAllowanceToRegisterNode
                },
                {
                    fn NodeAlreadyRegisterd(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryErrors> {
                        <NodeAlreadyRegisterd as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNetworkRegistryErrors::NodeAlreadyRegisterd)
                    }
                    NodeAlreadyRegisterd
                },
                {
                    fn NodeNotYetRegisterd(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryErrors> {
                        <NodeNotYetRegisterd as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNetworkRegistryErrors::NodeNotYetRegisterd)
                    }
                    NodeNotYetRegisterd
                },
                {
                    fn NodeRegisterdToOtherAccount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryErrors> {
                        <NodeRegisterdToOtherAccount as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNetworkRegistryErrors::NodeRegisterdToOtherAccount)
                    }
                    NodeRegisterdToOtherAccount
                },
                {
                    fn GloballyDisabledRegistry(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryErrors> {
                        <GloballyDisabledRegistry as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNetworkRegistryErrors::GloballyDisabledRegistry)
                    }
                    GloballyDisabledRegistry
                },
                {
                    fn GloballyEnabledRegistry(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryErrors> {
                        <GloballyEnabledRegistry as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNetworkRegistryErrors::GloballyEnabledRegistry)
                    }
                    GloballyEnabledRegistry
                },
                {
                    fn ArrayLengthNotMatch(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprNetworkRegistryErrors> {
                        <ArrayLengthNotMatch as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprNetworkRegistryErrors::ArrayLengthNotMatch)
                    }
                    ArrayLengthNotMatch
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_VALIDATE_SHIMS[idx](data)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::ArrayLengthNotMatch(inner) => {
                    <ArrayLengthNotMatch as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::CannotOperateForNode(inner) => {
                    <CannotOperateForNode as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::GloballyDisabledRegistry(inner) => {
                    <GloballyDisabledRegistry as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::GloballyEnabledRegistry(inner) => {
                    <GloballyEnabledRegistry as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NodeAlreadyRegisterd(inner) => {
                    <NodeAlreadyRegisterd as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NodeNotYetRegisterd(inner) => {
                    <NodeNotYetRegisterd as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NodeRegisterdToOtherAccount(inner) => {
                    <NodeRegisterdToOtherAccount as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NotEnoughAllowanceToRegisterNode(inner) => {
                    <NotEnoughAllowanceToRegisterNode as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::ArrayLengthNotMatch(inner) => {
                    <ArrayLengthNotMatch as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::CannotOperateForNode(inner) => {
                    <CannotOperateForNode as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::GloballyDisabledRegistry(inner) => {
                    <GloballyDisabledRegistry as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::GloballyEnabledRegistry(inner) => {
                    <GloballyEnabledRegistry as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NodeAlreadyRegisterd(inner) => {
                    <NodeAlreadyRegisterd as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NodeNotYetRegisterd(inner) => {
                    <NodeNotYetRegisterd as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NodeRegisterdToOtherAccount(inner) => {
                    <NodeRegisterdToOtherAccount as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotEnoughAllowanceToRegisterNode(inner) => {
                    <NotEnoughAllowanceToRegisterNode as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`HoprNetworkRegistry`](self) events.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub enum HoprNetworkRegistryEvents {
        #[allow(missing_docs)]
        Deregistered(Deregistered),
        #[allow(missing_docs)]
        DeregisteredByManager(DeregisteredByManager),
        #[allow(missing_docs)]
        EligibilityUpdated(EligibilityUpdated),
        #[allow(missing_docs)]
        NetworkRegistryStatusUpdated(NetworkRegistryStatusUpdated),
        #[allow(missing_docs)]
        Registered(Registered),
        #[allow(missing_docs)]
        RegisteredByManager(RegisteredByManager),
        #[allow(missing_docs)]
        RequirementUpdated(RequirementUpdated),
        #[allow(missing_docs)]
        RoleAdminChanged(RoleAdminChanged),
        #[allow(missing_docs)]
        RoleGranted(RoleGranted),
        #[allow(missing_docs)]
        RoleRevoked(RoleRevoked),
    }
    #[automatically_derived]
    impl HoprNetworkRegistryEvents {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                4u8, 225u8, 234u8, 164u8, 218u8, 24u8, 247u8, 231u8, 66u8, 164u8, 237u8,
                187u8, 233u8, 237u8, 227u8, 108u8, 223u8, 117u8, 247u8, 147u8, 187u8,
                3u8, 171u8, 33u8, 88u8, 192u8, 135u8, 127u8, 28u8, 175u8, 43u8, 147u8,
            ],
            [
                10u8, 49u8, 238u8, 157u8, 70u8, 168u8, 40u8, 136u8, 75u8, 129u8, 0u8,
                60u8, 132u8, 152u8, 21u8, 110u8, 166u8, 170u8, 21u8, 185u8, 181u8, 75u8,
                221u8, 14u8, 240u8, 181u8, 51u8, 217u8, 235u8, 165u8, 126u8, 85u8,
            ],
            [
                21u8, 154u8, 138u8, 233u8, 72u8, 252u8, 198u8, 231u8, 248u8, 181u8, 73u8,
                92u8, 13u8, 115u8, 233u8, 21u8, 152u8, 68u8, 10u8, 248u8, 166u8, 40u8,
                23u8, 36u8, 108u8, 9u8, 237u8, 194u8, 194u8, 141u8, 186u8, 138u8,
            ],
            [
                47u8, 135u8, 136u8, 17u8, 126u8, 126u8, 255u8, 29u8, 130u8, 233u8, 38u8,
                236u8, 121u8, 73u8, 1u8, 209u8, 124u8, 120u8, 2u8, 74u8, 80u8, 39u8, 9u8,
                64u8, 48u8, 69u8, 64u8, 167u8, 51u8, 101u8, 111u8, 13u8,
            ],
            [
                138u8, 196u8, 178u8, 235u8, 119u8, 73u8, 247u8, 92u8, 91u8, 153u8, 184u8,
                152u8, 229u8, 71u8, 253u8, 97u8, 93u8, 215u8, 164u8, 36u8, 230u8, 131u8,
                86u8, 234u8, 25u8, 107u8, 125u8, 174u8, 116u8, 45u8, 108u8, 50u8,
            ],
            [
                139u8, 200u8, 95u8, 37u8, 227u8, 233u8, 51u8, 151u8, 143u8, 9u8, 148u8,
                8u8, 179u8, 187u8, 62u8, 183u8, 99u8, 11u8, 118u8, 247u8, 69u8, 95u8,
                46u8, 32u8, 91u8, 203u8, 192u8, 167u8, 128u8, 225u8, 126u8, 114u8,
            ],
            [
                145u8, 118u8, 10u8, 16u8, 1u8, 245u8, 49u8, 236u8, 43u8, 238u8, 134u8,
                2u8, 190u8, 85u8, 173u8, 43u8, 17u8, 89u8, 70u8, 94u8, 223u8, 245u8,
                187u8, 205u8, 65u8, 210u8, 7u8, 3u8, 116u8, 42u8, 77u8, 66u8,
            ],
            [
                189u8, 121u8, 184u8, 111u8, 254u8, 10u8, 184u8, 232u8, 119u8, 97u8, 81u8,
                81u8, 66u8, 23u8, 205u8, 124u8, 172u8, 213u8, 44u8, 144u8, 159u8, 102u8,
                71u8, 92u8, 58u8, 244u8, 78u8, 18u8, 159u8, 11u8, 0u8, 255u8,
            ],
            [
                226u8, 153u8, 79u8, 141u8, 111u8, 96u8, 10u8, 212u8, 115u8, 219u8, 168u8,
                44u8, 10u8, 137u8, 10u8, 183u8, 175u8, 250u8, 203u8, 134u8, 13u8, 51u8,
                101u8, 244u8, 116u8, 186u8, 163u8, 220u8, 4u8, 162u8, 229u8, 87u8,
            ],
            [
                246u8, 57u8, 31u8, 92u8, 50u8, 217u8, 198u8, 157u8, 42u8, 71u8, 234u8,
                103u8, 11u8, 68u8, 41u8, 116u8, 181u8, 57u8, 53u8, 209u8, 237u8, 199u8,
                253u8, 100u8, 235u8, 33u8, 224u8, 71u8, 168u8, 57u8, 23u8, 27u8,
            ],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for HoprNetworkRegistryEvents {
        const NAME: &'static str = "HoprNetworkRegistryEvents";
        const COUNT: usize = 10usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(<Deregistered as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Deregistered as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::Deregistered)
                }
                Some(
                    <DeregisteredByManager as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <DeregisteredByManager as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::DeregisteredByManager)
                }
                Some(
                    <EligibilityUpdated as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <EligibilityUpdated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::EligibilityUpdated)
                }
                Some(
                    <NetworkRegistryStatusUpdated as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <NetworkRegistryStatusUpdated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::NetworkRegistryStatusUpdated)
                }
                Some(<Registered as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Registered as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::Registered)
                }
                Some(
                    <RegisteredByManager as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <RegisteredByManager as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::RegisteredByManager)
                }
                Some(
                    <RequirementUpdated as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <RequirementUpdated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::RequirementUpdated)
                }
                Some(<RoleAdminChanged as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <RoleAdminChanged as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::RoleAdminChanged)
                }
                Some(<RoleGranted as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <RoleGranted as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::RoleGranted)
                }
                Some(<RoleRevoked as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <RoleRevoked as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::RoleRevoked)
                }
                _ => {
                    alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                        name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                        log: alloy_sol_types::private::Box::new(
                            alloy_sol_types::private::LogData::new_unchecked(
                                topics.to_vec(),
                                data.to_vec().into(),
                            ),
                        ),
                    })
                }
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData for HoprNetworkRegistryEvents {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::Deregistered(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::DeregisteredByManager(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::EligibilityUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::NetworkRegistryStatusUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Registered(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RegisteredByManager(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RequirementUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RoleAdminChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RoleGranted(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RoleRevoked(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::Deregistered(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::DeregisteredByManager(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::EligibilityUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::NetworkRegistryStatusUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Registered(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RegisteredByManager(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RequirementUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RoleAdminChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RoleGranted(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RoleRevoked(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`HoprNetworkRegistry`](self) contract instance.

See the [wrapper's documentation](`HoprNetworkRegistryInstance`) for more details.*/
    #[inline]
    pub const fn new<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> HoprNetworkRegistryInstance<P, N> {
        HoprNetworkRegistryInstance::<P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        _requirementImplementation: alloy::sol_types::private::Address,
        _newOwner: alloy::sol_types::private::Address,
        _manager: alloy::sol_types::private::Address,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<HoprNetworkRegistryInstance<P, N>>,
    > {
        HoprNetworkRegistryInstance::<
            P,
            N,
        >::deploy(provider, _requirementImplementation, _newOwner, _manager)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        _requirementImplementation: alloy::sol_types::private::Address,
        _newOwner: alloy::sol_types::private::Address,
        _manager: alloy::sol_types::private::Address,
    ) -> alloy_contract::RawCallBuilder<P, N> {
        HoprNetworkRegistryInstance::<
            P,
            N,
        >::deploy_builder(provider, _requirementImplementation, _newOwner, _manager)
    }
    /**A [`HoprNetworkRegistry`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`HoprNetworkRegistry`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct HoprNetworkRegistryInstance<P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network: ::core::marker::PhantomData<N>,
    }
    #[automatically_derived]
    impl<P, N> ::core::fmt::Debug for HoprNetworkRegistryInstance<P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("HoprNetworkRegistryInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > HoprNetworkRegistryInstance<P, N> {
        /**Creates a new wrapper around an on-chain [`HoprNetworkRegistry`](self) contract instance.

See the [wrapper's documentation](`HoprNetworkRegistryInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
            _requirementImplementation: alloy::sol_types::private::Address,
            _newOwner: alloy::sol_types::private::Address,
            _manager: alloy::sol_types::private::Address,
        ) -> alloy_contract::Result<HoprNetworkRegistryInstance<P, N>> {
            let call_builder = Self::deploy_builder(
                provider,
                _requirementImplementation,
                _newOwner,
                _manager,
            );
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(
            provider: P,
            _requirementImplementation: alloy::sol_types::private::Address,
            _newOwner: alloy::sol_types::private::Address,
            _manager: alloy::sol_types::private::Address,
        ) -> alloy_contract::RawCallBuilder<P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                [
                    &BYTECODE[..],
                    &alloy_sol_types::SolConstructor::abi_encode(
                        &constructorCall {
                            _requirementImplementation,
                            _newOwner,
                            _manager,
                        },
                    )[..],
                ]
                    .concat()
                    .into(),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<P: ::core::clone::Clone, N> HoprNetworkRegistryInstance<&P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> HoprNetworkRegistryInstance<P, N> {
            HoprNetworkRegistryInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > HoprNetworkRegistryInstance<P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<&P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`DEFAULT_ADMIN_ROLE`] function.
        pub fn DEFAULT_ADMIN_ROLE(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, DEFAULT_ADMIN_ROLECall, N> {
            self.call_builder(&DEFAULT_ADMIN_ROLECall)
        }
        ///Creates a new call builder for the [`MANAGER_ROLE`] function.
        pub fn MANAGER_ROLE(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, MANAGER_ROLECall, N> {
            self.call_builder(&MANAGER_ROLECall)
        }
        ///Creates a new call builder for the [`countRegisterdNodesPerAccount`] function.
        pub fn countRegisterdNodesPerAccount(
            &self,
            _0: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, countRegisterdNodesPerAccountCall, N> {
            self.call_builder(&countRegisterdNodesPerAccountCall(_0))
        }
        ///Creates a new call builder for the [`disableRegistry`] function.
        pub fn disableRegistry(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, disableRegistryCall, N> {
            self.call_builder(&disableRegistryCall)
        }
        ///Creates a new call builder for the [`enableRegistry`] function.
        pub fn enableRegistry(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, enableRegistryCall, N> {
            self.call_builder(&enableRegistryCall)
        }
        ///Creates a new call builder for the [`enabled`] function.
        pub fn enabled(&self) -> alloy_contract::SolCallBuilder<&P, enabledCall, N> {
            self.call_builder(&enabledCall)
        }
        ///Creates a new call builder for the [`getRoleAdmin`] function.
        pub fn getRoleAdmin(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, getRoleAdminCall, N> {
            self.call_builder(&getRoleAdminCall { role })
        }
        ///Creates a new call builder for the [`getRoleMember`] function.
        pub fn getRoleMember(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            index: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, getRoleMemberCall, N> {
            self.call_builder(&getRoleMemberCall { role, index })
        }
        ///Creates a new call builder for the [`getRoleMemberCount`] function.
        pub fn getRoleMemberCount(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, getRoleMemberCountCall, N> {
            self.call_builder(&getRoleMemberCountCall { role })
        }
        ///Creates a new call builder for the [`grantRole`] function.
        pub fn grantRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, grantRoleCall, N> {
            self.call_builder(&grantRoleCall { role, account })
        }
        ///Creates a new call builder for the [`hasRole`] function.
        pub fn hasRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, hasRoleCall, N> {
            self.call_builder(&hasRoleCall { role, account })
        }
        ///Creates a new call builder for the [`isAccountEligible`] function.
        pub fn isAccountEligible(
            &self,
            stakingAccount: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, isAccountEligibleCall, N> {
            self.call_builder(
                &isAccountEligibleCall {
                    stakingAccount,
                },
            )
        }
        ///Creates a new call builder for the [`isNodeRegisteredAndEligible`] function.
        pub fn isNodeRegisteredAndEligible(
            &self,
            nodeAddress: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, isNodeRegisteredAndEligibleCall, N> {
            self.call_builder(
                &isNodeRegisteredAndEligibleCall {
                    nodeAddress,
                },
            )
        }
        ///Creates a new call builder for the [`isNodeRegisteredByAccount`] function.
        pub fn isNodeRegisteredByAccount(
            &self,
            nodeAddress: alloy::sol_types::private::Address,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, isNodeRegisteredByAccountCall, N> {
            self.call_builder(
                &isNodeRegisteredByAccountCall {
                    nodeAddress,
                    account,
                },
            )
        }
        ///Creates a new call builder for the [`managerDeregister`] function.
        pub fn managerDeregister(
            &self,
            nodeAddresses: alloy::sol_types::private::Vec<
                alloy::sol_types::private::Address,
            >,
        ) -> alloy_contract::SolCallBuilder<&P, managerDeregisterCall, N> {
            self.call_builder(
                &managerDeregisterCall {
                    nodeAddresses,
                },
            )
        }
        ///Creates a new call builder for the [`managerForceSync`] function.
        pub fn managerForceSync(
            &self,
            stakingAccounts: alloy::sol_types::private::Vec<
                alloy::sol_types::private::Address,
            >,
            eligibilities: alloy::sol_types::private::Vec<bool>,
        ) -> alloy_contract::SolCallBuilder<&P, managerForceSyncCall, N> {
            self.call_builder(
                &managerForceSyncCall {
                    stakingAccounts,
                    eligibilities,
                },
            )
        }
        ///Creates a new call builder for the [`managerRegister`] function.
        pub fn managerRegister(
            &self,
            stakingAccounts: alloy::sol_types::private::Vec<
                alloy::sol_types::private::Address,
            >,
            nodeAddresses: alloy::sol_types::private::Vec<
                alloy::sol_types::private::Address,
            >,
        ) -> alloy_contract::SolCallBuilder<&P, managerRegisterCall, N> {
            self.call_builder(
                &managerRegisterCall {
                    stakingAccounts,
                    nodeAddresses,
                },
            )
        }
        ///Creates a new call builder for the [`managerSync`] function.
        pub fn managerSync(
            &self,
            stakingAccounts: alloy::sol_types::private::Vec<
                alloy::sol_types::private::Address,
            >,
        ) -> alloy_contract::SolCallBuilder<&P, managerSyncCall, N> {
            self.call_builder(&managerSyncCall { stakingAccounts })
        }
        ///Creates a new call builder for the [`maxAdditionalRegistrations`] function.
        pub fn maxAdditionalRegistrations(
            &self,
            stakingAccount: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, maxAdditionalRegistrationsCall, N> {
            self.call_builder(
                &maxAdditionalRegistrationsCall {
                    stakingAccount,
                },
            )
        }
        ///Creates a new call builder for the [`nodeRegisterdToAccount`] function.
        pub fn nodeRegisterdToAccount(
            &self,
            _0: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, nodeRegisterdToAccountCall, N> {
            self.call_builder(&nodeRegisterdToAccountCall(_0))
        }
        ///Creates a new call builder for the [`renounceRole`] function.
        pub fn renounceRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, renounceRoleCall, N> {
            self.call_builder(&renounceRoleCall { role, account })
        }
        ///Creates a new call builder for the [`requirementImplementation`] function.
        pub fn requirementImplementation(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, requirementImplementationCall, N> {
            self.call_builder(&requirementImplementationCall)
        }
        ///Creates a new call builder for the [`revokeRole`] function.
        pub fn revokeRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, revokeRoleCall, N> {
            self.call_builder(&revokeRoleCall { role, account })
        }
        ///Creates a new call builder for the [`selfDeregister`] function.
        pub fn selfDeregister(
            &self,
            nodeAddresses: alloy::sol_types::private::Vec<
                alloy::sol_types::private::Address,
            >,
        ) -> alloy_contract::SolCallBuilder<&P, selfDeregisterCall, N> {
            self.call_builder(
                &selfDeregisterCall {
                    nodeAddresses,
                },
            )
        }
        ///Creates a new call builder for the [`selfRegister`] function.
        pub fn selfRegister(
            &self,
            nodeAddresses: alloy::sol_types::private::Vec<
                alloy::sol_types::private::Address,
            >,
        ) -> alloy_contract::SolCallBuilder<&P, selfRegisterCall, N> {
            self.call_builder(&selfRegisterCall { nodeAddresses })
        }
        ///Creates a new call builder for the [`selfSync`] function.
        pub fn selfSync(&self) -> alloy_contract::SolCallBuilder<&P, selfSyncCall, N> {
            self.call_builder(&selfSyncCall)
        }
        ///Creates a new call builder for the [`supportsInterface`] function.
        pub fn supportsInterface(
            &self,
            interfaceId: alloy::sol_types::private::FixedBytes<4>,
        ) -> alloy_contract::SolCallBuilder<&P, supportsInterfaceCall, N> {
            self.call_builder(
                &supportsInterfaceCall {
                    interfaceId,
                },
            )
        }
        ///Creates a new call builder for the [`updateRequirementImplementation`] function.
        pub fn updateRequirementImplementation(
            &self,
            _requirementImplementation: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, updateRequirementImplementationCall, N> {
            self.call_builder(
                &updateRequirementImplementationCall {
                    _requirementImplementation,
                },
            )
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > HoprNetworkRegistryInstance<P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<&P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        ///Creates a new event filter for the [`Deregistered`] event.
        pub fn Deregistered_filter(&self) -> alloy_contract::Event<&P, Deregistered, N> {
            self.event_filter::<Deregistered>()
        }
        ///Creates a new event filter for the [`DeregisteredByManager`] event.
        pub fn DeregisteredByManager_filter(
            &self,
        ) -> alloy_contract::Event<&P, DeregisteredByManager, N> {
            self.event_filter::<DeregisteredByManager>()
        }
        ///Creates a new event filter for the [`EligibilityUpdated`] event.
        pub fn EligibilityUpdated_filter(
            &self,
        ) -> alloy_contract::Event<&P, EligibilityUpdated, N> {
            self.event_filter::<EligibilityUpdated>()
        }
        ///Creates a new event filter for the [`NetworkRegistryStatusUpdated`] event.
        pub fn NetworkRegistryStatusUpdated_filter(
            &self,
        ) -> alloy_contract::Event<&P, NetworkRegistryStatusUpdated, N> {
            self.event_filter::<NetworkRegistryStatusUpdated>()
        }
        ///Creates a new event filter for the [`Registered`] event.
        pub fn Registered_filter(&self) -> alloy_contract::Event<&P, Registered, N> {
            self.event_filter::<Registered>()
        }
        ///Creates a new event filter for the [`RegisteredByManager`] event.
        pub fn RegisteredByManager_filter(
            &self,
        ) -> alloy_contract::Event<&P, RegisteredByManager, N> {
            self.event_filter::<RegisteredByManager>()
        }
        ///Creates a new event filter for the [`RequirementUpdated`] event.
        pub fn RequirementUpdated_filter(
            &self,
        ) -> alloy_contract::Event<&P, RequirementUpdated, N> {
            self.event_filter::<RequirementUpdated>()
        }
        ///Creates a new event filter for the [`RoleAdminChanged`] event.
        pub fn RoleAdminChanged_filter(
            &self,
        ) -> alloy_contract::Event<&P, RoleAdminChanged, N> {
            self.event_filter::<RoleAdminChanged>()
        }
        ///Creates a new event filter for the [`RoleGranted`] event.
        pub fn RoleGranted_filter(&self) -> alloy_contract::Event<&P, RoleGranted, N> {
            self.event_filter::<RoleGranted>()
        }
        ///Creates a new event filter for the [`RoleRevoked`] event.
        pub fn RoleRevoked_filter(&self) -> alloy_contract::Event<&P, RoleRevoked, N> {
            self.event_filter::<RoleRevoked>()
        }
    }
}
