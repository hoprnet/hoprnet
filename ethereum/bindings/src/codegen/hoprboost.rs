/**

Generated by the following Solidity interface...
```solidity
interface HoprBoost {
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);
    event BoostMinted(uint256 indexed boostTypeIndex, uint256 indexed boostNumerator, uint256 indexed redeemDeadline);
    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);
    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);
    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);

    constructor(address newAdmin, string baseTokenURI);

    function DEFAULT_ADMIN_ROLE() external view returns (bytes32);
    function MINTER_ROLE() external view returns (bytes32);
    function approve(address to, uint256 tokenId) external;
    function balanceOf(address owner) external view returns (uint256);
    function batchMint(address[] memory to, string memory boostType, string memory boostRank, uint256 boostNumerator, uint256 redeemDeadline) external;
    function boostOf(uint256 tokenId) external view returns (uint256, uint256);
    function getApproved(uint256 tokenId) external view returns (address);
    function getRoleAdmin(bytes32 role) external view returns (bytes32);
    function getRoleMember(bytes32 role, uint256 index) external view returns (address);
    function getRoleMemberCount(bytes32 role) external view returns (uint256);
    function grantRole(bytes32 role, address account) external;
    function hasRole(bytes32 role, address account) external view returns (bool);
    function isApprovedForAll(address owner, address operator) external view returns (bool);
    function mint(address to, string memory boostType, string memory boostRank, uint256 boostNumerator, uint256 redeemDeadline) external;
    function name() external view returns (string memory);
    function ownerOf(uint256 tokenId) external view returns (address);
    function reclaimErc20Tokens(address tokenAddress) external;
    function reclaimErc721Tokens(address tokenAddress, uint256 tokenId) external;
    function renounceRole(bytes32 role, address account) external;
    function revokeRole(bytes32 role, address account) external;
    function safeTransferFrom(address from, address to, uint256 tokenId) external;
    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) external;
    function setApprovalForAll(address operator, bool approved) external;
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
    function symbol() external view returns (string memory);
    function tokenByIndex(uint256 index) external view returns (uint256);
    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);
    function tokenURI(uint256 tokenId) external view returns (string memory);
    function totalSupply() external view returns (uint256);
    function transferFrom(address from, address to, uint256 tokenId) external;
    function typeAt(uint256 typeIndex) external view returns (string memory);
    function typeIndexOf(uint256 tokenId) external view returns (uint256);
    function typeOf(uint256 tokenId) external view returns (string memory);
    function updateBaseURI(string memory baseTokenURI) external;
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [
      {
        "name": "newAdmin",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "baseTokenURI",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "DEFAULT_ADMIN_ROLE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "MINTER_ROLE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "approve",
    "inputs": [
      {
        "name": "to",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "tokenId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "balanceOf",
    "inputs": [
      {
        "name": "owner",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "batchMint",
    "inputs": [
      {
        "name": "to",
        "type": "address[]",
        "internalType": "address[]"
      },
      {
        "name": "boostType",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "boostRank",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "boostNumerator",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "redeemDeadline",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "boostOf",
    "inputs": [
      {
        "name": "tokenId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getApproved",
    "inputs": [
      {
        "name": "tokenId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getRoleAdmin",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getRoleMember",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "index",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getRoleMemberCount",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "grantRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "hasRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "isApprovedForAll",
    "inputs": [
      {
        "name": "owner",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "mint",
    "inputs": [
      {
        "name": "to",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "boostType",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "boostRank",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "boostNumerator",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "redeemDeadline",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "name",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "ownerOf",
    "inputs": [
      {
        "name": "tokenId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "reclaimErc20Tokens",
    "inputs": [
      {
        "name": "tokenAddress",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "reclaimErc721Tokens",
    "inputs": [
      {
        "name": "tokenAddress",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "tokenId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "renounceRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "revokeRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "safeTransferFrom",
    "inputs": [
      {
        "name": "from",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "to",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "tokenId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "safeTransferFrom",
    "inputs": [
      {
        "name": "from",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "to",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "tokenId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "_data",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setApprovalForAll",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "approved",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "supportsInterface",
    "inputs": [
      {
        "name": "interfaceId",
        "type": "bytes4",
        "internalType": "bytes4"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "symbol",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "tokenByIndex",
    "inputs": [
      {
        "name": "index",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "tokenOfOwnerByIndex",
    "inputs": [
      {
        "name": "owner",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "index",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "tokenURI",
    "inputs": [
      {
        "name": "tokenId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "totalSupply",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "transferFrom",
    "inputs": [
      {
        "name": "from",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "to",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "tokenId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "typeAt",
    "inputs": [
      {
        "name": "typeIndex",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "typeIndexOf",
    "inputs": [
      {
        "name": "tokenId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "typeOf",
    "inputs": [
      {
        "name": "tokenId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "updateBaseURI",
    "inputs": [
      {
        "name": "baseTokenURI",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "event",
    "name": "Approval",
    "inputs": [
      {
        "name": "owner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "approved",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "tokenId",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "ApprovalForAll",
    "inputs": [
      {
        "name": "owner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "operator",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "approved",
        "type": "bool",
        "indexed": false,
        "internalType": "bool"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "BoostMinted",
    "inputs": [
      {
        "name": "boostTypeIndex",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      },
      {
        "name": "boostNumerator",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      },
      {
        "name": "redeemDeadline",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RoleAdminChanged",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "previousAdminRole",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "newAdminRole",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RoleGranted",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "sender",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RoleRevoked",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "sender",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Transfer",
    "inputs": [
      {
        "name": "from",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "to",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "tokenId",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod HoprBoost {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x60806040523480156200001157600080fd5b50604051620034db380380620034db833981016040819052620000349162000259565b6040518060400160405280600e81526020016d1213d41488109bdbdcdd0813919560921b8152506040518060400160405280600a8152602001691213d41488109bdbdcdd60b21b81525081600290816200008f9190620003dd565b5060036200009e8282620003dd565b50506001600d5550600e620000b48282620003dd565b50620000c2600083620000f6565b620000ee7f9f2df0fed2c77648de5860a4cc508cd0818c85b8b8a1ab4ceeef8d981c8956a683620000f6565b5050620004a9565b62000102828262000106565b5050565b62000112828262000131565b60008281526001602052604090206200012c9082620001d1565b505050565b6000828152602081815260408083206001600160a01b038516845290915290205460ff1662000102576000828152602081815260408083206001600160a01b03851684529091529020805460ff191660011790556200018d3390565b6001600160a01b0316816001600160a01b0316837f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d60405160405180910390a45050565b6000620001e8836001600160a01b038416620001f1565b90505b92915050565b60008181526001830160205260408120546200023a57508154600181810184556000848152602080822090930184905584548482528286019093526040902091909155620001eb565b506000620001eb565b634e487b7160e01b600052604160045260246000fd5b600080604083850312156200026d57600080fd5b82516001600160a01b03811681146200028557600080fd5b602084810151919350906001600160401b0380821115620002a557600080fd5b818601915086601f830112620002ba57600080fd5b815181811115620002cf57620002cf62000243565b604051601f8201601f19908116603f01168101908382118183101715620002fa57620002fa62000243565b8160405282815289868487010111156200031357600080fd5b600093505b8284101562000337578484018601518185018701529285019262000318565b60008684830101528096505050505050509250929050565b600181811c908216806200036457607f821691505b6020821081036200038557634e487b7160e01b600052602260045260246000fd5b50919050565b601f8211156200012c57600081815260208120601f850160051c81016020861015620003b45750805b601f850160051c820191505b81811015620003d557828155600101620003c0565b505050505050565b81516001600160401b03811115620003f957620003f962000243565b62000411816200040a84546200034f565b846200038b565b602080601f831160018114620004495760008415620004305750858301515b600019600386901b1c1916600185901b178555620003d5565b600085815260208120601f198616915b828110156200047a5788860151825594840194600190910190840162000459565b5085821015620004995787850151600019600388901b60f8161c191681555b5050505050600190811b01905550565b61302280620004b96000396000f3fe608060405234801561001057600080fd5b50600436106102065760003560e01c806370a082311161011a578063a22cb465116100ad578063c87b56dd1161007c578063c87b56dd14610498578063ca15c873146104ab578063d5391393146104be578063d547741f146104e5578063e985e9c5146104f857600080fd5b8063a22cb4651461044c578063b5185a881461045f578063b88d4fde14610472578063c588ff8b1461048557600080fd5b8063931688cb116100e9578063931688cb146104165780639365c5331461042957806395d89b411461043c578063a217fddf1461044457600080fd5b806370a082311461039b578063896cddf4146103ae5780639010d07c146103f057806391d148541461040357600080fd5b80632f2ff15d1161019d57806348c64e411161016c57806348c64e411461032f5780634f6ccce714610342578063562317c5146103555780636067bc15146103755780636352211e1461038857600080fd5b80632f2ff15d146102e35780632f745c59146102f657806336568abe1461030957806342842e0e1461031c57600080fd5b806318160ddd116101d957806318160ddd1461028857806323b872dd1461029a578063248a9ca3146102ad57806329867dac146102d057600080fd5b806301ffc9a71461020b57806306fdde0314610233578063081812fc14610248578063095ea7b314610273575b600080fd5b61021e61021936600461266f565b610534565b60405190151581526020015b60405180910390f35b61023b61055f565b60405161022a91906126dc565b61025b6102563660046126ef565b6105f1565b6040516001600160a01b03909116815260200161022a565b610286610281366004612724565b61067e565b005b600b545b60405190815260200161022a565b6102866102a836600461274e565b610793565b61028c6102bb3660046126ef565b60009081526020819052604090206001015490565b6102866102de366004612836565b6107c4565b6102866102f13660046128bc565b610876565b61028c610304366004612724565b61089c565b6102866103173660046128bc565b610932565b61028661032a36600461274e565b6109b0565b61028661033d366004612724565b6109cb565b61028c6103503660046126ef565b610aa4565b61028c6103633660046126ef565b60009081526013602052604090205490565b6102866103833660046128e8565b610b37565b61025b6103963660046126ef565b610c20565b61028c6103a93660046128e8565b610c97565b6103db6103bc3660046126ef565b6000908152601160209081526040808320546012909252909120549091565b6040805192835260208301919091520161022a565b61025b6103fe366004612903565b610d1e565b61021e6104113660046128bc565b610d3d565b610286610424366004612925565b610d66565b6102866104373660046129a3565b610d7e565b61023b610eeb565b61028c600081565b61028661045a366004612a88565b610efa565b61023b61046d3660046126ef565b610f05565b610286610480366004612abf565b610f12565b61023b6104933660046126ef565b610f4a565b61023b6104a63660046126ef565b610f68565b61028c6104b93660046126ef565b610f73565b61028c7f9f2df0fed2c77648de5860a4cc508cd0818c85b8b8a1ab4ceeef8d981c8956a681565b6102866104f33660046128bc565b610f8a565b61021e610506366004612b3b565b6001600160a01b03918216600090815260076020908152604080832093909416825291909152205460ff1690565b60006001600160e01b03198216630d639add60e11b1480610559575061055982610fb0565b92915050565b60606002805461056e90612b65565b80601f016020809104026020016040519081016040528092919081815260200182805461059a90612b65565b80156105e75780601f106105bc576101008083540402835291602001916105e7565b820191906000526020600020905b8154815290600101906020018083116105ca57829003601f168201915b5050505050905090565b60006105fc82610fd5565b6106625760405162461bcd60e51b815260206004820152602c60248201527f4552433732313a20617070726f76656420717565727920666f72206e6f6e657860448201526b34b9ba32b73a103a37b5b2b760a11b60648201526084015b60405180910390fd5b506000908152600660205260409020546001600160a01b031690565b600061068982610c20565b9050806001600160a01b0316836001600160a01b0316036106f65760405162461bcd60e51b815260206004820152602160248201527f4552433732313a20617070726f76616c20746f2063757272656e74206f776e656044820152603960f91b6064820152608401610659565b336001600160a01b038216148061071257506107128133610506565b6107845760405162461bcd60e51b815260206004820152603860248201527f4552433732313a20617070726f76652063616c6c6572206973206e6f74206f7760448201527f6e6572206e6f7220617070726f76656420666f7220616c6c00000000000000006064820152608401610659565b61078e8383610ff2565b505050565b61079d3382611060565b6107b95760405162461bcd60e51b815260040161065990612b9f565b61078e83838361114a565b7f9f2df0fed2c77648de5860a4cc508cd0818c85b8b8a1ab4ceeef8d981c8956a66107ef81336112f5565b6107fa600f86611359565b506000610808600f87611406565b90506000868660405160200161081f929190612bf0565b604051602081830303815290604052905061083d8886868585611431565b8385837f735e5eb5afdd72cc64657ded7e5de390af3708afb5b9a80b0e5c911a0499d98f60405160405180910390a45050505050505050565b60008281526020819052604090206001015461089281336112f5565b61078e8383611482565b60006108a783610c97565b82106109095760405162461bcd60e51b815260206004820152602b60248201527f455243373231456e756d657261626c653a206f776e657220696e646578206f7560448201526a74206f6620626f756e647360a81b6064820152608401610659565b506001600160a01b03919091166000908152600960209081526040808320938352929052205490565b6001600160a01b03811633146109a25760405162461bcd60e51b815260206004820152602f60248201527f416363657373436f6e74726f6c3a2063616e206f6e6c792072656e6f756e636560448201526e103937b632b9903337b91039b2b63360891b6064820152608401610659565b6109ac82826114a4565b5050565b61078e83838360405180602001604052806000815250610f12565b60006109d781336112f5565b6002600d5403610a295760405162461bcd60e51b815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c006044820152606401610659565b6002600d55604080516323b872dd60e01b81523060048201523360248201526044810184905290516001600160a01b038516916323b872dd91606480830192600092919082900301818387803b158015610a8257600080fd5b505af1158015610a96573d6000803e3d6000fd5b50506001600d555050505050565b6000610aaf600b5490565b8210610b125760405162461bcd60e51b815260206004820152602c60248201527f455243373231456e756d657261626c653a20676c6f62616c20696e646578206f60448201526b7574206f6620626f756e647360a01b6064820152608401610659565b600b8281548110610b2557610b25612c2c565b90600052602060002001549050919050565b6000610b4381336112f5565b6002600d5403610b955760405162461bcd60e51b815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c006044820152606401610659565b6002600d55610c17336040516370a0823160e01b81523060048201526001600160a01b038516906370a0823190602401602060405180830381865afa158015610be2573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c069190612c42565b6001600160a01b03851691906114c6565b50506001600d55565b6000818152600460205260408120546001600160a01b0316806105595760405162461bcd60e51b815260206004820152602960248201527f4552433732313a206f776e657220717565727920666f72206e6f6e657869737460448201526832b73a103a37b5b2b760b91b6064820152608401610659565b60006001600160a01b038216610d025760405162461bcd60e51b815260206004820152602a60248201527f4552433732313a2062616c616e636520717565727920666f7220746865207a65604482015269726f206164647265737360b01b6064820152608401610659565b506001600160a01b031660009081526005602052604090205490565b6000828152600160205260408120610d369083611518565b9392505050565b6000918252602082815260408084206001600160a01b0393909316845291905290205460ff1690565b6000610d7281336112f5565b600e61078e8382612ca1565b7f9f2df0fed2c77648de5860a4cc508cd0818c85b8b8a1ab4ceeef8d981c8956a6610da981336112f5565b610dec87878080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250600f939250506113599050565b506000610e3288888080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250600f939250506114069050565b9050600088888888604051602001610e4d9493929190612d61565b604051602081830303815290604052905060005b8a811015610eae57610e9c8c8c83818110610e7e57610e7e612c2c565b9050602002016020810190610e9391906128e8565b87878686611431565b80610ea681612da2565b915050610e61565b508385837f735e5eb5afdd72cc64657ded7e5de390af3708afb5b9a80b0e5c911a0499d98f60405160405180910390a45050505050505050505050565b60606003805461056e90612b65565b6109ac338383611524565b6060610559600f836115f2565b610f1c3383611060565b610f385760405162461bcd60e51b815260040161065990612b9f565b610f44848484846116ab565b50505050565b60008181526013602052604090205460609061055990600f906115f2565b6060610559826116de565b60008181526001602052604081206105599061183f565b600082815260208190526040902060010154610fa681336112f5565b61078e83836114a4565b60006001600160e01b0319821663780e9d6360e01b1480610559575061055982611849565b6000908152600460205260409020546001600160a01b0316151590565b600081815260066020526040902080546001600160a01b0319166001600160a01b038416908117909155819061102782610c20565b6001600160a01b03167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92560405160405180910390a45050565b600061106b82610fd5565b6110cc5760405162461bcd60e51b815260206004820152602c60248201527f4552433732313a206f70657261746f7220717565727920666f72206e6f6e657860448201526b34b9ba32b73a103a37b5b2b760a11b6064820152608401610659565b60006110d783610c20565b9050806001600160a01b0316846001600160a01b031614806111125750836001600160a01b0316611107846105f1565b6001600160a01b0316145b8061114257506001600160a01b0380821660009081526007602090815260408083209388168352929052205460ff165b949350505050565b826001600160a01b031661115d82610c20565b6001600160a01b0316146111c55760405162461bcd60e51b815260206004820152602960248201527f4552433732313a207472616e73666572206f6620746f6b656e2074686174206960448201526839903737ba1037bbb760b91b6064820152608401610659565b6001600160a01b0382166112275760405162461bcd60e51b8152602060048201526024808201527f4552433732313a207472616e7366657220746f20746865207a65726f206164646044820152637265737360e01b6064820152608401610659565b611232838383611889565b61123d600082610ff2565b6001600160a01b0383166000908152600560205260408120805460019290611266908490612dbb565b90915550506001600160a01b0382166000908152600560205260408120805460019290611294908490612dce565b909155505060008181526004602052604080822080546001600160a01b0319166001600160a01b0386811691821790925591518493918716917fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef91a4505050565b6112ff8282610d3d565b6109ac57611317816001600160a01b03166014611894565b611322836020611894565b604051602001611333929190612de1565b60408051601f198184030181529082905262461bcd60e51b8252610659916004016126dc565b60006113658383611a30565b6113fe578254600181018455600084815260209020016113858382612ca1565b508254604051600185019061139b908590612e56565b90815260200160405180910390208190555082600101826040516113bf9190612e56565b90815260405190819003602001812054907f11497a834951095469930ec62e1641f0dcf3617d9cd7579b6da76e54df3000a790600090a2506001610559565b506000610559565b6000826001018260405161141a9190612e56565b908152602001604051809103902054905092915050565b600061143c600b5490565b90506114488682611a5d565b6000818152601160209081526040808320889055601282528083208790556013909152902083905561147a8183611b9c565b505050505050565b61148c8282611c20565b600082815260016020526040902061078e9082611ca4565b6114ae8282611cb9565b600082815260016020526040902061078e9082611d1e565b604080516001600160a01b038416602482015260448082018490528251808303909101815260649091019091526020810180516001600160e01b031663a9059cbb60e01b17905261078e908490611d33565b6000610d368383611e05565b816001600160a01b0316836001600160a01b0316036115855760405162461bcd60e51b815260206004820152601960248201527f4552433732313a20617070726f766520746f2063616c6c6572000000000000006044820152606401610659565b6001600160a01b03838116600081815260076020908152604080832094871680845294825291829020805460ff191686151590811790915591519182527f17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31910160405180910390a3505050565b606082611600600184612dbb565b8154811061161057611610612c2c565b90600052602060002001805461162590612b65565b80601f016020809104026020016040519081016040528092919081815260200182805461165190612b65565b801561169e5780601f106116735761010080835404028352916020019161169e565b820191906000526020600020905b81548152906001019060200180831161168157829003601f168201915b5050505050905092915050565b6116b684848461114a565b6116c284848484611e2f565b610f445760405162461bcd60e51b815260040161065990612e72565b60606116e982610fd5565b61174f5760405162461bcd60e51b815260206004820152603160248201527f45524337323155524953746f726167653a2055524920717565727920666f72206044820152703737b732bc34b9ba32b73a103a37b5b2b760791b6064820152608401610659565b6000828152600860205260408120805461176890612b65565b80601f016020809104026020016040519081016040528092919081815260200182805461179490612b65565b80156117e15780601f106117b6576101008083540402835291602001916117e1565b820191906000526020600020905b8154815290600101906020018083116117c457829003601f168201915b5050505050905060006117f2611f30565b90508051600003611804575092915050565b81511561183657808260405160200161181e929190612ec4565b60405160208183030381529060405292505050919050565b61114284611f3f565b6000610559825490565b60006001600160e01b031982166380ac58cd60e01b148061187a57506001600160e01b03198216635b5e139f60e01b145b80610559575061055982612009565b61078e83838361202e565b606060006118a3836002612ef3565b6118ae906002612dce565b67ffffffffffffffff8111156118c6576118c661278a565b6040519080825280601f01601f1916602001820160405280156118f0576020820181803683370190505b509050600360fc1b8160008151811061190b5761190b612c2c565b60200101906001600160f81b031916908160001a905350600f60fb1b8160018151811061193a5761193a612c2c565b60200101906001600160f81b031916908160001a905350600061195e846002612ef3565b611969906001612dce565b90505b60018111156119e1576f181899199a1a9b1b9c1cb0b131b232b360811b85600f166010811061199d5761199d612c2c565b1a60f81b8282815181106119b3576119b3612c2c565b60200101906001600160f81b031916908160001a90535060049490941c936119da81612f0a565b905061196c565b508315610d365760405162461bcd60e51b815260206004820181905260248201527f537472696e67733a20686578206c656e67746820696e73756666696369656e746044820152606401610659565b60008260010182604051611a449190612e56565b9081526040519081900360200190205415159392505050565b6001600160a01b038216611ab35760405162461bcd60e51b815260206004820181905260248201527f4552433732313a206d696e7420746f20746865207a65726f20616464726573736044820152606401610659565b611abc81610fd5565b15611b095760405162461bcd60e51b815260206004820152601c60248201527f4552433732313a20746f6b656e20616c7265616479206d696e746564000000006044820152606401610659565b611b1560008383611889565b6001600160a01b0382166000908152600560205260408120805460019290611b3e908490612dce565b909155505060008181526004602052604080822080546001600160a01b0319166001600160a01b03861690811790915590518392907fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef908290a45050565b611ba582610fd5565b611c085760405162461bcd60e51b815260206004820152602e60248201527f45524337323155524953746f726167653a2055524920736574206f66206e6f6e60448201526d32bc34b9ba32b73a103a37b5b2b760911b6064820152608401610659565b600082815260086020526040902061078e8282612ca1565b611c2a8282610d3d565b6109ac576000828152602081815260408083206001600160a01b03851684529091529020805460ff19166001179055611c603390565b6001600160a01b0316816001600160a01b0316837f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d60405160405180910390a45050565b6000610d36836001600160a01b0384166120e6565b611cc38282610d3d565b156109ac576000828152602081815260408083206001600160a01b0385168085529252808320805460ff1916905551339285917ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b9190a45050565b6000610d36836001600160a01b03841661212d565b6000611d88826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b03166122209092919063ffffffff16565b80519091501561078e5780806020019051810190611da69190612f21565b61078e5760405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e6044820152691bdd081cdd58d8d9595960b21b6064820152608401610659565b6000826000018281548110611e1c57611e1c612c2c565b9060005260206000200154905092915050565b60006001600160a01b0384163b15611f2557604051630a85bd0160e11b81526001600160a01b0385169063150b7a0290611e73903390899088908890600401612f3e565b6020604051808303816000875af1925050508015611eae575060408051601f3d908101601f19168201909252611eab91810190612f7b565b60015b611f0b573d808015611edc576040519150601f19603f3d011682016040523d82523d6000602084013e611ee1565b606091505b508051600003611f035760405162461bcd60e51b815260040161065990612e72565b805181602001fd5b6001600160e01b031916630a85bd0160e11b149050611142565b506001949350505050565b6060600e805461056e90612b65565b6060611f4a82610fd5565b611fae5760405162461bcd60e51b815260206004820152602f60248201527f4552433732314d657461646174613a2055524920717565727920666f72206e6f60448201526e3732bc34b9ba32b73a103a37b5b2b760891b6064820152608401610659565b6000611fb8611f30565b90506000815111611fd85760405180602001604052806000815250610d36565b80611fe28461222f565b604051602001611ff3929190612ec4565b6040516020818303038152906040529392505050565b60006001600160e01b03198216635a05180f60e01b1480610559575061055982612330565b6001600160a01b0383166120895761208481600b80546000838152600c60205260408120829055600182018355919091527f0175b7a638427703f0dbe7bb9bbf987a2551717b34e79f33b5b1008d1fa01db90155565b6120ac565b816001600160a01b0316836001600160a01b0316146120ac576120ac8382612365565b6001600160a01b0382166120c35761078e81612402565b826001600160a01b0316826001600160a01b03161461078e5761078e82826124b1565b60008181526001830160205260408120546113fe57508154600181810184556000848152602080822090930184905584548482528286019093526040902091909155610559565b60008181526001830160205260408120548015612216576000612151600183612dbb565b855490915060009061216590600190612dbb565b90508181146121ca57600086600001828154811061218557612185612c2c565b90600052602060002001549050808760000184815481106121a8576121a8612c2c565b6000918252602080832090910192909255918252600188019052604090208390555b85548690806121db576121db612f98565b600190038181906000526020600020016000905590558560010160008681526020019081526020016000206000905560019350505050610559565b6000915050610559565b606061114284846000856124f5565b6060816000036122565750506040805180820190915260018152600360fc1b602082015290565b8160005b8115612280578061226a81612da2565b91506122799050600a83612fc4565b915061225a565b60008167ffffffffffffffff81111561229b5761229b61278a565b6040519080825280601f01601f1916602001820160405280156122c5576020820181803683370190505b5090505b8415611142576122da600183612dbb565b91506122e7600a86612fd8565b6122f2906030612dce565b60f81b81838151811061230757612307612c2c565b60200101906001600160f81b031916908160001a905350612329600a86612fc4565b94506122c9565b60006001600160e01b03198216637965db0b60e01b148061055957506301ffc9a760e01b6001600160e01b0319831614610559565b6000600161237284610c97565b61237c9190612dbb565b6000838152600a60205260409020549091508082146123cf576001600160a01b03841660009081526009602090815260408083208584528252808320548484528184208190558352600a90915290208190555b506000918252600a602090815260408084208490556001600160a01b039094168352600981528383209183525290812055565b600b5460009061241490600190612dbb565b6000838152600c6020526040812054600b805493945090928490811061243c5761243c612c2c565b9060005260206000200154905080600b838154811061245d5761245d612c2c565b6000918252602080832090910192909255828152600c9091526040808220849055858252812055600b80548061249557612495612f98565b6001900381819060005260206000200160009055905550505050565b60006124bc83610c97565b6001600160a01b0390931660009081526009602090815260408083208684528252808320859055938252600a9052919091209190915550565b6060824710156125565760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f6044820152651c8818d85b1b60d21b6064820152608401610659565b843b6125a45760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e74726163740000006044820152606401610659565b600080866001600160a01b031685876040516125c09190612e56565b60006040518083038185875af1925050503d80600081146125fd576040519150601f19603f3d011682016040523d82523d6000602084013e612602565b606091505b509150915061261282828661261d565b979650505050505050565b6060831561262c575081610d36565b82511561263c5782518084602001fd5b8160405162461bcd60e51b815260040161065991906126dc565b6001600160e01b03198116811461266c57600080fd5b50565b60006020828403121561268157600080fd5b8135610d3681612656565b60005b838110156126a757818101518382015260200161268f565b50506000910152565b600081518084526126c881602086016020860161268c565b601f01601f19169290920160200192915050565b602081526000610d3660208301846126b0565b60006020828403121561270157600080fd5b5035919050565b80356001600160a01b038116811461271f57600080fd5b919050565b6000806040838503121561273757600080fd5b61274083612708565b946020939093013593505050565b60008060006060848603121561276357600080fd5b61276c84612708565b925061277a60208501612708565b9150604084013590509250925092565b634e487b7160e01b600052604160045260246000fd5b600067ffffffffffffffff808411156127bb576127bb61278a565b604051601f8501601f19908116603f011681019082821181831017156127e3576127e361278a565b816040528093508581528686860111156127fc57600080fd5b858560208301376000602087830101525050509392505050565b600082601f83011261282757600080fd5b610d36838335602085016127a0565b600080600080600060a0868803121561284e57600080fd5b61285786612708565b9450602086013567ffffffffffffffff8082111561287457600080fd5b61288089838a01612816565b9550604088013591508082111561289657600080fd5b506128a388828901612816565b9598949750949560608101359550608001359392505050565b600080604083850312156128cf57600080fd5b823591506128df60208401612708565b90509250929050565b6000602082840312156128fa57600080fd5b610d3682612708565b6000806040838503121561291657600080fd5b50508035926020909101359150565b60006020828403121561293757600080fd5b813567ffffffffffffffff81111561294e57600080fd5b61114284828501612816565b60008083601f84011261296c57600080fd5b50813567ffffffffffffffff81111561298457600080fd5b60208301915083602082850101111561299c57600080fd5b9250929050565b60008060008060008060008060a0898b0312156129bf57600080fd5b883567ffffffffffffffff808211156129d757600080fd5b818b0191508b601f8301126129eb57600080fd5b8135818111156129fa57600080fd5b8c60208260051b8501011115612a0f57600080fd5b60209283019a509850908a01359080821115612a2a57600080fd5b612a368c838d0161295a565b909850965060408b0135915080821115612a4f57600080fd5b50612a5c8b828c0161295a565b999c989b509699959896976060870135966080013595509350505050565b801515811461266c57600080fd5b60008060408385031215612a9b57600080fd5b612aa483612708565b91506020830135612ab481612a7a565b809150509250929050565b60008060008060808587031215612ad557600080fd5b612ade85612708565b9350612aec60208601612708565b925060408501359150606085013567ffffffffffffffff811115612b0f57600080fd5b8501601f81018713612b2057600080fd5b612b2f878235602084016127a0565b91505092959194509250565b60008060408385031215612b4e57600080fd5b612b5783612708565b91506128df60208401612708565b600181811c90821680612b7957607f821691505b602082108103612b9957634e487b7160e01b600052602260045260246000fd5b50919050565b60208082526031908201527f4552433732313a207472616e736665722063616c6c6572206973206e6f74206f6040820152701ddb995c881b9bdc88185c1c1c9bdd9959607a1b606082015260800190565b60008351612c0281846020880161268c565b602f60f81b9083019081528351612c2081600184016020880161268c565b01600101949350505050565b634e487b7160e01b600052603260045260246000fd5b600060208284031215612c5457600080fd5b5051919050565b601f82111561078e57600081815260208120601f850160051c81016020861015612c825750805b601f850160051c820191505b8181101561147a57828155600101612c8e565b815167ffffffffffffffff811115612cbb57612cbb61278a565b612ccf81612cc98454612b65565b84612c5b565b602080601f831160018114612d045760008415612cec5750858301515b600019600386901b1c1916600185901b17855561147a565b600085815260208120601f198616915b82811015612d3357888601518255948401946001909101908401612d14565b5085821015612d515787850151600019600388901b60f8161c191681555b5050505050600190811b01905550565b838582376000848201602f60f81b815283856001830137600093016001019283525090949350505050565b634e487b7160e01b600052601160045260246000fd5b600060018201612db457612db4612d8c565b5060010190565b8181038181111561055957610559612d8c565b8082018082111561055957610559612d8c565b7f416363657373436f6e74726f6c3a206163636f756e7420000000000000000000815260008351612e1981601785016020880161268c565b7001034b99036b4b9b9b4b733903937b6329607d1b6017918401918201528351612e4a81602884016020880161268c565b01602801949350505050565b60008251612e6881846020870161268c565b9190910192915050565b60208082526032908201527f4552433732313a207472616e7366657220746f206e6f6e20455243373231526560408201527131b2b4bb32b91034b6b83632b6b2b73a32b960711b606082015260800190565b60008351612ed681846020880161268c565b835190830190612eea81836020880161268c565b01949350505050565b808202811582820484141761055957610559612d8c565b600081612f1957612f19612d8c565b506000190190565b600060208284031215612f3357600080fd5b8151610d3681612a7a565b6001600160a01b0385811682528416602082015260408101839052608060608201819052600090612f71908301846126b0565b9695505050505050565b600060208284031215612f8d57600080fd5b8151610d3681612656565b634e487b7160e01b600052603160045260246000fd5b634e487b7160e01b600052601260045260246000fd5b600082612fd357612fd3612fae565b500490565b600082612fe757612fe7612fae565b50069056fea26469706673582212206d7bdeeafd6b3cbb431f4c7c2225045ed0e8e39a368f310a27ae495f2fc10cdb64736f6c63430008130033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R4\x80\x15b\0\0\x11W`\0\x80\xFD[P`@Qb\x004\xDB8\x03\x80b\x004\xDB\x839\x81\x01`@\x81\x90Rb\0\x004\x91b\0\x02YV[`@Q\x80`@\x01`@R\x80`\x0E\x81R` \x01m\x12\x13\xD4\x14\x88\x10\x9B\xDB\xDC\xDD\x08\x13\x91\x95`\x92\x1B\x81RP`@Q\x80`@\x01`@R\x80`\n\x81R` \x01i\x12\x13\xD4\x14\x88\x10\x9B\xDB\xDC\xDD`\xB2\x1B\x81RP\x81`\x02\x90\x81b\0\0\x8F\x91\x90b\0\x03\xDDV[P`\x03b\0\0\x9E\x82\x82b\0\x03\xDDV[PP`\x01`\rUP`\x0Eb\0\0\xB4\x82\x82b\0\x03\xDDV[Pb\0\0\xC2`\0\x83b\0\0\xF6V[b\0\0\xEE\x7F\x9F-\xF0\xFE\xD2\xC7vH\xDEX`\xA4\xCCP\x8C\xD0\x81\x8C\x85\xB8\xB8\xA1\xABL\xEE\xEF\x8D\x98\x1C\x89V\xA6\x83b\0\0\xF6V[PPb\0\x04\xA9V[b\0\x01\x02\x82\x82b\0\x01\x06V[PPV[b\0\x01\x12\x82\x82b\0\x011V[`\0\x82\x81R`\x01` R`@\x90 b\0\x01,\x90\x82b\0\x01\xD1V[PPPV[`\0\x82\x81R` \x81\x81R`@\x80\x83 `\x01`\x01`\xA0\x1B\x03\x85\x16\x84R\x90\x91R\x90 T`\xFF\x16b\0\x01\x02W`\0\x82\x81R` \x81\x81R`@\x80\x83 `\x01`\x01`\xA0\x1B\x03\x85\x16\x84R\x90\x91R\x90 \x80T`\xFF\x19\x16`\x01\x17\x90Ub\0\x01\x8D3\x90V[`\x01`\x01`\xA0\x1B\x03\x16\x81`\x01`\x01`\xA0\x1B\x03\x16\x83\x7F/\x87\x88\x11~~\xFF\x1D\x82\xE9&\xECyI\x01\xD1|x\x02JP'\t@0E@\xA73eo\r`@Q`@Q\x80\x91\x03\x90\xA4PPV[`\0b\0\x01\xE8\x83`\x01`\x01`\xA0\x1B\x03\x84\x16b\0\x01\xF1V[\x90P[\x92\x91PPV[`\0\x81\x81R`\x01\x83\x01` R`@\x81 Tb\0\x02:WP\x81T`\x01\x81\x81\x01\x84U`\0\x84\x81R` \x80\x82 \x90\x93\x01\x84\x90U\x84T\x84\x82R\x82\x86\x01\x90\x93R`@\x90 \x91\x90\x91Ub\0\x01\xEBV[P`\0b\0\x01\xEBV[cNH{q`\xE0\x1B`\0R`A`\x04R`$`\0\xFD[`\0\x80`@\x83\x85\x03\x12\x15b\0\x02mW`\0\x80\xFD[\x82Q`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14b\0\x02\x85W`\0\x80\xFD[` \x84\x81\x01Q\x91\x93P\x90`\x01`\x01`@\x1B\x03\x80\x82\x11\x15b\0\x02\xA5W`\0\x80\xFD[\x81\x86\x01\x91P\x86`\x1F\x83\x01\x12b\0\x02\xBAW`\0\x80\xFD[\x81Q\x81\x81\x11\x15b\0\x02\xCFWb\0\x02\xCFb\0\x02CV[`@Q`\x1F\x82\x01`\x1F\x19\x90\x81\x16`?\x01\x16\x81\x01\x90\x83\x82\x11\x81\x83\x10\x17\x15b\0\x02\xFAWb\0\x02\xFAb\0\x02CV[\x81`@R\x82\x81R\x89\x86\x84\x87\x01\x01\x11\x15b\0\x03\x13W`\0\x80\xFD[`\0\x93P[\x82\x84\x10\x15b\0\x037W\x84\x84\x01\x86\x01Q\x81\x85\x01\x87\x01R\x92\x85\x01\x92b\0\x03\x18V[`\0\x86\x84\x83\x01\x01R\x80\x96PPPPPPP\x92P\x92\x90PV[`\x01\x81\x81\x1C\x90\x82\x16\x80b\0\x03dW`\x7F\x82\x16\x91P[` \x82\x10\x81\x03b\0\x03\x85WcNH{q`\xE0\x1B`\0R`\"`\x04R`$`\0\xFD[P\x91\x90PV[`\x1F\x82\x11\x15b\0\x01,W`\0\x81\x81R` \x81 `\x1F\x85\x01`\x05\x1C\x81\x01` \x86\x10\x15b\0\x03\xB4WP\x80[`\x1F\x85\x01`\x05\x1C\x82\x01\x91P[\x81\x81\x10\x15b\0\x03\xD5W\x82\x81U`\x01\x01b\0\x03\xC0V[PPPPPPV[\x81Q`\x01`\x01`@\x1B\x03\x81\x11\x15b\0\x03\xF9Wb\0\x03\xF9b\0\x02CV[b\0\x04\x11\x81b\0\x04\n\x84Tb\0\x03OV[\x84b\0\x03\x8BV[` \x80`\x1F\x83\x11`\x01\x81\x14b\0\x04IW`\0\x84\x15b\0\x040WP\x85\x83\x01Q[`\0\x19`\x03\x86\x90\x1B\x1C\x19\x16`\x01\x85\x90\x1B\x17\x85Ub\0\x03\xD5V[`\0\x85\x81R` \x81 `\x1F\x19\x86\x16\x91[\x82\x81\x10\x15b\0\x04zW\x88\x86\x01Q\x82U\x94\x84\x01\x94`\x01\x90\x91\x01\x90\x84\x01b\0\x04YV[P\x85\x82\x10\x15b\0\x04\x99W\x87\x85\x01Q`\0\x19`\x03\x88\x90\x1B`\xF8\x16\x1C\x19\x16\x81U[PPPPP`\x01\x90\x81\x1B\x01\x90UPV[a0\"\x80b\0\x04\xB9`\09`\0\xF3\xFE`\x80`@R4\x80\x15a\0\x10W`\0\x80\xFD[P`\x046\x10a\x02\x06W`\x005`\xE0\x1C\x80cp\xA0\x821\x11a\x01\x1AW\x80c\xA2,\xB4e\x11a\0\xADW\x80c\xC8{V\xDD\x11a\0|W\x80c\xC8{V\xDD\x14a\x04\x98W\x80c\xCA\x15\xC8s\x14a\x04\xABW\x80c\xD59\x13\x93\x14a\x04\xBEW\x80c\xD5Gt\x1F\x14a\x04\xE5W\x80c\xE9\x85\xE9\xC5\x14a\x04\xF8W`\0\x80\xFD[\x80c\xA2,\xB4e\x14a\x04LW\x80c\xB5\x18Z\x88\x14a\x04_W\x80c\xB8\x8DO\xDE\x14a\x04rW\x80c\xC5\x88\xFF\x8B\x14a\x04\x85W`\0\x80\xFD[\x80c\x93\x16\x88\xCB\x11a\0\xE9W\x80c\x93\x16\x88\xCB\x14a\x04\x16W\x80c\x93e\xC53\x14a\x04)W\x80c\x95\xD8\x9BA\x14a\x04<W\x80c\xA2\x17\xFD\xDF\x14a\x04DW`\0\x80\xFD[\x80cp\xA0\x821\x14a\x03\x9BW\x80c\x89l\xDD\xF4\x14a\x03\xAEW\x80c\x90\x10\xD0|\x14a\x03\xF0W\x80c\x91\xD1HT\x14a\x04\x03W`\0\x80\xFD[\x80c//\xF1]\x11a\x01\x9DW\x80cH\xC6NA\x11a\x01lW\x80cH\xC6NA\x14a\x03/W\x80cOl\xCC\xE7\x14a\x03BW\x80cV#\x17\xC5\x14a\x03UW\x80c`g\xBC\x15\x14a\x03uW\x80ccR!\x1E\x14a\x03\x88W`\0\x80\xFD[\x80c//\xF1]\x14a\x02\xE3W\x80c/t\\Y\x14a\x02\xF6W\x80c6V\x8A\xBE\x14a\x03\tW\x80cB\x84.\x0E\x14a\x03\x1CW`\0\x80\xFD[\x80c\x18\x16\r\xDD\x11a\x01\xD9W\x80c\x18\x16\r\xDD\x14a\x02\x88W\x80c#\xB8r\xDD\x14a\x02\x9AW\x80c$\x8A\x9C\xA3\x14a\x02\xADW\x80c)\x86}\xAC\x14a\x02\xD0W`\0\x80\xFD[\x80c\x01\xFF\xC9\xA7\x14a\x02\x0BW\x80c\x06\xFD\xDE\x03\x14a\x023W\x80c\x08\x18\x12\xFC\x14a\x02HW\x80c\t^\xA7\xB3\x14a\x02sW[`\0\x80\xFD[a\x02\x1Ea\x02\x196`\x04a&oV[a\x054V[`@Q\x90\x15\x15\x81R` \x01[`@Q\x80\x91\x03\x90\xF3[a\x02;a\x05_V[`@Qa\x02*\x91\x90a&\xDCV[a\x02[a\x02V6`\x04a&\xEFV[a\x05\xF1V[`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R` \x01a\x02*V[a\x02\x86a\x02\x816`\x04a'$V[a\x06~V[\0[`\x0BT[`@Q\x90\x81R` \x01a\x02*V[a\x02\x86a\x02\xA86`\x04a'NV[a\x07\x93V[a\x02\x8Ca\x02\xBB6`\x04a&\xEFV[`\0\x90\x81R` \x81\x90R`@\x90 `\x01\x01T\x90V[a\x02\x86a\x02\xDE6`\x04a(6V[a\x07\xC4V[a\x02\x86a\x02\xF16`\x04a(\xBCV[a\x08vV[a\x02\x8Ca\x03\x046`\x04a'$V[a\x08\x9CV[a\x02\x86a\x03\x176`\x04a(\xBCV[a\t2V[a\x02\x86a\x03*6`\x04a'NV[a\t\xB0V[a\x02\x86a\x03=6`\x04a'$V[a\t\xCBV[a\x02\x8Ca\x03P6`\x04a&\xEFV[a\n\xA4V[a\x02\x8Ca\x03c6`\x04a&\xEFV[`\0\x90\x81R`\x13` R`@\x90 T\x90V[a\x02\x86a\x03\x836`\x04a(\xE8V[a\x0B7V[a\x02[a\x03\x966`\x04a&\xEFV[a\x0C V[a\x02\x8Ca\x03\xA96`\x04a(\xE8V[a\x0C\x97V[a\x03\xDBa\x03\xBC6`\x04a&\xEFV[`\0\x90\x81R`\x11` \x90\x81R`@\x80\x83 T`\x12\x90\x92R\x90\x91 T\x90\x91V[`@\x80Q\x92\x83R` \x83\x01\x91\x90\x91R\x01a\x02*V[a\x02[a\x03\xFE6`\x04a)\x03V[a\r\x1EV[a\x02\x1Ea\x04\x116`\x04a(\xBCV[a\r=V[a\x02\x86a\x04$6`\x04a)%V[a\rfV[a\x02\x86a\x0476`\x04a)\xA3V[a\r~V[a\x02;a\x0E\xEBV[a\x02\x8C`\0\x81V[a\x02\x86a\x04Z6`\x04a*\x88V[a\x0E\xFAV[a\x02;a\x04m6`\x04a&\xEFV[a\x0F\x05V[a\x02\x86a\x04\x806`\x04a*\xBFV[a\x0F\x12V[a\x02;a\x04\x936`\x04a&\xEFV[a\x0FJV[a\x02;a\x04\xA66`\x04a&\xEFV[a\x0FhV[a\x02\x8Ca\x04\xB96`\x04a&\xEFV[a\x0FsV[a\x02\x8C\x7F\x9F-\xF0\xFE\xD2\xC7vH\xDEX`\xA4\xCCP\x8C\xD0\x81\x8C\x85\xB8\xB8\xA1\xABL\xEE\xEF\x8D\x98\x1C\x89V\xA6\x81V[a\x02\x86a\x04\xF36`\x04a(\xBCV[a\x0F\x8AV[a\x02\x1Ea\x05\x066`\x04a+;V[`\x01`\x01`\xA0\x1B\x03\x91\x82\x16`\0\x90\x81R`\x07` \x90\x81R`@\x80\x83 \x93\x90\x94\x16\x82R\x91\x90\x91R T`\xFF\x16\x90V[`\0`\x01`\x01`\xE0\x1B\x03\x19\x82\x16c\rc\x9A\xDD`\xE1\x1B\x14\x80a\x05YWPa\x05Y\x82a\x0F\xB0V[\x92\x91PPV[```\x02\x80Ta\x05n\x90a+eV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x05\x9A\x90a+eV[\x80\x15a\x05\xE7W\x80`\x1F\x10a\x05\xBCWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x05\xE7V[\x82\x01\x91\x90`\0R` `\0 \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x05\xCAW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x90P\x90V[`\0a\x05\xFC\x82a\x0F\xD5V[a\x06bW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`,`$\x82\x01R\x7FERC721: approved query for nonex`D\x82\x01Rk4\xB9\xBA2\xB7:\x10:7\xB5\xB2\xB7`\xA1\x1B`d\x82\x01R`\x84\x01[`@Q\x80\x91\x03\x90\xFD[P`\0\x90\x81R`\x06` R`@\x90 T`\x01`\x01`\xA0\x1B\x03\x16\x90V[`\0a\x06\x89\x82a\x0C V[\x90P\x80`\x01`\x01`\xA0\x1B\x03\x16\x83`\x01`\x01`\xA0\x1B\x03\x16\x03a\x06\xF6W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`!`$\x82\x01R\x7FERC721: approval to current owne`D\x82\x01R`9`\xF9\x1B`d\x82\x01R`\x84\x01a\x06YV[3`\x01`\x01`\xA0\x1B\x03\x82\x16\x14\x80a\x07\x12WPa\x07\x12\x813a\x05\x06V[a\x07\x84W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`8`$\x82\x01R\x7FERC721: approve caller is not ow`D\x82\x01R\x7Fner nor approved for all\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x06YV[a\x07\x8E\x83\x83a\x0F\xF2V[PPPV[a\x07\x9D3\x82a\x10`V[a\x07\xB9W`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x06Y\x90a+\x9FV[a\x07\x8E\x83\x83\x83a\x11JV[\x7F\x9F-\xF0\xFE\xD2\xC7vH\xDEX`\xA4\xCCP\x8C\xD0\x81\x8C\x85\xB8\xB8\xA1\xABL\xEE\xEF\x8D\x98\x1C\x89V\xA6a\x07\xEF\x813a\x12\xF5V[a\x07\xFA`\x0F\x86a\x13YV[P`\0a\x08\x08`\x0F\x87a\x14\x06V[\x90P`\0\x86\x86`@Q` \x01a\x08\x1F\x92\x91\x90a+\xF0V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x90Pa\x08=\x88\x86\x86\x85\x85a\x141V[\x83\x85\x83\x7Fs^^\xB5\xAF\xDDr\xCCde}\xED~]\xE3\x90\xAF7\x08\xAF\xB5\xB9\xA8\x0B\x0E\\\x91\x1A\x04\x99\xD9\x8F`@Q`@Q\x80\x91\x03\x90\xA4PPPPPPPPV[`\0\x82\x81R` \x81\x90R`@\x90 `\x01\x01Ta\x08\x92\x813a\x12\xF5V[a\x07\x8E\x83\x83a\x14\x82V[`\0a\x08\xA7\x83a\x0C\x97V[\x82\x10a\t\tW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`+`$\x82\x01R\x7FERC721Enumerable: owner index ou`D\x82\x01Rjt of bounds`\xA8\x1B`d\x82\x01R`\x84\x01a\x06YV[P`\x01`\x01`\xA0\x1B\x03\x91\x90\x91\x16`\0\x90\x81R`\t` \x90\x81R`@\x80\x83 \x93\x83R\x92\x90R T\x90V[`\x01`\x01`\xA0\x1B\x03\x81\x163\x14a\t\xA2W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`/`$\x82\x01R\x7FAccessControl: can only renounce`D\x82\x01Rn\x1097\xB62\xB9\x9037\xB9\x109\xB2\xB63`\x89\x1B`d\x82\x01R`\x84\x01a\x06YV[a\t\xAC\x82\x82a\x14\xA4V[PPV[a\x07\x8E\x83\x83\x83`@Q\x80` \x01`@R\x80`\0\x81RPa\x0F\x12V[`\0a\t\xD7\x813a\x12\xF5V[`\x02`\rT\x03a\n)W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1F`$\x82\x01R\x7FReentrancyGuard: reentrant call\0`D\x82\x01R`d\x01a\x06YV[`\x02`\rU`@\x80Qc#\xB8r\xDD`\xE0\x1B\x81R0`\x04\x82\x01R3`$\x82\x01R`D\x81\x01\x84\x90R\x90Q`\x01`\x01`\xA0\x1B\x03\x85\x16\x91c#\xB8r\xDD\x91`d\x80\x83\x01\x92`\0\x92\x91\x90\x82\x90\x03\x01\x81\x83\x87\x80;\x15\x80\x15a\n\x82W`\0\x80\xFD[PZ\xF1\x15\x80\x15a\n\x96W=`\0\x80>=`\0\xFD[PP`\x01`\rUPPPPPV[`\0a\n\xAF`\x0BT\x90V[\x82\x10a\x0B\x12W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`,`$\x82\x01R\x7FERC721Enumerable: global index o`D\x82\x01Rkut of bounds`\xA0\x1B`d\x82\x01R`\x84\x01a\x06YV[`\x0B\x82\x81T\x81\x10a\x0B%Wa\x0B%a,,V[\x90`\0R` `\0 \x01T\x90P\x91\x90PV[`\0a\x0BC\x813a\x12\xF5V[`\x02`\rT\x03a\x0B\x95W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1F`$\x82\x01R\x7FReentrancyGuard: reentrant call\0`D\x82\x01R`d\x01a\x06YV[`\x02`\rUa\x0C\x173`@Qcp\xA0\x821`\xE0\x1B\x81R0`\x04\x82\x01R`\x01`\x01`\xA0\x1B\x03\x85\x16\x90cp\xA0\x821\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x0B\xE2W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x0C\x06\x91\x90a,BV[`\x01`\x01`\xA0\x1B\x03\x85\x16\x91\x90a\x14\xC6V[PP`\x01`\rUV[`\0\x81\x81R`\x04` R`@\x81 T`\x01`\x01`\xA0\x1B\x03\x16\x80a\x05YW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`)`$\x82\x01R\x7FERC721: owner query for nonexist`D\x82\x01Rh2\xB7:\x10:7\xB5\xB2\xB7`\xB9\x1B`d\x82\x01R`\x84\x01a\x06YV[`\0`\x01`\x01`\xA0\x1B\x03\x82\x16a\r\x02W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`*`$\x82\x01R\x7FERC721: balance query for the ze`D\x82\x01Riro address`\xB0\x1B`d\x82\x01R`\x84\x01a\x06YV[P`\x01`\x01`\xA0\x1B\x03\x16`\0\x90\x81R`\x05` R`@\x90 T\x90V[`\0\x82\x81R`\x01` R`@\x81 a\r6\x90\x83a\x15\x18V[\x93\x92PPPV[`\0\x91\x82R` \x82\x81R`@\x80\x84 `\x01`\x01`\xA0\x1B\x03\x93\x90\x93\x16\x84R\x91\x90R\x90 T`\xFF\x16\x90V[`\0a\rr\x813a\x12\xF5V[`\x0Ea\x07\x8E\x83\x82a,\xA1V[\x7F\x9F-\xF0\xFE\xD2\xC7vH\xDEX`\xA4\xCCP\x8C\xD0\x81\x8C\x85\xB8\xB8\xA1\xABL\xEE\xEF\x8D\x98\x1C\x89V\xA6a\r\xA9\x813a\x12\xF5V[a\r\xEC\x87\x87\x80\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83\x80\x82\x847`\0\x92\x01\x91\x90\x91RP`\x0F\x93\x92PPa\x13Y\x90PV[P`\0a\x0E2\x88\x88\x80\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83\x80\x82\x847`\0\x92\x01\x91\x90\x91RP`\x0F\x93\x92PPa\x14\x06\x90PV[\x90P`\0\x88\x88\x88\x88`@Q` \x01a\x0EM\x94\x93\x92\x91\x90a-aV[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x90P`\0[\x8A\x81\x10\x15a\x0E\xAEWa\x0E\x9C\x8C\x8C\x83\x81\x81\x10a\x0E~Wa\x0E~a,,V[\x90P` \x02\x01` \x81\x01\x90a\x0E\x93\x91\x90a(\xE8V[\x87\x87\x86\x86a\x141V[\x80a\x0E\xA6\x81a-\xA2V[\x91PPa\x0EaV[P\x83\x85\x83\x7Fs^^\xB5\xAF\xDDr\xCCde}\xED~]\xE3\x90\xAF7\x08\xAF\xB5\xB9\xA8\x0B\x0E\\\x91\x1A\x04\x99\xD9\x8F`@Q`@Q\x80\x91\x03\x90\xA4PPPPPPPPPPPV[```\x03\x80Ta\x05n\x90a+eV[a\t\xAC3\x83\x83a\x15$V[``a\x05Y`\x0F\x83a\x15\xF2V[a\x0F\x1C3\x83a\x10`V[a\x0F8W`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x06Y\x90a+\x9FV[a\x0FD\x84\x84\x84\x84a\x16\xABV[PPPPV[`\0\x81\x81R`\x13` R`@\x90 T``\x90a\x05Y\x90`\x0F\x90a\x15\xF2V[``a\x05Y\x82a\x16\xDEV[`\0\x81\x81R`\x01` R`@\x81 a\x05Y\x90a\x18?V[`\0\x82\x81R` \x81\x90R`@\x90 `\x01\x01Ta\x0F\xA6\x813a\x12\xF5V[a\x07\x8E\x83\x83a\x14\xA4V[`\0`\x01`\x01`\xE0\x1B\x03\x19\x82\x16cx\x0E\x9Dc`\xE0\x1B\x14\x80a\x05YWPa\x05Y\x82a\x18IV[`\0\x90\x81R`\x04` R`@\x90 T`\x01`\x01`\xA0\x1B\x03\x16\x15\x15\x90V[`\0\x81\x81R`\x06` R`@\x90 \x80T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x84\x16\x90\x81\x17\x90\x91U\x81\x90a\x10'\x82a\x0C V[`\x01`\x01`\xA0\x1B\x03\x16\x7F\x8C[\xE1\xE5\xEB\xEC}[\xD1OqB}\x1E\x84\xF3\xDD\x03\x14\xC0\xF7\xB2)\x1E[ \n\xC8\xC7\xC3\xB9%`@Q`@Q\x80\x91\x03\x90\xA4PPV[`\0a\x10k\x82a\x0F\xD5V[a\x10\xCCW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`,`$\x82\x01R\x7FERC721: operator query for nonex`D\x82\x01Rk4\xB9\xBA2\xB7:\x10:7\xB5\xB2\xB7`\xA1\x1B`d\x82\x01R`\x84\x01a\x06YV[`\0a\x10\xD7\x83a\x0C V[\x90P\x80`\x01`\x01`\xA0\x1B\x03\x16\x84`\x01`\x01`\xA0\x1B\x03\x16\x14\x80a\x11\x12WP\x83`\x01`\x01`\xA0\x1B\x03\x16a\x11\x07\x84a\x05\xF1V[`\x01`\x01`\xA0\x1B\x03\x16\x14[\x80a\x11BWP`\x01`\x01`\xA0\x1B\x03\x80\x82\x16`\0\x90\x81R`\x07` \x90\x81R`@\x80\x83 \x93\x88\x16\x83R\x92\x90R T`\xFF\x16[\x94\x93PPPPV[\x82`\x01`\x01`\xA0\x1B\x03\x16a\x11]\x82a\x0C V[`\x01`\x01`\xA0\x1B\x03\x16\x14a\x11\xC5W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`)`$\x82\x01R\x7FERC721: transfer of token that i`D\x82\x01Rh9\x9077\xBA\x107\xBB\xB7`\xB9\x1B`d\x82\x01R`\x84\x01a\x06YV[`\x01`\x01`\xA0\x1B\x03\x82\x16a\x12'W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`$\x80\x82\x01R\x7FERC721: transfer to the zero add`D\x82\x01Rcress`\xE0\x1B`d\x82\x01R`\x84\x01a\x06YV[a\x122\x83\x83\x83a\x18\x89V[a\x12=`\0\x82a\x0F\xF2V[`\x01`\x01`\xA0\x1B\x03\x83\x16`\0\x90\x81R`\x05` R`@\x81 \x80T`\x01\x92\x90a\x12f\x90\x84\x90a-\xBBV[\x90\x91UPP`\x01`\x01`\xA0\x1B\x03\x82\x16`\0\x90\x81R`\x05` R`@\x81 \x80T`\x01\x92\x90a\x12\x94\x90\x84\x90a-\xCEV[\x90\x91UPP`\0\x81\x81R`\x04` R`@\x80\x82 \x80T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x86\x81\x16\x91\x82\x17\x90\x92U\x91Q\x84\x93\x91\x87\x16\x91\x7F\xDD\xF2R\xAD\x1B\xE2\xC8\x9Bi\xC2\xB0h\xFC7\x8D\xAA\x95+\xA7\xF1c\xC4\xA1\x16(\xF5ZM\xF5#\xB3\xEF\x91\xA4PPPV[a\x12\xFF\x82\x82a\r=V[a\t\xACWa\x13\x17\x81`\x01`\x01`\xA0\x1B\x03\x16`\x14a\x18\x94V[a\x13\"\x83` a\x18\x94V[`@Q` \x01a\x133\x92\x91\x90a-\xE1V[`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x90\x82\x90RbF\x1B\xCD`\xE5\x1B\x82Ra\x06Y\x91`\x04\x01a&\xDCV[`\0a\x13e\x83\x83a\x1A0V[a\x13\xFEW\x82T`\x01\x81\x01\x84U`\0\x84\x81R` \x90 \x01a\x13\x85\x83\x82a,\xA1V[P\x82T`@Q`\x01\x85\x01\x90a\x13\x9B\x90\x85\x90a.VV[\x90\x81R` \x01`@Q\x80\x91\x03\x90 \x81\x90UP\x82`\x01\x01\x82`@Qa\x13\xBF\x91\x90a.VV[\x90\x81R`@Q\x90\x81\x90\x03` \x01\x81 T\x90\x7F\x11Iz\x83IQ\tTi\x93\x0E\xC6.\x16A\xF0\xDC\xF3a}\x9C\xD7W\x9Bm\xA7nT\xDF0\0\xA7\x90`\0\x90\xA2P`\x01a\x05YV[P`\0a\x05YV[`\0\x82`\x01\x01\x82`@Qa\x14\x1A\x91\x90a.VV[\x90\x81R` \x01`@Q\x80\x91\x03\x90 T\x90P\x92\x91PPV[`\0a\x14<`\x0BT\x90V[\x90Pa\x14H\x86\x82a\x1A]V[`\0\x81\x81R`\x11` \x90\x81R`@\x80\x83 \x88\x90U`\x12\x82R\x80\x83 \x87\x90U`\x13\x90\x91R\x90 \x83\x90Ua\x14z\x81\x83a\x1B\x9CV[PPPPPPV[a\x14\x8C\x82\x82a\x1C V[`\0\x82\x81R`\x01` R`@\x90 a\x07\x8E\x90\x82a\x1C\xA4V[a\x14\xAE\x82\x82a\x1C\xB9V[`\0\x82\x81R`\x01` R`@\x90 a\x07\x8E\x90\x82a\x1D\x1EV[`@\x80Q`\x01`\x01`\xA0\x1B\x03\x84\x16`$\x82\x01R`D\x80\x82\x01\x84\x90R\x82Q\x80\x83\x03\x90\x91\x01\x81R`d\x90\x91\x01\x90\x91R` \x81\x01\x80Q`\x01`\x01`\xE0\x1B\x03\x16c\xA9\x05\x9C\xBB`\xE0\x1B\x17\x90Ra\x07\x8E\x90\x84\x90a\x1D3V[`\0a\r6\x83\x83a\x1E\x05V[\x81`\x01`\x01`\xA0\x1B\x03\x16\x83`\x01`\x01`\xA0\x1B\x03\x16\x03a\x15\x85W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x19`$\x82\x01R\x7FERC721: approve to caller\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x06YV[`\x01`\x01`\xA0\x1B\x03\x83\x81\x16`\0\x81\x81R`\x07` \x90\x81R`@\x80\x83 \x94\x87\x16\x80\x84R\x94\x82R\x91\x82\x90 \x80T`\xFF\x19\x16\x86\x15\x15\x90\x81\x17\x90\x91U\x91Q\x91\x82R\x7F\x170~\xAB9\xABa\x07\xE8\x89\x98E\xAD=Y\xBD\x96S\xF2\0\xF2 \x92\x04\x89\xCA+Y7il1\x91\x01`@Q\x80\x91\x03\x90\xA3PPPV[``\x82a\x16\0`\x01\x84a-\xBBV[\x81T\x81\x10a\x16\x10Wa\x16\x10a,,V[\x90`\0R` `\0 \x01\x80Ta\x16%\x90a+eV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x16Q\x90a+eV[\x80\x15a\x16\x9EW\x80`\x1F\x10a\x16sWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x16\x9EV[\x82\x01\x91\x90`\0R` `\0 \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x16\x81W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x90P\x92\x91PPV[a\x16\xB6\x84\x84\x84a\x11JV[a\x16\xC2\x84\x84\x84\x84a\x1E/V[a\x0FDW`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x06Y\x90a.rV[``a\x16\xE9\x82a\x0F\xD5V[a\x17OW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`1`$\x82\x01R\x7FERC721URIStorage: URI query for `D\x82\x01Rp77\xB72\xBC4\xB9\xBA2\xB7:\x10:7\xB5\xB2\xB7`y\x1B`d\x82\x01R`\x84\x01a\x06YV[`\0\x82\x81R`\x08` R`@\x81 \x80Ta\x17h\x90a+eV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x17\x94\x90a+eV[\x80\x15a\x17\xE1W\x80`\x1F\x10a\x17\xB6Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x17\xE1V[\x82\x01\x91\x90`\0R` `\0 \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x17\xC4W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x90P`\0a\x17\xF2a\x1F0V[\x90P\x80Q`\0\x03a\x18\x04WP\x92\x91PPV[\x81Q\x15a\x186W\x80\x82`@Q` \x01a\x18\x1E\x92\x91\x90a.\xC4V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x92PPP\x91\x90PV[a\x11B\x84a\x1F?V[`\0a\x05Y\x82T\x90V[`\0`\x01`\x01`\xE0\x1B\x03\x19\x82\x16c\x80\xACX\xCD`\xE0\x1B\x14\x80a\x18zWP`\x01`\x01`\xE0\x1B\x03\x19\x82\x16c[^\x13\x9F`\xE0\x1B\x14[\x80a\x05YWPa\x05Y\x82a \tV[a\x07\x8E\x83\x83\x83a .V[```\0a\x18\xA3\x83`\x02a.\xF3V[a\x18\xAE\x90`\x02a-\xCEV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x18\xC6Wa\x18\xC6a'\x8AV[`@Q\x90\x80\x82R\x80`\x1F\x01`\x1F\x19\x16` \x01\x82\x01`@R\x80\x15a\x18\xF0W` \x82\x01\x81\x806\x837\x01\x90P[P\x90P`\x03`\xFC\x1B\x81`\0\x81Q\x81\x10a\x19\x0BWa\x19\x0Ba,,V[` \x01\x01\x90`\x01`\x01`\xF8\x1B\x03\x19\x16\x90\x81`\0\x1A\x90SP`\x0F`\xFB\x1B\x81`\x01\x81Q\x81\x10a\x19:Wa\x19:a,,V[` \x01\x01\x90`\x01`\x01`\xF8\x1B\x03\x19\x16\x90\x81`\0\x1A\x90SP`\0a\x19^\x84`\x02a.\xF3V[a\x19i\x90`\x01a-\xCEV[\x90P[`\x01\x81\x11\x15a\x19\xE1Wo\x18\x18\x99\x19\x9A\x1A\x9B\x1B\x9C\x1C\xB0\xB11\xB22\xB3`\x81\x1B\x85`\x0F\x16`\x10\x81\x10a\x19\x9DWa\x19\x9Da,,V[\x1A`\xF8\x1B\x82\x82\x81Q\x81\x10a\x19\xB3Wa\x19\xB3a,,V[` \x01\x01\x90`\x01`\x01`\xF8\x1B\x03\x19\x16\x90\x81`\0\x1A\x90SP`\x04\x94\x90\x94\x1C\x93a\x19\xDA\x81a/\nV[\x90Pa\x19lV[P\x83\x15a\r6W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01\x81\x90R`$\x82\x01R\x7FStrings: hex length insufficient`D\x82\x01R`d\x01a\x06YV[`\0\x82`\x01\x01\x82`@Qa\x1AD\x91\x90a.VV[\x90\x81R`@Q\x90\x81\x90\x03` \x01\x90 T\x15\x15\x93\x92PPPV[`\x01`\x01`\xA0\x1B\x03\x82\x16a\x1A\xB3W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01\x81\x90R`$\x82\x01R\x7FERC721: mint to the zero address`D\x82\x01R`d\x01a\x06YV[a\x1A\xBC\x81a\x0F\xD5V[\x15a\x1B\tW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1C`$\x82\x01R\x7FERC721: token already minted\0\0\0\0`D\x82\x01R`d\x01a\x06YV[a\x1B\x15`\0\x83\x83a\x18\x89V[`\x01`\x01`\xA0\x1B\x03\x82\x16`\0\x90\x81R`\x05` R`@\x81 \x80T`\x01\x92\x90a\x1B>\x90\x84\x90a-\xCEV[\x90\x91UPP`\0\x81\x81R`\x04` R`@\x80\x82 \x80T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x86\x16\x90\x81\x17\x90\x91U\x90Q\x83\x92\x90\x7F\xDD\xF2R\xAD\x1B\xE2\xC8\x9Bi\xC2\xB0h\xFC7\x8D\xAA\x95+\xA7\xF1c\xC4\xA1\x16(\xF5ZM\xF5#\xB3\xEF\x90\x82\x90\xA4PPV[a\x1B\xA5\x82a\x0F\xD5V[a\x1C\x08W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`.`$\x82\x01R\x7FERC721URIStorage: URI set of non`D\x82\x01Rm2\xBC4\xB9\xBA2\xB7:\x10:7\xB5\xB2\xB7`\x91\x1B`d\x82\x01R`\x84\x01a\x06YV[`\0\x82\x81R`\x08` R`@\x90 a\x07\x8E\x82\x82a,\xA1V[a\x1C*\x82\x82a\r=V[a\t\xACW`\0\x82\x81R` \x81\x81R`@\x80\x83 `\x01`\x01`\xA0\x1B\x03\x85\x16\x84R\x90\x91R\x90 \x80T`\xFF\x19\x16`\x01\x17\x90Ua\x1C`3\x90V[`\x01`\x01`\xA0\x1B\x03\x16\x81`\x01`\x01`\xA0\x1B\x03\x16\x83\x7F/\x87\x88\x11~~\xFF\x1D\x82\xE9&\xECyI\x01\xD1|x\x02JP'\t@0E@\xA73eo\r`@Q`@Q\x80\x91\x03\x90\xA4PPV[`\0a\r6\x83`\x01`\x01`\xA0\x1B\x03\x84\x16a \xE6V[a\x1C\xC3\x82\x82a\r=V[\x15a\t\xACW`\0\x82\x81R` \x81\x81R`@\x80\x83 `\x01`\x01`\xA0\x1B\x03\x85\x16\x80\x85R\x92R\x80\x83 \x80T`\xFF\x19\x16\x90UQ3\x92\x85\x91\x7F\xF69\x1F\\2\xD9\xC6\x9D*G\xEAg\x0BD)t\xB595\xD1\xED\xC7\xFDd\xEB!\xE0G\xA89\x17\x1B\x91\x90\xA4PPV[`\0a\r6\x83`\x01`\x01`\xA0\x1B\x03\x84\x16a!-V[`\0a\x1D\x88\x82`@Q\x80`@\x01`@R\x80` \x81R` \x01\x7FSafeERC20: low-level call failed\x81RP\x85`\x01`\x01`\xA0\x1B\x03\x16a\" \x90\x92\x91\x90c\xFF\xFF\xFF\xFF\x16V[\x80Q\x90\x91P\x15a\x07\x8EW\x80\x80` \x01\x90Q\x81\x01\x90a\x1D\xA6\x91\x90a/!V[a\x07\x8EW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`*`$\x82\x01R\x7FSafeERC20: ERC20 operation did n`D\x82\x01Ri\x1B\xDD\x08\x1C\xDDX\xD8\xD9YY`\xB2\x1B`d\x82\x01R`\x84\x01a\x06YV[`\0\x82`\0\x01\x82\x81T\x81\x10a\x1E\x1CWa\x1E\x1Ca,,V[\x90`\0R` `\0 \x01T\x90P\x92\x91PPV[`\0`\x01`\x01`\xA0\x1B\x03\x84\x16;\x15a\x1F%W`@Qc\n\x85\xBD\x01`\xE1\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x85\x16\x90c\x15\x0Bz\x02\x90a\x1Es\x903\x90\x89\x90\x88\x90\x88\x90`\x04\x01a/>V[` `@Q\x80\x83\x03\x81`\0\x87Z\xF1\x92PPP\x80\x15a\x1E\xAEWP`@\x80Q`\x1F=\x90\x81\x01`\x1F\x19\x16\x82\x01\x90\x92Ra\x1E\xAB\x91\x81\x01\x90a/{V[`\x01[a\x1F\x0BW=\x80\x80\x15a\x1E\xDCW`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=`\0` \x84\x01>a\x1E\xE1V[``\x91P[P\x80Q`\0\x03a\x1F\x03W`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x06Y\x90a.rV[\x80Q\x81` \x01\xFD[`\x01`\x01`\xE0\x1B\x03\x19\x16c\n\x85\xBD\x01`\xE1\x1B\x14\x90Pa\x11BV[P`\x01\x94\x93PPPPV[```\x0E\x80Ta\x05n\x90a+eV[``a\x1FJ\x82a\x0F\xD5V[a\x1F\xAEW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`/`$\x82\x01R\x7FERC721Metadata: URI query for no`D\x82\x01Rn72\xBC4\xB9\xBA2\xB7:\x10:7\xB5\xB2\xB7`\x89\x1B`d\x82\x01R`\x84\x01a\x06YV[`\0a\x1F\xB8a\x1F0V[\x90P`\0\x81Q\x11a\x1F\xD8W`@Q\x80` \x01`@R\x80`\0\x81RPa\r6V[\x80a\x1F\xE2\x84a\"/V[`@Q` \x01a\x1F\xF3\x92\x91\x90a.\xC4V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x93\x92PPPV[`\0`\x01`\x01`\xE0\x1B\x03\x19\x82\x16cZ\x05\x18\x0F`\xE0\x1B\x14\x80a\x05YWPa\x05Y\x82a#0V[`\x01`\x01`\xA0\x1B\x03\x83\x16a \x89Wa \x84\x81`\x0B\x80T`\0\x83\x81R`\x0C` R`@\x81 \x82\x90U`\x01\x82\x01\x83U\x91\x90\x91R\x7F\x01u\xB7\xA68Bw\x03\xF0\xDB\xE7\xBB\x9B\xBF\x98z%Qq{4\xE7\x9F3\xB5\xB1\0\x8D\x1F\xA0\x1D\xB9\x01UV[a \xACV[\x81`\x01`\x01`\xA0\x1B\x03\x16\x83`\x01`\x01`\xA0\x1B\x03\x16\x14a \xACWa \xAC\x83\x82a#eV[`\x01`\x01`\xA0\x1B\x03\x82\x16a \xC3Wa\x07\x8E\x81a$\x02V[\x82`\x01`\x01`\xA0\x1B\x03\x16\x82`\x01`\x01`\xA0\x1B\x03\x16\x14a\x07\x8EWa\x07\x8E\x82\x82a$\xB1V[`\0\x81\x81R`\x01\x83\x01` R`@\x81 Ta\x13\xFEWP\x81T`\x01\x81\x81\x01\x84U`\0\x84\x81R` \x80\x82 \x90\x93\x01\x84\x90U\x84T\x84\x82R\x82\x86\x01\x90\x93R`@\x90 \x91\x90\x91Ua\x05YV[`\0\x81\x81R`\x01\x83\x01` R`@\x81 T\x80\x15a\"\x16W`\0a!Q`\x01\x83a-\xBBV[\x85T\x90\x91P`\0\x90a!e\x90`\x01\x90a-\xBBV[\x90P\x81\x81\x14a!\xCAW`\0\x86`\0\x01\x82\x81T\x81\x10a!\x85Wa!\x85a,,V[\x90`\0R` `\0 \x01T\x90P\x80\x87`\0\x01\x84\x81T\x81\x10a!\xA8Wa!\xA8a,,V[`\0\x91\x82R` \x80\x83 \x90\x91\x01\x92\x90\x92U\x91\x82R`\x01\x88\x01\x90R`@\x90 \x83\x90U[\x85T\x86\x90\x80a!\xDBWa!\xDBa/\x98V[`\x01\x90\x03\x81\x81\x90`\0R` `\0 \x01`\0\x90U\x90U\x85`\x01\x01`\0\x86\x81R` \x01\x90\x81R` \x01`\0 `\0\x90U`\x01\x93PPPPa\x05YV[`\0\x91PPa\x05YV[``a\x11B\x84\x84`\0\x85a$\xF5V[``\x81`\0\x03a\"VWPP`@\x80Q\x80\x82\x01\x90\x91R`\x01\x81R`\x03`\xFC\x1B` \x82\x01R\x90V[\x81`\0[\x81\x15a\"\x80W\x80a\"j\x81a-\xA2V[\x91Pa\"y\x90P`\n\x83a/\xC4V[\x91Pa\"ZV[`\0\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\"\x9BWa\"\x9Ba'\x8AV[`@Q\x90\x80\x82R\x80`\x1F\x01`\x1F\x19\x16` \x01\x82\x01`@R\x80\x15a\"\xC5W` \x82\x01\x81\x806\x837\x01\x90P[P\x90P[\x84\x15a\x11BWa\"\xDA`\x01\x83a-\xBBV[\x91Pa\"\xE7`\n\x86a/\xD8V[a\"\xF2\x90`0a-\xCEV[`\xF8\x1B\x81\x83\x81Q\x81\x10a#\x07Wa#\x07a,,V[` \x01\x01\x90`\x01`\x01`\xF8\x1B\x03\x19\x16\x90\x81`\0\x1A\x90SPa#)`\n\x86a/\xC4V[\x94Pa\"\xC9V[`\0`\x01`\x01`\xE0\x1B\x03\x19\x82\x16cye\xDB\x0B`\xE0\x1B\x14\x80a\x05YWPc\x01\xFF\xC9\xA7`\xE0\x1B`\x01`\x01`\xE0\x1B\x03\x19\x83\x16\x14a\x05YV[`\0`\x01a#r\x84a\x0C\x97V[a#|\x91\x90a-\xBBV[`\0\x83\x81R`\n` R`@\x90 T\x90\x91P\x80\x82\x14a#\xCFW`\x01`\x01`\xA0\x1B\x03\x84\x16`\0\x90\x81R`\t` \x90\x81R`@\x80\x83 \x85\x84R\x82R\x80\x83 T\x84\x84R\x81\x84 \x81\x90U\x83R`\n\x90\x91R\x90 \x81\x90U[P`\0\x91\x82R`\n` \x90\x81R`@\x80\x84 \x84\x90U`\x01`\x01`\xA0\x1B\x03\x90\x94\x16\x83R`\t\x81R\x83\x83 \x91\x83RR\x90\x81 UV[`\x0BT`\0\x90a$\x14\x90`\x01\x90a-\xBBV[`\0\x83\x81R`\x0C` R`@\x81 T`\x0B\x80T\x93\x94P\x90\x92\x84\x90\x81\x10a$<Wa$<a,,V[\x90`\0R` `\0 \x01T\x90P\x80`\x0B\x83\x81T\x81\x10a$]Wa$]a,,V[`\0\x91\x82R` \x80\x83 \x90\x91\x01\x92\x90\x92U\x82\x81R`\x0C\x90\x91R`@\x80\x82 \x84\x90U\x85\x82R\x81 U`\x0B\x80T\x80a$\x95Wa$\x95a/\x98V[`\x01\x90\x03\x81\x81\x90`\0R` `\0 \x01`\0\x90U\x90UPPPPV[`\0a$\xBC\x83a\x0C\x97V[`\x01`\x01`\xA0\x1B\x03\x90\x93\x16`\0\x90\x81R`\t` \x90\x81R`@\x80\x83 \x86\x84R\x82R\x80\x83 \x85\x90U\x93\x82R`\n\x90R\x91\x90\x91 \x91\x90\x91UPV[``\x82G\x10\x15a%VW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`&`$\x82\x01R\x7FAddress: insufficient balance fo`D\x82\x01Re\x1C\x88\x18\xD8[\x1B`\xD2\x1B`d\x82\x01R`\x84\x01a\x06YV[\x84;a%\xA4W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1D`$\x82\x01R\x7FAddress: call to non-contract\0\0\0`D\x82\x01R`d\x01a\x06YV[`\0\x80\x86`\x01`\x01`\xA0\x1B\x03\x16\x85\x87`@Qa%\xC0\x91\x90a.VV[`\0`@Q\x80\x83\x03\x81\x85\x87Z\xF1\x92PPP=\x80`\0\x81\x14a%\xFDW`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=`\0` \x84\x01>a&\x02V[``\x91P[P\x91P\x91Pa&\x12\x82\x82\x86a&\x1DV[\x97\x96PPPPPPPV[``\x83\x15a&,WP\x81a\r6V[\x82Q\x15a&<W\x82Q\x80\x84` \x01\xFD[\x81`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x06Y\x91\x90a&\xDCV[`\x01`\x01`\xE0\x1B\x03\x19\x81\x16\x81\x14a&lW`\0\x80\xFD[PV[`\0` \x82\x84\x03\x12\x15a&\x81W`\0\x80\xFD[\x815a\r6\x81a&VV[`\0[\x83\x81\x10\x15a&\xA7W\x81\x81\x01Q\x83\x82\x01R` \x01a&\x8FV[PP`\0\x91\x01RV[`\0\x81Q\x80\x84Ra&\xC8\x81` \x86\x01` \x86\x01a&\x8CV[`\x1F\x01`\x1F\x19\x16\x92\x90\x92\x01` \x01\x92\x91PPV[` \x81R`\0a\r6` \x83\x01\x84a&\xB0V[`\0` \x82\x84\x03\x12\x15a'\x01W`\0\x80\xFD[P5\x91\x90PV[\x805`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a'\x1FW`\0\x80\xFD[\x91\x90PV[`\0\x80`@\x83\x85\x03\x12\x15a'7W`\0\x80\xFD[a'@\x83a'\x08V[\x94` \x93\x90\x93\x015\x93PPPV[`\0\x80`\0``\x84\x86\x03\x12\x15a'cW`\0\x80\xFD[a'l\x84a'\x08V[\x92Pa'z` \x85\x01a'\x08V[\x91P`@\x84\x015\x90P\x92P\x92P\x92V[cNH{q`\xE0\x1B`\0R`A`\x04R`$`\0\xFD[`\0g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x84\x11\x15a'\xBBWa'\xBBa'\x8AV[`@Q`\x1F\x85\x01`\x1F\x19\x90\x81\x16`?\x01\x16\x81\x01\x90\x82\x82\x11\x81\x83\x10\x17\x15a'\xE3Wa'\xE3a'\x8AV[\x81`@R\x80\x93P\x85\x81R\x86\x86\x86\x01\x11\x15a'\xFCW`\0\x80\xFD[\x85\x85` \x83\x017`\0` \x87\x83\x01\x01RPPP\x93\x92PPPV[`\0\x82`\x1F\x83\x01\x12a('W`\0\x80\xFD[a\r6\x83\x835` \x85\x01a'\xA0V[`\0\x80`\0\x80`\0`\xA0\x86\x88\x03\x12\x15a(NW`\0\x80\xFD[a(W\x86a'\x08V[\x94P` \x86\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x82\x11\x15a(tW`\0\x80\xFD[a(\x80\x89\x83\x8A\x01a(\x16V[\x95P`@\x88\x015\x91P\x80\x82\x11\x15a(\x96W`\0\x80\xFD[Pa(\xA3\x88\x82\x89\x01a(\x16V[\x95\x98\x94\x97P\x94\x95``\x81\x015\x95P`\x80\x015\x93\x92PPPV[`\0\x80`@\x83\x85\x03\x12\x15a(\xCFW`\0\x80\xFD[\x825\x91Pa(\xDF` \x84\x01a'\x08V[\x90P\x92P\x92\x90PV[`\0` \x82\x84\x03\x12\x15a(\xFAW`\0\x80\xFD[a\r6\x82a'\x08V[`\0\x80`@\x83\x85\x03\x12\x15a)\x16W`\0\x80\xFD[PP\x805\x92` \x90\x91\x015\x91PV[`\0` \x82\x84\x03\x12\x15a)7W`\0\x80\xFD[\x815g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a)NW`\0\x80\xFD[a\x11B\x84\x82\x85\x01a(\x16V[`\0\x80\x83`\x1F\x84\x01\x12a)lW`\0\x80\xFD[P\x815g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a)\x84W`\0\x80\xFD[` \x83\x01\x91P\x83` \x82\x85\x01\x01\x11\x15a)\x9CW`\0\x80\xFD[\x92P\x92\x90PV[`\0\x80`\0\x80`\0\x80`\0\x80`\xA0\x89\x8B\x03\x12\x15a)\xBFW`\0\x80\xFD[\x885g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x82\x11\x15a)\xD7W`\0\x80\xFD[\x81\x8B\x01\x91P\x8B`\x1F\x83\x01\x12a)\xEBW`\0\x80\xFD[\x815\x81\x81\x11\x15a)\xFAW`\0\x80\xFD[\x8C` \x82`\x05\x1B\x85\x01\x01\x11\x15a*\x0FW`\0\x80\xFD[` \x92\x83\x01\x9AP\x98P\x90\x8A\x015\x90\x80\x82\x11\x15a**W`\0\x80\xFD[a*6\x8C\x83\x8D\x01a)ZV[\x90\x98P\x96P`@\x8B\x015\x91P\x80\x82\x11\x15a*OW`\0\x80\xFD[Pa*\\\x8B\x82\x8C\x01a)ZV[\x99\x9C\x98\x9BP\x96\x99\x95\x98\x96\x97``\x87\x015\x96`\x80\x015\x95P\x93PPPPV[\x80\x15\x15\x81\x14a&lW`\0\x80\xFD[`\0\x80`@\x83\x85\x03\x12\x15a*\x9BW`\0\x80\xFD[a*\xA4\x83a'\x08V[\x91P` \x83\x015a*\xB4\x81a*zV[\x80\x91PP\x92P\x92\x90PV[`\0\x80`\0\x80`\x80\x85\x87\x03\x12\x15a*\xD5W`\0\x80\xFD[a*\xDE\x85a'\x08V[\x93Pa*\xEC` \x86\x01a'\x08V[\x92P`@\x85\x015\x91P``\x85\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a+\x0FW`\0\x80\xFD[\x85\x01`\x1F\x81\x01\x87\x13a+ W`\0\x80\xFD[a+/\x87\x825` \x84\x01a'\xA0V[\x91PP\x92\x95\x91\x94P\x92PV[`\0\x80`@\x83\x85\x03\x12\x15a+NW`\0\x80\xFD[a+W\x83a'\x08V[\x91Pa(\xDF` \x84\x01a'\x08V[`\x01\x81\x81\x1C\x90\x82\x16\x80a+yW`\x7F\x82\x16\x91P[` \x82\x10\x81\x03a+\x99WcNH{q`\xE0\x1B`\0R`\"`\x04R`$`\0\xFD[P\x91\x90PV[` \x80\x82R`1\x90\x82\x01R\x7FERC721: transfer caller is not o`@\x82\x01Rp\x1D\xDB\x99\\\x88\x1B\x9B\xDC\x88\x18\\\x1C\x1C\x9B\xDD\x99Y`z\x1B``\x82\x01R`\x80\x01\x90V[`\0\x83Qa,\x02\x81\x84` \x88\x01a&\x8CV[`/`\xF8\x1B\x90\x83\x01\x90\x81R\x83Qa, \x81`\x01\x84\x01` \x88\x01a&\x8CV[\x01`\x01\x01\x94\x93PPPPV[cNH{q`\xE0\x1B`\0R`2`\x04R`$`\0\xFD[`\0` \x82\x84\x03\x12\x15a,TW`\0\x80\xFD[PQ\x91\x90PV[`\x1F\x82\x11\x15a\x07\x8EW`\0\x81\x81R` \x81 `\x1F\x85\x01`\x05\x1C\x81\x01` \x86\x10\x15a,\x82WP\x80[`\x1F\x85\x01`\x05\x1C\x82\x01\x91P[\x81\x81\x10\x15a\x14zW\x82\x81U`\x01\x01a,\x8EV[\x81Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a,\xBBWa,\xBBa'\x8AV[a,\xCF\x81a,\xC9\x84Ta+eV[\x84a,[V[` \x80`\x1F\x83\x11`\x01\x81\x14a-\x04W`\0\x84\x15a,\xECWP\x85\x83\x01Q[`\0\x19`\x03\x86\x90\x1B\x1C\x19\x16`\x01\x85\x90\x1B\x17\x85Ua\x14zV[`\0\x85\x81R` \x81 `\x1F\x19\x86\x16\x91[\x82\x81\x10\x15a-3W\x88\x86\x01Q\x82U\x94\x84\x01\x94`\x01\x90\x91\x01\x90\x84\x01a-\x14V[P\x85\x82\x10\x15a-QW\x87\x85\x01Q`\0\x19`\x03\x88\x90\x1B`\xF8\x16\x1C\x19\x16\x81U[PPPPP`\x01\x90\x81\x1B\x01\x90UPV[\x83\x85\x827`\0\x84\x82\x01`/`\xF8\x1B\x81R\x83\x85`\x01\x83\x017`\0\x93\x01`\x01\x01\x92\x83RP\x90\x94\x93PPPPV[cNH{q`\xE0\x1B`\0R`\x11`\x04R`$`\0\xFD[`\0`\x01\x82\x01a-\xB4Wa-\xB4a-\x8CV[P`\x01\x01\x90V[\x81\x81\x03\x81\x81\x11\x15a\x05YWa\x05Ya-\x8CV[\x80\x82\x01\x80\x82\x11\x15a\x05YWa\x05Ya-\x8CV[\x7FAccessControl: account \0\0\0\0\0\0\0\0\0\x81R`\0\x83Qa.\x19\x81`\x17\x85\x01` \x88\x01a&\x8CV[p\x01\x03K\x99\x03kK\x9B\x9BKs9\x03\x93{c)`}\x1B`\x17\x91\x84\x01\x91\x82\x01R\x83Qa.J\x81`(\x84\x01` \x88\x01a&\x8CV[\x01`(\x01\x94\x93PPPPV[`\0\x82Qa.h\x81\x84` \x87\x01a&\x8CV[\x91\x90\x91\x01\x92\x91PPV[` \x80\x82R`2\x90\x82\x01R\x7FERC721: transfer to non ERC721Re`@\x82\x01Rq1\xB2\xB4\xBB2\xB9\x104\xB6\xB862\xB6\xB2\xB7:2\xB9`q\x1B``\x82\x01R`\x80\x01\x90V[`\0\x83Qa.\xD6\x81\x84` \x88\x01a&\x8CV[\x83Q\x90\x83\x01\x90a.\xEA\x81\x83` \x88\x01a&\x8CV[\x01\x94\x93PPPPV[\x80\x82\x02\x81\x15\x82\x82\x04\x84\x14\x17a\x05YWa\x05Ya-\x8CV[`\0\x81a/\x19Wa/\x19a-\x8CV[P`\0\x19\x01\x90V[`\0` \x82\x84\x03\x12\x15a/3W`\0\x80\xFD[\x81Qa\r6\x81a*zV[`\x01`\x01`\xA0\x1B\x03\x85\x81\x16\x82R\x84\x16` \x82\x01R`@\x81\x01\x83\x90R`\x80``\x82\x01\x81\x90R`\0\x90a/q\x90\x83\x01\x84a&\xB0V[\x96\x95PPPPPPV[`\0` \x82\x84\x03\x12\x15a/\x8DW`\0\x80\xFD[\x81Qa\r6\x81a&VV[cNH{q`\xE0\x1B`\0R`1`\x04R`$`\0\xFD[cNH{q`\xE0\x1B`\0R`\x12`\x04R`$`\0\xFD[`\0\x82a/\xD3Wa/\xD3a/\xAEV[P\x04\x90V[`\0\x82a/\xE7Wa/\xE7a/\xAEV[P\x06\x90V\xFE\xA2dipfsX\"\x12 m{\xDE\xEA\xFDk<\xBBC\x1FL|\"%\x04^\xD0\xE8\xE3\x9A6\x8F1\n'\xAEI_/\xC1\x0C\xDBdsolcC\0\x08\x13\x003",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x608060405234801561001057600080fd5b50600436106102065760003560e01c806370a082311161011a578063a22cb465116100ad578063c87b56dd1161007c578063c87b56dd14610498578063ca15c873146104ab578063d5391393146104be578063d547741f146104e5578063e985e9c5146104f857600080fd5b8063a22cb4651461044c578063b5185a881461045f578063b88d4fde14610472578063c588ff8b1461048557600080fd5b8063931688cb116100e9578063931688cb146104165780639365c5331461042957806395d89b411461043c578063a217fddf1461044457600080fd5b806370a082311461039b578063896cddf4146103ae5780639010d07c146103f057806391d148541461040357600080fd5b80632f2ff15d1161019d57806348c64e411161016c57806348c64e411461032f5780634f6ccce714610342578063562317c5146103555780636067bc15146103755780636352211e1461038857600080fd5b80632f2ff15d146102e35780632f745c59146102f657806336568abe1461030957806342842e0e1461031c57600080fd5b806318160ddd116101d957806318160ddd1461028857806323b872dd1461029a578063248a9ca3146102ad57806329867dac146102d057600080fd5b806301ffc9a71461020b57806306fdde0314610233578063081812fc14610248578063095ea7b314610273575b600080fd5b61021e61021936600461266f565b610534565b60405190151581526020015b60405180910390f35b61023b61055f565b60405161022a91906126dc565b61025b6102563660046126ef565b6105f1565b6040516001600160a01b03909116815260200161022a565b610286610281366004612724565b61067e565b005b600b545b60405190815260200161022a565b6102866102a836600461274e565b610793565b61028c6102bb3660046126ef565b60009081526020819052604090206001015490565b6102866102de366004612836565b6107c4565b6102866102f13660046128bc565b610876565b61028c610304366004612724565b61089c565b6102866103173660046128bc565b610932565b61028661032a36600461274e565b6109b0565b61028661033d366004612724565b6109cb565b61028c6103503660046126ef565b610aa4565b61028c6103633660046126ef565b60009081526013602052604090205490565b6102866103833660046128e8565b610b37565b61025b6103963660046126ef565b610c20565b61028c6103a93660046128e8565b610c97565b6103db6103bc3660046126ef565b6000908152601160209081526040808320546012909252909120549091565b6040805192835260208301919091520161022a565b61025b6103fe366004612903565b610d1e565b61021e6104113660046128bc565b610d3d565b610286610424366004612925565b610d66565b6102866104373660046129a3565b610d7e565b61023b610eeb565b61028c600081565b61028661045a366004612a88565b610efa565b61023b61046d3660046126ef565b610f05565b610286610480366004612abf565b610f12565b61023b6104933660046126ef565b610f4a565b61023b6104a63660046126ef565b610f68565b61028c6104b93660046126ef565b610f73565b61028c7f9f2df0fed2c77648de5860a4cc508cd0818c85b8b8a1ab4ceeef8d981c8956a681565b6102866104f33660046128bc565b610f8a565b61021e610506366004612b3b565b6001600160a01b03918216600090815260076020908152604080832093909416825291909152205460ff1690565b60006001600160e01b03198216630d639add60e11b1480610559575061055982610fb0565b92915050565b60606002805461056e90612b65565b80601f016020809104026020016040519081016040528092919081815260200182805461059a90612b65565b80156105e75780601f106105bc576101008083540402835291602001916105e7565b820191906000526020600020905b8154815290600101906020018083116105ca57829003601f168201915b5050505050905090565b60006105fc82610fd5565b6106625760405162461bcd60e51b815260206004820152602c60248201527f4552433732313a20617070726f76656420717565727920666f72206e6f6e657860448201526b34b9ba32b73a103a37b5b2b760a11b60648201526084015b60405180910390fd5b506000908152600660205260409020546001600160a01b031690565b600061068982610c20565b9050806001600160a01b0316836001600160a01b0316036106f65760405162461bcd60e51b815260206004820152602160248201527f4552433732313a20617070726f76616c20746f2063757272656e74206f776e656044820152603960f91b6064820152608401610659565b336001600160a01b038216148061071257506107128133610506565b6107845760405162461bcd60e51b815260206004820152603860248201527f4552433732313a20617070726f76652063616c6c6572206973206e6f74206f7760448201527f6e6572206e6f7220617070726f76656420666f7220616c6c00000000000000006064820152608401610659565b61078e8383610ff2565b505050565b61079d3382611060565b6107b95760405162461bcd60e51b815260040161065990612b9f565b61078e83838361114a565b7f9f2df0fed2c77648de5860a4cc508cd0818c85b8b8a1ab4ceeef8d981c8956a66107ef81336112f5565b6107fa600f86611359565b506000610808600f87611406565b90506000868660405160200161081f929190612bf0565b604051602081830303815290604052905061083d8886868585611431565b8385837f735e5eb5afdd72cc64657ded7e5de390af3708afb5b9a80b0e5c911a0499d98f60405160405180910390a45050505050505050565b60008281526020819052604090206001015461089281336112f5565b61078e8383611482565b60006108a783610c97565b82106109095760405162461bcd60e51b815260206004820152602b60248201527f455243373231456e756d657261626c653a206f776e657220696e646578206f7560448201526a74206f6620626f756e647360a81b6064820152608401610659565b506001600160a01b03919091166000908152600960209081526040808320938352929052205490565b6001600160a01b03811633146109a25760405162461bcd60e51b815260206004820152602f60248201527f416363657373436f6e74726f6c3a2063616e206f6e6c792072656e6f756e636560448201526e103937b632b9903337b91039b2b63360891b6064820152608401610659565b6109ac82826114a4565b5050565b61078e83838360405180602001604052806000815250610f12565b60006109d781336112f5565b6002600d5403610a295760405162461bcd60e51b815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c006044820152606401610659565b6002600d55604080516323b872dd60e01b81523060048201523360248201526044810184905290516001600160a01b038516916323b872dd91606480830192600092919082900301818387803b158015610a8257600080fd5b505af1158015610a96573d6000803e3d6000fd5b50506001600d555050505050565b6000610aaf600b5490565b8210610b125760405162461bcd60e51b815260206004820152602c60248201527f455243373231456e756d657261626c653a20676c6f62616c20696e646578206f60448201526b7574206f6620626f756e647360a01b6064820152608401610659565b600b8281548110610b2557610b25612c2c565b90600052602060002001549050919050565b6000610b4381336112f5565b6002600d5403610b955760405162461bcd60e51b815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c006044820152606401610659565b6002600d55610c17336040516370a0823160e01b81523060048201526001600160a01b038516906370a0823190602401602060405180830381865afa158015610be2573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c069190612c42565b6001600160a01b03851691906114c6565b50506001600d55565b6000818152600460205260408120546001600160a01b0316806105595760405162461bcd60e51b815260206004820152602960248201527f4552433732313a206f776e657220717565727920666f72206e6f6e657869737460448201526832b73a103a37b5b2b760b91b6064820152608401610659565b60006001600160a01b038216610d025760405162461bcd60e51b815260206004820152602a60248201527f4552433732313a2062616c616e636520717565727920666f7220746865207a65604482015269726f206164647265737360b01b6064820152608401610659565b506001600160a01b031660009081526005602052604090205490565b6000828152600160205260408120610d369083611518565b9392505050565b6000918252602082815260408084206001600160a01b0393909316845291905290205460ff1690565b6000610d7281336112f5565b600e61078e8382612ca1565b7f9f2df0fed2c77648de5860a4cc508cd0818c85b8b8a1ab4ceeef8d981c8956a6610da981336112f5565b610dec87878080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250600f939250506113599050565b506000610e3288888080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250600f939250506114069050565b9050600088888888604051602001610e4d9493929190612d61565b604051602081830303815290604052905060005b8a811015610eae57610e9c8c8c83818110610e7e57610e7e612c2c565b9050602002016020810190610e9391906128e8565b87878686611431565b80610ea681612da2565b915050610e61565b508385837f735e5eb5afdd72cc64657ded7e5de390af3708afb5b9a80b0e5c911a0499d98f60405160405180910390a45050505050505050505050565b60606003805461056e90612b65565b6109ac338383611524565b6060610559600f836115f2565b610f1c3383611060565b610f385760405162461bcd60e51b815260040161065990612b9f565b610f44848484846116ab565b50505050565b60008181526013602052604090205460609061055990600f906115f2565b6060610559826116de565b60008181526001602052604081206105599061183f565b600082815260208190526040902060010154610fa681336112f5565b61078e83836114a4565b60006001600160e01b0319821663780e9d6360e01b1480610559575061055982611849565b6000908152600460205260409020546001600160a01b0316151590565b600081815260066020526040902080546001600160a01b0319166001600160a01b038416908117909155819061102782610c20565b6001600160a01b03167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92560405160405180910390a45050565b600061106b82610fd5565b6110cc5760405162461bcd60e51b815260206004820152602c60248201527f4552433732313a206f70657261746f7220717565727920666f72206e6f6e657860448201526b34b9ba32b73a103a37b5b2b760a11b6064820152608401610659565b60006110d783610c20565b9050806001600160a01b0316846001600160a01b031614806111125750836001600160a01b0316611107846105f1565b6001600160a01b0316145b8061114257506001600160a01b0380821660009081526007602090815260408083209388168352929052205460ff165b949350505050565b826001600160a01b031661115d82610c20565b6001600160a01b0316146111c55760405162461bcd60e51b815260206004820152602960248201527f4552433732313a207472616e73666572206f6620746f6b656e2074686174206960448201526839903737ba1037bbb760b91b6064820152608401610659565b6001600160a01b0382166112275760405162461bcd60e51b8152602060048201526024808201527f4552433732313a207472616e7366657220746f20746865207a65726f206164646044820152637265737360e01b6064820152608401610659565b611232838383611889565b61123d600082610ff2565b6001600160a01b0383166000908152600560205260408120805460019290611266908490612dbb565b90915550506001600160a01b0382166000908152600560205260408120805460019290611294908490612dce565b909155505060008181526004602052604080822080546001600160a01b0319166001600160a01b0386811691821790925591518493918716917fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef91a4505050565b6112ff8282610d3d565b6109ac57611317816001600160a01b03166014611894565b611322836020611894565b604051602001611333929190612de1565b60408051601f198184030181529082905262461bcd60e51b8252610659916004016126dc565b60006113658383611a30565b6113fe578254600181018455600084815260209020016113858382612ca1565b508254604051600185019061139b908590612e56565b90815260200160405180910390208190555082600101826040516113bf9190612e56565b90815260405190819003602001812054907f11497a834951095469930ec62e1641f0dcf3617d9cd7579b6da76e54df3000a790600090a2506001610559565b506000610559565b6000826001018260405161141a9190612e56565b908152602001604051809103902054905092915050565b600061143c600b5490565b90506114488682611a5d565b6000818152601160209081526040808320889055601282528083208790556013909152902083905561147a8183611b9c565b505050505050565b61148c8282611c20565b600082815260016020526040902061078e9082611ca4565b6114ae8282611cb9565b600082815260016020526040902061078e9082611d1e565b604080516001600160a01b038416602482015260448082018490528251808303909101815260649091019091526020810180516001600160e01b031663a9059cbb60e01b17905261078e908490611d33565b6000610d368383611e05565b816001600160a01b0316836001600160a01b0316036115855760405162461bcd60e51b815260206004820152601960248201527f4552433732313a20617070726f766520746f2063616c6c6572000000000000006044820152606401610659565b6001600160a01b03838116600081815260076020908152604080832094871680845294825291829020805460ff191686151590811790915591519182527f17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31910160405180910390a3505050565b606082611600600184612dbb565b8154811061161057611610612c2c565b90600052602060002001805461162590612b65565b80601f016020809104026020016040519081016040528092919081815260200182805461165190612b65565b801561169e5780601f106116735761010080835404028352916020019161169e565b820191906000526020600020905b81548152906001019060200180831161168157829003601f168201915b5050505050905092915050565b6116b684848461114a565b6116c284848484611e2f565b610f445760405162461bcd60e51b815260040161065990612e72565b60606116e982610fd5565b61174f5760405162461bcd60e51b815260206004820152603160248201527f45524337323155524953746f726167653a2055524920717565727920666f72206044820152703737b732bc34b9ba32b73a103a37b5b2b760791b6064820152608401610659565b6000828152600860205260408120805461176890612b65565b80601f016020809104026020016040519081016040528092919081815260200182805461179490612b65565b80156117e15780601f106117b6576101008083540402835291602001916117e1565b820191906000526020600020905b8154815290600101906020018083116117c457829003601f168201915b5050505050905060006117f2611f30565b90508051600003611804575092915050565b81511561183657808260405160200161181e929190612ec4565b60405160208183030381529060405292505050919050565b61114284611f3f565b6000610559825490565b60006001600160e01b031982166380ac58cd60e01b148061187a57506001600160e01b03198216635b5e139f60e01b145b80610559575061055982612009565b61078e83838361202e565b606060006118a3836002612ef3565b6118ae906002612dce565b67ffffffffffffffff8111156118c6576118c661278a565b6040519080825280601f01601f1916602001820160405280156118f0576020820181803683370190505b509050600360fc1b8160008151811061190b5761190b612c2c565b60200101906001600160f81b031916908160001a905350600f60fb1b8160018151811061193a5761193a612c2c565b60200101906001600160f81b031916908160001a905350600061195e846002612ef3565b611969906001612dce565b90505b60018111156119e1576f181899199a1a9b1b9c1cb0b131b232b360811b85600f166010811061199d5761199d612c2c565b1a60f81b8282815181106119b3576119b3612c2c565b60200101906001600160f81b031916908160001a90535060049490941c936119da81612f0a565b905061196c565b508315610d365760405162461bcd60e51b815260206004820181905260248201527f537472696e67733a20686578206c656e67746820696e73756666696369656e746044820152606401610659565b60008260010182604051611a449190612e56565b9081526040519081900360200190205415159392505050565b6001600160a01b038216611ab35760405162461bcd60e51b815260206004820181905260248201527f4552433732313a206d696e7420746f20746865207a65726f20616464726573736044820152606401610659565b611abc81610fd5565b15611b095760405162461bcd60e51b815260206004820152601c60248201527f4552433732313a20746f6b656e20616c7265616479206d696e746564000000006044820152606401610659565b611b1560008383611889565b6001600160a01b0382166000908152600560205260408120805460019290611b3e908490612dce565b909155505060008181526004602052604080822080546001600160a01b0319166001600160a01b03861690811790915590518392907fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef908290a45050565b611ba582610fd5565b611c085760405162461bcd60e51b815260206004820152602e60248201527f45524337323155524953746f726167653a2055524920736574206f66206e6f6e60448201526d32bc34b9ba32b73a103a37b5b2b760911b6064820152608401610659565b600082815260086020526040902061078e8282612ca1565b611c2a8282610d3d565b6109ac576000828152602081815260408083206001600160a01b03851684529091529020805460ff19166001179055611c603390565b6001600160a01b0316816001600160a01b0316837f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d60405160405180910390a45050565b6000610d36836001600160a01b0384166120e6565b611cc38282610d3d565b156109ac576000828152602081815260408083206001600160a01b0385168085529252808320805460ff1916905551339285917ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b9190a45050565b6000610d36836001600160a01b03841661212d565b6000611d88826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b03166122209092919063ffffffff16565b80519091501561078e5780806020019051810190611da69190612f21565b61078e5760405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e6044820152691bdd081cdd58d8d9595960b21b6064820152608401610659565b6000826000018281548110611e1c57611e1c612c2c565b9060005260206000200154905092915050565b60006001600160a01b0384163b15611f2557604051630a85bd0160e11b81526001600160a01b0385169063150b7a0290611e73903390899088908890600401612f3e565b6020604051808303816000875af1925050508015611eae575060408051601f3d908101601f19168201909252611eab91810190612f7b565b60015b611f0b573d808015611edc576040519150601f19603f3d011682016040523d82523d6000602084013e611ee1565b606091505b508051600003611f035760405162461bcd60e51b815260040161065990612e72565b805181602001fd5b6001600160e01b031916630a85bd0160e11b149050611142565b506001949350505050565b6060600e805461056e90612b65565b6060611f4a82610fd5565b611fae5760405162461bcd60e51b815260206004820152602f60248201527f4552433732314d657461646174613a2055524920717565727920666f72206e6f60448201526e3732bc34b9ba32b73a103a37b5b2b760891b6064820152608401610659565b6000611fb8611f30565b90506000815111611fd85760405180602001604052806000815250610d36565b80611fe28461222f565b604051602001611ff3929190612ec4565b6040516020818303038152906040529392505050565b60006001600160e01b03198216635a05180f60e01b1480610559575061055982612330565b6001600160a01b0383166120895761208481600b80546000838152600c60205260408120829055600182018355919091527f0175b7a638427703f0dbe7bb9bbf987a2551717b34e79f33b5b1008d1fa01db90155565b6120ac565b816001600160a01b0316836001600160a01b0316146120ac576120ac8382612365565b6001600160a01b0382166120c35761078e81612402565b826001600160a01b0316826001600160a01b03161461078e5761078e82826124b1565b60008181526001830160205260408120546113fe57508154600181810184556000848152602080822090930184905584548482528286019093526040902091909155610559565b60008181526001830160205260408120548015612216576000612151600183612dbb565b855490915060009061216590600190612dbb565b90508181146121ca57600086600001828154811061218557612185612c2c565b90600052602060002001549050808760000184815481106121a8576121a8612c2c565b6000918252602080832090910192909255918252600188019052604090208390555b85548690806121db576121db612f98565b600190038181906000526020600020016000905590558560010160008681526020019081526020016000206000905560019350505050610559565b6000915050610559565b606061114284846000856124f5565b6060816000036122565750506040805180820190915260018152600360fc1b602082015290565b8160005b8115612280578061226a81612da2565b91506122799050600a83612fc4565b915061225a565b60008167ffffffffffffffff81111561229b5761229b61278a565b6040519080825280601f01601f1916602001820160405280156122c5576020820181803683370190505b5090505b8415611142576122da600183612dbb565b91506122e7600a86612fd8565b6122f2906030612dce565b60f81b81838151811061230757612307612c2c565b60200101906001600160f81b031916908160001a905350612329600a86612fc4565b94506122c9565b60006001600160e01b03198216637965db0b60e01b148061055957506301ffc9a760e01b6001600160e01b0319831614610559565b6000600161237284610c97565b61237c9190612dbb565b6000838152600a60205260409020549091508082146123cf576001600160a01b03841660009081526009602090815260408083208584528252808320548484528184208190558352600a90915290208190555b506000918252600a602090815260408084208490556001600160a01b039094168352600981528383209183525290812055565b600b5460009061241490600190612dbb565b6000838152600c6020526040812054600b805493945090928490811061243c5761243c612c2c565b9060005260206000200154905080600b838154811061245d5761245d612c2c565b6000918252602080832090910192909255828152600c9091526040808220849055858252812055600b80548061249557612495612f98565b6001900381819060005260206000200160009055905550505050565b60006124bc83610c97565b6001600160a01b0390931660009081526009602090815260408083208684528252808320859055938252600a9052919091209190915550565b6060824710156125565760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f6044820152651c8818d85b1b60d21b6064820152608401610659565b843b6125a45760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e74726163740000006044820152606401610659565b600080866001600160a01b031685876040516125c09190612e56565b60006040518083038185875af1925050503d80600081146125fd576040519150601f19603f3d011682016040523d82523d6000602084013e612602565b606091505b509150915061261282828661261d565b979650505050505050565b6060831561262c575081610d36565b82511561263c5782518084602001fd5b8160405162461bcd60e51b815260040161065991906126dc565b6001600160e01b03198116811461266c57600080fd5b50565b60006020828403121561268157600080fd5b8135610d3681612656565b60005b838110156126a757818101518382015260200161268f565b50506000910152565b600081518084526126c881602086016020860161268c565b601f01601f19169290920160200192915050565b602081526000610d3660208301846126b0565b60006020828403121561270157600080fd5b5035919050565b80356001600160a01b038116811461271f57600080fd5b919050565b6000806040838503121561273757600080fd5b61274083612708565b946020939093013593505050565b60008060006060848603121561276357600080fd5b61276c84612708565b925061277a60208501612708565b9150604084013590509250925092565b634e487b7160e01b600052604160045260246000fd5b600067ffffffffffffffff808411156127bb576127bb61278a565b604051601f8501601f19908116603f011681019082821181831017156127e3576127e361278a565b816040528093508581528686860111156127fc57600080fd5b858560208301376000602087830101525050509392505050565b600082601f83011261282757600080fd5b610d36838335602085016127a0565b600080600080600060a0868803121561284e57600080fd5b61285786612708565b9450602086013567ffffffffffffffff8082111561287457600080fd5b61288089838a01612816565b9550604088013591508082111561289657600080fd5b506128a388828901612816565b9598949750949560608101359550608001359392505050565b600080604083850312156128cf57600080fd5b823591506128df60208401612708565b90509250929050565b6000602082840312156128fa57600080fd5b610d3682612708565b6000806040838503121561291657600080fd5b50508035926020909101359150565b60006020828403121561293757600080fd5b813567ffffffffffffffff81111561294e57600080fd5b61114284828501612816565b60008083601f84011261296c57600080fd5b50813567ffffffffffffffff81111561298457600080fd5b60208301915083602082850101111561299c57600080fd5b9250929050565b60008060008060008060008060a0898b0312156129bf57600080fd5b883567ffffffffffffffff808211156129d757600080fd5b818b0191508b601f8301126129eb57600080fd5b8135818111156129fa57600080fd5b8c60208260051b8501011115612a0f57600080fd5b60209283019a509850908a01359080821115612a2a57600080fd5b612a368c838d0161295a565b909850965060408b0135915080821115612a4f57600080fd5b50612a5c8b828c0161295a565b999c989b509699959896976060870135966080013595509350505050565b801515811461266c57600080fd5b60008060408385031215612a9b57600080fd5b612aa483612708565b91506020830135612ab481612a7a565b809150509250929050565b60008060008060808587031215612ad557600080fd5b612ade85612708565b9350612aec60208601612708565b925060408501359150606085013567ffffffffffffffff811115612b0f57600080fd5b8501601f81018713612b2057600080fd5b612b2f878235602084016127a0565b91505092959194509250565b60008060408385031215612b4e57600080fd5b612b5783612708565b91506128df60208401612708565b600181811c90821680612b7957607f821691505b602082108103612b9957634e487b7160e01b600052602260045260246000fd5b50919050565b60208082526031908201527f4552433732313a207472616e736665722063616c6c6572206973206e6f74206f6040820152701ddb995c881b9bdc88185c1c1c9bdd9959607a1b606082015260800190565b60008351612c0281846020880161268c565b602f60f81b9083019081528351612c2081600184016020880161268c565b01600101949350505050565b634e487b7160e01b600052603260045260246000fd5b600060208284031215612c5457600080fd5b5051919050565b601f82111561078e57600081815260208120601f850160051c81016020861015612c825750805b601f850160051c820191505b8181101561147a57828155600101612c8e565b815167ffffffffffffffff811115612cbb57612cbb61278a565b612ccf81612cc98454612b65565b84612c5b565b602080601f831160018114612d045760008415612cec5750858301515b600019600386901b1c1916600185901b17855561147a565b600085815260208120601f198616915b82811015612d3357888601518255948401946001909101908401612d14565b5085821015612d515787850151600019600388901b60f8161c191681555b5050505050600190811b01905550565b838582376000848201602f60f81b815283856001830137600093016001019283525090949350505050565b634e487b7160e01b600052601160045260246000fd5b600060018201612db457612db4612d8c565b5060010190565b8181038181111561055957610559612d8c565b8082018082111561055957610559612d8c565b7f416363657373436f6e74726f6c3a206163636f756e7420000000000000000000815260008351612e1981601785016020880161268c565b7001034b99036b4b9b9b4b733903937b6329607d1b6017918401918201528351612e4a81602884016020880161268c565b01602801949350505050565b60008251612e6881846020870161268c565b9190910192915050565b60208082526032908201527f4552433732313a207472616e7366657220746f206e6f6e20455243373231526560408201527131b2b4bb32b91034b6b83632b6b2b73a32b960711b606082015260800190565b60008351612ed681846020880161268c565b835190830190612eea81836020880161268c565b01949350505050565b808202811582820484141761055957610559612d8c565b600081612f1957612f19612d8c565b506000190190565b600060208284031215612f3357600080fd5b8151610d3681612a7a565b6001600160a01b0385811682528416602082015260408101839052608060608201819052600090612f71908301846126b0565b9695505050505050565b600060208284031215612f8d57600080fd5b8151610d3681612656565b634e487b7160e01b600052603160045260246000fd5b634e487b7160e01b600052601260045260246000fd5b600082612fd357612fd3612fae565b500490565b600082612fe757612fe7612fae565b50069056fea26469706673582212206d7bdeeafd6b3cbb431f4c7c2225045ed0e8e39a368f310a27ae495f2fc10cdb64736f6c63430008130033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R4\x80\x15a\0\x10W`\0\x80\xFD[P`\x046\x10a\x02\x06W`\x005`\xE0\x1C\x80cp\xA0\x821\x11a\x01\x1AW\x80c\xA2,\xB4e\x11a\0\xADW\x80c\xC8{V\xDD\x11a\0|W\x80c\xC8{V\xDD\x14a\x04\x98W\x80c\xCA\x15\xC8s\x14a\x04\xABW\x80c\xD59\x13\x93\x14a\x04\xBEW\x80c\xD5Gt\x1F\x14a\x04\xE5W\x80c\xE9\x85\xE9\xC5\x14a\x04\xF8W`\0\x80\xFD[\x80c\xA2,\xB4e\x14a\x04LW\x80c\xB5\x18Z\x88\x14a\x04_W\x80c\xB8\x8DO\xDE\x14a\x04rW\x80c\xC5\x88\xFF\x8B\x14a\x04\x85W`\0\x80\xFD[\x80c\x93\x16\x88\xCB\x11a\0\xE9W\x80c\x93\x16\x88\xCB\x14a\x04\x16W\x80c\x93e\xC53\x14a\x04)W\x80c\x95\xD8\x9BA\x14a\x04<W\x80c\xA2\x17\xFD\xDF\x14a\x04DW`\0\x80\xFD[\x80cp\xA0\x821\x14a\x03\x9BW\x80c\x89l\xDD\xF4\x14a\x03\xAEW\x80c\x90\x10\xD0|\x14a\x03\xF0W\x80c\x91\xD1HT\x14a\x04\x03W`\0\x80\xFD[\x80c//\xF1]\x11a\x01\x9DW\x80cH\xC6NA\x11a\x01lW\x80cH\xC6NA\x14a\x03/W\x80cOl\xCC\xE7\x14a\x03BW\x80cV#\x17\xC5\x14a\x03UW\x80c`g\xBC\x15\x14a\x03uW\x80ccR!\x1E\x14a\x03\x88W`\0\x80\xFD[\x80c//\xF1]\x14a\x02\xE3W\x80c/t\\Y\x14a\x02\xF6W\x80c6V\x8A\xBE\x14a\x03\tW\x80cB\x84.\x0E\x14a\x03\x1CW`\0\x80\xFD[\x80c\x18\x16\r\xDD\x11a\x01\xD9W\x80c\x18\x16\r\xDD\x14a\x02\x88W\x80c#\xB8r\xDD\x14a\x02\x9AW\x80c$\x8A\x9C\xA3\x14a\x02\xADW\x80c)\x86}\xAC\x14a\x02\xD0W`\0\x80\xFD[\x80c\x01\xFF\xC9\xA7\x14a\x02\x0BW\x80c\x06\xFD\xDE\x03\x14a\x023W\x80c\x08\x18\x12\xFC\x14a\x02HW\x80c\t^\xA7\xB3\x14a\x02sW[`\0\x80\xFD[a\x02\x1Ea\x02\x196`\x04a&oV[a\x054V[`@Q\x90\x15\x15\x81R` \x01[`@Q\x80\x91\x03\x90\xF3[a\x02;a\x05_V[`@Qa\x02*\x91\x90a&\xDCV[a\x02[a\x02V6`\x04a&\xEFV[a\x05\xF1V[`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R` \x01a\x02*V[a\x02\x86a\x02\x816`\x04a'$V[a\x06~V[\0[`\x0BT[`@Q\x90\x81R` \x01a\x02*V[a\x02\x86a\x02\xA86`\x04a'NV[a\x07\x93V[a\x02\x8Ca\x02\xBB6`\x04a&\xEFV[`\0\x90\x81R` \x81\x90R`@\x90 `\x01\x01T\x90V[a\x02\x86a\x02\xDE6`\x04a(6V[a\x07\xC4V[a\x02\x86a\x02\xF16`\x04a(\xBCV[a\x08vV[a\x02\x8Ca\x03\x046`\x04a'$V[a\x08\x9CV[a\x02\x86a\x03\x176`\x04a(\xBCV[a\t2V[a\x02\x86a\x03*6`\x04a'NV[a\t\xB0V[a\x02\x86a\x03=6`\x04a'$V[a\t\xCBV[a\x02\x8Ca\x03P6`\x04a&\xEFV[a\n\xA4V[a\x02\x8Ca\x03c6`\x04a&\xEFV[`\0\x90\x81R`\x13` R`@\x90 T\x90V[a\x02\x86a\x03\x836`\x04a(\xE8V[a\x0B7V[a\x02[a\x03\x966`\x04a&\xEFV[a\x0C V[a\x02\x8Ca\x03\xA96`\x04a(\xE8V[a\x0C\x97V[a\x03\xDBa\x03\xBC6`\x04a&\xEFV[`\0\x90\x81R`\x11` \x90\x81R`@\x80\x83 T`\x12\x90\x92R\x90\x91 T\x90\x91V[`@\x80Q\x92\x83R` \x83\x01\x91\x90\x91R\x01a\x02*V[a\x02[a\x03\xFE6`\x04a)\x03V[a\r\x1EV[a\x02\x1Ea\x04\x116`\x04a(\xBCV[a\r=V[a\x02\x86a\x04$6`\x04a)%V[a\rfV[a\x02\x86a\x0476`\x04a)\xA3V[a\r~V[a\x02;a\x0E\xEBV[a\x02\x8C`\0\x81V[a\x02\x86a\x04Z6`\x04a*\x88V[a\x0E\xFAV[a\x02;a\x04m6`\x04a&\xEFV[a\x0F\x05V[a\x02\x86a\x04\x806`\x04a*\xBFV[a\x0F\x12V[a\x02;a\x04\x936`\x04a&\xEFV[a\x0FJV[a\x02;a\x04\xA66`\x04a&\xEFV[a\x0FhV[a\x02\x8Ca\x04\xB96`\x04a&\xEFV[a\x0FsV[a\x02\x8C\x7F\x9F-\xF0\xFE\xD2\xC7vH\xDEX`\xA4\xCCP\x8C\xD0\x81\x8C\x85\xB8\xB8\xA1\xABL\xEE\xEF\x8D\x98\x1C\x89V\xA6\x81V[a\x02\x86a\x04\xF36`\x04a(\xBCV[a\x0F\x8AV[a\x02\x1Ea\x05\x066`\x04a+;V[`\x01`\x01`\xA0\x1B\x03\x91\x82\x16`\0\x90\x81R`\x07` \x90\x81R`@\x80\x83 \x93\x90\x94\x16\x82R\x91\x90\x91R T`\xFF\x16\x90V[`\0`\x01`\x01`\xE0\x1B\x03\x19\x82\x16c\rc\x9A\xDD`\xE1\x1B\x14\x80a\x05YWPa\x05Y\x82a\x0F\xB0V[\x92\x91PPV[```\x02\x80Ta\x05n\x90a+eV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x05\x9A\x90a+eV[\x80\x15a\x05\xE7W\x80`\x1F\x10a\x05\xBCWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x05\xE7V[\x82\x01\x91\x90`\0R` `\0 \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x05\xCAW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x90P\x90V[`\0a\x05\xFC\x82a\x0F\xD5V[a\x06bW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`,`$\x82\x01R\x7FERC721: approved query for nonex`D\x82\x01Rk4\xB9\xBA2\xB7:\x10:7\xB5\xB2\xB7`\xA1\x1B`d\x82\x01R`\x84\x01[`@Q\x80\x91\x03\x90\xFD[P`\0\x90\x81R`\x06` R`@\x90 T`\x01`\x01`\xA0\x1B\x03\x16\x90V[`\0a\x06\x89\x82a\x0C V[\x90P\x80`\x01`\x01`\xA0\x1B\x03\x16\x83`\x01`\x01`\xA0\x1B\x03\x16\x03a\x06\xF6W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`!`$\x82\x01R\x7FERC721: approval to current owne`D\x82\x01R`9`\xF9\x1B`d\x82\x01R`\x84\x01a\x06YV[3`\x01`\x01`\xA0\x1B\x03\x82\x16\x14\x80a\x07\x12WPa\x07\x12\x813a\x05\x06V[a\x07\x84W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`8`$\x82\x01R\x7FERC721: approve caller is not ow`D\x82\x01R\x7Fner nor approved for all\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x06YV[a\x07\x8E\x83\x83a\x0F\xF2V[PPPV[a\x07\x9D3\x82a\x10`V[a\x07\xB9W`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x06Y\x90a+\x9FV[a\x07\x8E\x83\x83\x83a\x11JV[\x7F\x9F-\xF0\xFE\xD2\xC7vH\xDEX`\xA4\xCCP\x8C\xD0\x81\x8C\x85\xB8\xB8\xA1\xABL\xEE\xEF\x8D\x98\x1C\x89V\xA6a\x07\xEF\x813a\x12\xF5V[a\x07\xFA`\x0F\x86a\x13YV[P`\0a\x08\x08`\x0F\x87a\x14\x06V[\x90P`\0\x86\x86`@Q` \x01a\x08\x1F\x92\x91\x90a+\xF0V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x90Pa\x08=\x88\x86\x86\x85\x85a\x141V[\x83\x85\x83\x7Fs^^\xB5\xAF\xDDr\xCCde}\xED~]\xE3\x90\xAF7\x08\xAF\xB5\xB9\xA8\x0B\x0E\\\x91\x1A\x04\x99\xD9\x8F`@Q`@Q\x80\x91\x03\x90\xA4PPPPPPPPV[`\0\x82\x81R` \x81\x90R`@\x90 `\x01\x01Ta\x08\x92\x813a\x12\xF5V[a\x07\x8E\x83\x83a\x14\x82V[`\0a\x08\xA7\x83a\x0C\x97V[\x82\x10a\t\tW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`+`$\x82\x01R\x7FERC721Enumerable: owner index ou`D\x82\x01Rjt of bounds`\xA8\x1B`d\x82\x01R`\x84\x01a\x06YV[P`\x01`\x01`\xA0\x1B\x03\x91\x90\x91\x16`\0\x90\x81R`\t` \x90\x81R`@\x80\x83 \x93\x83R\x92\x90R T\x90V[`\x01`\x01`\xA0\x1B\x03\x81\x163\x14a\t\xA2W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`/`$\x82\x01R\x7FAccessControl: can only renounce`D\x82\x01Rn\x1097\xB62\xB9\x9037\xB9\x109\xB2\xB63`\x89\x1B`d\x82\x01R`\x84\x01a\x06YV[a\t\xAC\x82\x82a\x14\xA4V[PPV[a\x07\x8E\x83\x83\x83`@Q\x80` \x01`@R\x80`\0\x81RPa\x0F\x12V[`\0a\t\xD7\x813a\x12\xF5V[`\x02`\rT\x03a\n)W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1F`$\x82\x01R\x7FReentrancyGuard: reentrant call\0`D\x82\x01R`d\x01a\x06YV[`\x02`\rU`@\x80Qc#\xB8r\xDD`\xE0\x1B\x81R0`\x04\x82\x01R3`$\x82\x01R`D\x81\x01\x84\x90R\x90Q`\x01`\x01`\xA0\x1B\x03\x85\x16\x91c#\xB8r\xDD\x91`d\x80\x83\x01\x92`\0\x92\x91\x90\x82\x90\x03\x01\x81\x83\x87\x80;\x15\x80\x15a\n\x82W`\0\x80\xFD[PZ\xF1\x15\x80\x15a\n\x96W=`\0\x80>=`\0\xFD[PP`\x01`\rUPPPPPV[`\0a\n\xAF`\x0BT\x90V[\x82\x10a\x0B\x12W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`,`$\x82\x01R\x7FERC721Enumerable: global index o`D\x82\x01Rkut of bounds`\xA0\x1B`d\x82\x01R`\x84\x01a\x06YV[`\x0B\x82\x81T\x81\x10a\x0B%Wa\x0B%a,,V[\x90`\0R` `\0 \x01T\x90P\x91\x90PV[`\0a\x0BC\x813a\x12\xF5V[`\x02`\rT\x03a\x0B\x95W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1F`$\x82\x01R\x7FReentrancyGuard: reentrant call\0`D\x82\x01R`d\x01a\x06YV[`\x02`\rUa\x0C\x173`@Qcp\xA0\x821`\xE0\x1B\x81R0`\x04\x82\x01R`\x01`\x01`\xA0\x1B\x03\x85\x16\x90cp\xA0\x821\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x0B\xE2W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x0C\x06\x91\x90a,BV[`\x01`\x01`\xA0\x1B\x03\x85\x16\x91\x90a\x14\xC6V[PP`\x01`\rUV[`\0\x81\x81R`\x04` R`@\x81 T`\x01`\x01`\xA0\x1B\x03\x16\x80a\x05YW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`)`$\x82\x01R\x7FERC721: owner query for nonexist`D\x82\x01Rh2\xB7:\x10:7\xB5\xB2\xB7`\xB9\x1B`d\x82\x01R`\x84\x01a\x06YV[`\0`\x01`\x01`\xA0\x1B\x03\x82\x16a\r\x02W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`*`$\x82\x01R\x7FERC721: balance query for the ze`D\x82\x01Riro address`\xB0\x1B`d\x82\x01R`\x84\x01a\x06YV[P`\x01`\x01`\xA0\x1B\x03\x16`\0\x90\x81R`\x05` R`@\x90 T\x90V[`\0\x82\x81R`\x01` R`@\x81 a\r6\x90\x83a\x15\x18V[\x93\x92PPPV[`\0\x91\x82R` \x82\x81R`@\x80\x84 `\x01`\x01`\xA0\x1B\x03\x93\x90\x93\x16\x84R\x91\x90R\x90 T`\xFF\x16\x90V[`\0a\rr\x813a\x12\xF5V[`\x0Ea\x07\x8E\x83\x82a,\xA1V[\x7F\x9F-\xF0\xFE\xD2\xC7vH\xDEX`\xA4\xCCP\x8C\xD0\x81\x8C\x85\xB8\xB8\xA1\xABL\xEE\xEF\x8D\x98\x1C\x89V\xA6a\r\xA9\x813a\x12\xF5V[a\r\xEC\x87\x87\x80\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83\x80\x82\x847`\0\x92\x01\x91\x90\x91RP`\x0F\x93\x92PPa\x13Y\x90PV[P`\0a\x0E2\x88\x88\x80\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83\x80\x82\x847`\0\x92\x01\x91\x90\x91RP`\x0F\x93\x92PPa\x14\x06\x90PV[\x90P`\0\x88\x88\x88\x88`@Q` \x01a\x0EM\x94\x93\x92\x91\x90a-aV[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x90P`\0[\x8A\x81\x10\x15a\x0E\xAEWa\x0E\x9C\x8C\x8C\x83\x81\x81\x10a\x0E~Wa\x0E~a,,V[\x90P` \x02\x01` \x81\x01\x90a\x0E\x93\x91\x90a(\xE8V[\x87\x87\x86\x86a\x141V[\x80a\x0E\xA6\x81a-\xA2V[\x91PPa\x0EaV[P\x83\x85\x83\x7Fs^^\xB5\xAF\xDDr\xCCde}\xED~]\xE3\x90\xAF7\x08\xAF\xB5\xB9\xA8\x0B\x0E\\\x91\x1A\x04\x99\xD9\x8F`@Q`@Q\x80\x91\x03\x90\xA4PPPPPPPPPPPV[```\x03\x80Ta\x05n\x90a+eV[a\t\xAC3\x83\x83a\x15$V[``a\x05Y`\x0F\x83a\x15\xF2V[a\x0F\x1C3\x83a\x10`V[a\x0F8W`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x06Y\x90a+\x9FV[a\x0FD\x84\x84\x84\x84a\x16\xABV[PPPPV[`\0\x81\x81R`\x13` R`@\x90 T``\x90a\x05Y\x90`\x0F\x90a\x15\xF2V[``a\x05Y\x82a\x16\xDEV[`\0\x81\x81R`\x01` R`@\x81 a\x05Y\x90a\x18?V[`\0\x82\x81R` \x81\x90R`@\x90 `\x01\x01Ta\x0F\xA6\x813a\x12\xF5V[a\x07\x8E\x83\x83a\x14\xA4V[`\0`\x01`\x01`\xE0\x1B\x03\x19\x82\x16cx\x0E\x9Dc`\xE0\x1B\x14\x80a\x05YWPa\x05Y\x82a\x18IV[`\0\x90\x81R`\x04` R`@\x90 T`\x01`\x01`\xA0\x1B\x03\x16\x15\x15\x90V[`\0\x81\x81R`\x06` R`@\x90 \x80T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x84\x16\x90\x81\x17\x90\x91U\x81\x90a\x10'\x82a\x0C V[`\x01`\x01`\xA0\x1B\x03\x16\x7F\x8C[\xE1\xE5\xEB\xEC}[\xD1OqB}\x1E\x84\xF3\xDD\x03\x14\xC0\xF7\xB2)\x1E[ \n\xC8\xC7\xC3\xB9%`@Q`@Q\x80\x91\x03\x90\xA4PPV[`\0a\x10k\x82a\x0F\xD5V[a\x10\xCCW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`,`$\x82\x01R\x7FERC721: operator query for nonex`D\x82\x01Rk4\xB9\xBA2\xB7:\x10:7\xB5\xB2\xB7`\xA1\x1B`d\x82\x01R`\x84\x01a\x06YV[`\0a\x10\xD7\x83a\x0C V[\x90P\x80`\x01`\x01`\xA0\x1B\x03\x16\x84`\x01`\x01`\xA0\x1B\x03\x16\x14\x80a\x11\x12WP\x83`\x01`\x01`\xA0\x1B\x03\x16a\x11\x07\x84a\x05\xF1V[`\x01`\x01`\xA0\x1B\x03\x16\x14[\x80a\x11BWP`\x01`\x01`\xA0\x1B\x03\x80\x82\x16`\0\x90\x81R`\x07` \x90\x81R`@\x80\x83 \x93\x88\x16\x83R\x92\x90R T`\xFF\x16[\x94\x93PPPPV[\x82`\x01`\x01`\xA0\x1B\x03\x16a\x11]\x82a\x0C V[`\x01`\x01`\xA0\x1B\x03\x16\x14a\x11\xC5W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`)`$\x82\x01R\x7FERC721: transfer of token that i`D\x82\x01Rh9\x9077\xBA\x107\xBB\xB7`\xB9\x1B`d\x82\x01R`\x84\x01a\x06YV[`\x01`\x01`\xA0\x1B\x03\x82\x16a\x12'W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`$\x80\x82\x01R\x7FERC721: transfer to the zero add`D\x82\x01Rcress`\xE0\x1B`d\x82\x01R`\x84\x01a\x06YV[a\x122\x83\x83\x83a\x18\x89V[a\x12=`\0\x82a\x0F\xF2V[`\x01`\x01`\xA0\x1B\x03\x83\x16`\0\x90\x81R`\x05` R`@\x81 \x80T`\x01\x92\x90a\x12f\x90\x84\x90a-\xBBV[\x90\x91UPP`\x01`\x01`\xA0\x1B\x03\x82\x16`\0\x90\x81R`\x05` R`@\x81 \x80T`\x01\x92\x90a\x12\x94\x90\x84\x90a-\xCEV[\x90\x91UPP`\0\x81\x81R`\x04` R`@\x80\x82 \x80T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x86\x81\x16\x91\x82\x17\x90\x92U\x91Q\x84\x93\x91\x87\x16\x91\x7F\xDD\xF2R\xAD\x1B\xE2\xC8\x9Bi\xC2\xB0h\xFC7\x8D\xAA\x95+\xA7\xF1c\xC4\xA1\x16(\xF5ZM\xF5#\xB3\xEF\x91\xA4PPPV[a\x12\xFF\x82\x82a\r=V[a\t\xACWa\x13\x17\x81`\x01`\x01`\xA0\x1B\x03\x16`\x14a\x18\x94V[a\x13\"\x83` a\x18\x94V[`@Q` \x01a\x133\x92\x91\x90a-\xE1V[`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x90\x82\x90RbF\x1B\xCD`\xE5\x1B\x82Ra\x06Y\x91`\x04\x01a&\xDCV[`\0a\x13e\x83\x83a\x1A0V[a\x13\xFEW\x82T`\x01\x81\x01\x84U`\0\x84\x81R` \x90 \x01a\x13\x85\x83\x82a,\xA1V[P\x82T`@Q`\x01\x85\x01\x90a\x13\x9B\x90\x85\x90a.VV[\x90\x81R` \x01`@Q\x80\x91\x03\x90 \x81\x90UP\x82`\x01\x01\x82`@Qa\x13\xBF\x91\x90a.VV[\x90\x81R`@Q\x90\x81\x90\x03` \x01\x81 T\x90\x7F\x11Iz\x83IQ\tTi\x93\x0E\xC6.\x16A\xF0\xDC\xF3a}\x9C\xD7W\x9Bm\xA7nT\xDF0\0\xA7\x90`\0\x90\xA2P`\x01a\x05YV[P`\0a\x05YV[`\0\x82`\x01\x01\x82`@Qa\x14\x1A\x91\x90a.VV[\x90\x81R` \x01`@Q\x80\x91\x03\x90 T\x90P\x92\x91PPV[`\0a\x14<`\x0BT\x90V[\x90Pa\x14H\x86\x82a\x1A]V[`\0\x81\x81R`\x11` \x90\x81R`@\x80\x83 \x88\x90U`\x12\x82R\x80\x83 \x87\x90U`\x13\x90\x91R\x90 \x83\x90Ua\x14z\x81\x83a\x1B\x9CV[PPPPPPV[a\x14\x8C\x82\x82a\x1C V[`\0\x82\x81R`\x01` R`@\x90 a\x07\x8E\x90\x82a\x1C\xA4V[a\x14\xAE\x82\x82a\x1C\xB9V[`\0\x82\x81R`\x01` R`@\x90 a\x07\x8E\x90\x82a\x1D\x1EV[`@\x80Q`\x01`\x01`\xA0\x1B\x03\x84\x16`$\x82\x01R`D\x80\x82\x01\x84\x90R\x82Q\x80\x83\x03\x90\x91\x01\x81R`d\x90\x91\x01\x90\x91R` \x81\x01\x80Q`\x01`\x01`\xE0\x1B\x03\x16c\xA9\x05\x9C\xBB`\xE0\x1B\x17\x90Ra\x07\x8E\x90\x84\x90a\x1D3V[`\0a\r6\x83\x83a\x1E\x05V[\x81`\x01`\x01`\xA0\x1B\x03\x16\x83`\x01`\x01`\xA0\x1B\x03\x16\x03a\x15\x85W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x19`$\x82\x01R\x7FERC721: approve to caller\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x06YV[`\x01`\x01`\xA0\x1B\x03\x83\x81\x16`\0\x81\x81R`\x07` \x90\x81R`@\x80\x83 \x94\x87\x16\x80\x84R\x94\x82R\x91\x82\x90 \x80T`\xFF\x19\x16\x86\x15\x15\x90\x81\x17\x90\x91U\x91Q\x91\x82R\x7F\x170~\xAB9\xABa\x07\xE8\x89\x98E\xAD=Y\xBD\x96S\xF2\0\xF2 \x92\x04\x89\xCA+Y7il1\x91\x01`@Q\x80\x91\x03\x90\xA3PPPV[``\x82a\x16\0`\x01\x84a-\xBBV[\x81T\x81\x10a\x16\x10Wa\x16\x10a,,V[\x90`\0R` `\0 \x01\x80Ta\x16%\x90a+eV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x16Q\x90a+eV[\x80\x15a\x16\x9EW\x80`\x1F\x10a\x16sWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x16\x9EV[\x82\x01\x91\x90`\0R` `\0 \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x16\x81W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x90P\x92\x91PPV[a\x16\xB6\x84\x84\x84a\x11JV[a\x16\xC2\x84\x84\x84\x84a\x1E/V[a\x0FDW`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x06Y\x90a.rV[``a\x16\xE9\x82a\x0F\xD5V[a\x17OW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`1`$\x82\x01R\x7FERC721URIStorage: URI query for `D\x82\x01Rp77\xB72\xBC4\xB9\xBA2\xB7:\x10:7\xB5\xB2\xB7`y\x1B`d\x82\x01R`\x84\x01a\x06YV[`\0\x82\x81R`\x08` R`@\x81 \x80Ta\x17h\x90a+eV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x17\x94\x90a+eV[\x80\x15a\x17\xE1W\x80`\x1F\x10a\x17\xB6Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x17\xE1V[\x82\x01\x91\x90`\0R` `\0 \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x17\xC4W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x90P`\0a\x17\xF2a\x1F0V[\x90P\x80Q`\0\x03a\x18\x04WP\x92\x91PPV[\x81Q\x15a\x186W\x80\x82`@Q` \x01a\x18\x1E\x92\x91\x90a.\xC4V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x92PPP\x91\x90PV[a\x11B\x84a\x1F?V[`\0a\x05Y\x82T\x90V[`\0`\x01`\x01`\xE0\x1B\x03\x19\x82\x16c\x80\xACX\xCD`\xE0\x1B\x14\x80a\x18zWP`\x01`\x01`\xE0\x1B\x03\x19\x82\x16c[^\x13\x9F`\xE0\x1B\x14[\x80a\x05YWPa\x05Y\x82a \tV[a\x07\x8E\x83\x83\x83a .V[```\0a\x18\xA3\x83`\x02a.\xF3V[a\x18\xAE\x90`\x02a-\xCEV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x18\xC6Wa\x18\xC6a'\x8AV[`@Q\x90\x80\x82R\x80`\x1F\x01`\x1F\x19\x16` \x01\x82\x01`@R\x80\x15a\x18\xF0W` \x82\x01\x81\x806\x837\x01\x90P[P\x90P`\x03`\xFC\x1B\x81`\0\x81Q\x81\x10a\x19\x0BWa\x19\x0Ba,,V[` \x01\x01\x90`\x01`\x01`\xF8\x1B\x03\x19\x16\x90\x81`\0\x1A\x90SP`\x0F`\xFB\x1B\x81`\x01\x81Q\x81\x10a\x19:Wa\x19:a,,V[` \x01\x01\x90`\x01`\x01`\xF8\x1B\x03\x19\x16\x90\x81`\0\x1A\x90SP`\0a\x19^\x84`\x02a.\xF3V[a\x19i\x90`\x01a-\xCEV[\x90P[`\x01\x81\x11\x15a\x19\xE1Wo\x18\x18\x99\x19\x9A\x1A\x9B\x1B\x9C\x1C\xB0\xB11\xB22\xB3`\x81\x1B\x85`\x0F\x16`\x10\x81\x10a\x19\x9DWa\x19\x9Da,,V[\x1A`\xF8\x1B\x82\x82\x81Q\x81\x10a\x19\xB3Wa\x19\xB3a,,V[` \x01\x01\x90`\x01`\x01`\xF8\x1B\x03\x19\x16\x90\x81`\0\x1A\x90SP`\x04\x94\x90\x94\x1C\x93a\x19\xDA\x81a/\nV[\x90Pa\x19lV[P\x83\x15a\r6W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01\x81\x90R`$\x82\x01R\x7FStrings: hex length insufficient`D\x82\x01R`d\x01a\x06YV[`\0\x82`\x01\x01\x82`@Qa\x1AD\x91\x90a.VV[\x90\x81R`@Q\x90\x81\x90\x03` \x01\x90 T\x15\x15\x93\x92PPPV[`\x01`\x01`\xA0\x1B\x03\x82\x16a\x1A\xB3W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01\x81\x90R`$\x82\x01R\x7FERC721: mint to the zero address`D\x82\x01R`d\x01a\x06YV[a\x1A\xBC\x81a\x0F\xD5V[\x15a\x1B\tW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1C`$\x82\x01R\x7FERC721: token already minted\0\0\0\0`D\x82\x01R`d\x01a\x06YV[a\x1B\x15`\0\x83\x83a\x18\x89V[`\x01`\x01`\xA0\x1B\x03\x82\x16`\0\x90\x81R`\x05` R`@\x81 \x80T`\x01\x92\x90a\x1B>\x90\x84\x90a-\xCEV[\x90\x91UPP`\0\x81\x81R`\x04` R`@\x80\x82 \x80T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x86\x16\x90\x81\x17\x90\x91U\x90Q\x83\x92\x90\x7F\xDD\xF2R\xAD\x1B\xE2\xC8\x9Bi\xC2\xB0h\xFC7\x8D\xAA\x95+\xA7\xF1c\xC4\xA1\x16(\xF5ZM\xF5#\xB3\xEF\x90\x82\x90\xA4PPV[a\x1B\xA5\x82a\x0F\xD5V[a\x1C\x08W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`.`$\x82\x01R\x7FERC721URIStorage: URI set of non`D\x82\x01Rm2\xBC4\xB9\xBA2\xB7:\x10:7\xB5\xB2\xB7`\x91\x1B`d\x82\x01R`\x84\x01a\x06YV[`\0\x82\x81R`\x08` R`@\x90 a\x07\x8E\x82\x82a,\xA1V[a\x1C*\x82\x82a\r=V[a\t\xACW`\0\x82\x81R` \x81\x81R`@\x80\x83 `\x01`\x01`\xA0\x1B\x03\x85\x16\x84R\x90\x91R\x90 \x80T`\xFF\x19\x16`\x01\x17\x90Ua\x1C`3\x90V[`\x01`\x01`\xA0\x1B\x03\x16\x81`\x01`\x01`\xA0\x1B\x03\x16\x83\x7F/\x87\x88\x11~~\xFF\x1D\x82\xE9&\xECyI\x01\xD1|x\x02JP'\t@0E@\xA73eo\r`@Q`@Q\x80\x91\x03\x90\xA4PPV[`\0a\r6\x83`\x01`\x01`\xA0\x1B\x03\x84\x16a \xE6V[a\x1C\xC3\x82\x82a\r=V[\x15a\t\xACW`\0\x82\x81R` \x81\x81R`@\x80\x83 `\x01`\x01`\xA0\x1B\x03\x85\x16\x80\x85R\x92R\x80\x83 \x80T`\xFF\x19\x16\x90UQ3\x92\x85\x91\x7F\xF69\x1F\\2\xD9\xC6\x9D*G\xEAg\x0BD)t\xB595\xD1\xED\xC7\xFDd\xEB!\xE0G\xA89\x17\x1B\x91\x90\xA4PPV[`\0a\r6\x83`\x01`\x01`\xA0\x1B\x03\x84\x16a!-V[`\0a\x1D\x88\x82`@Q\x80`@\x01`@R\x80` \x81R` \x01\x7FSafeERC20: low-level call failed\x81RP\x85`\x01`\x01`\xA0\x1B\x03\x16a\" \x90\x92\x91\x90c\xFF\xFF\xFF\xFF\x16V[\x80Q\x90\x91P\x15a\x07\x8EW\x80\x80` \x01\x90Q\x81\x01\x90a\x1D\xA6\x91\x90a/!V[a\x07\x8EW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`*`$\x82\x01R\x7FSafeERC20: ERC20 operation did n`D\x82\x01Ri\x1B\xDD\x08\x1C\xDDX\xD8\xD9YY`\xB2\x1B`d\x82\x01R`\x84\x01a\x06YV[`\0\x82`\0\x01\x82\x81T\x81\x10a\x1E\x1CWa\x1E\x1Ca,,V[\x90`\0R` `\0 \x01T\x90P\x92\x91PPV[`\0`\x01`\x01`\xA0\x1B\x03\x84\x16;\x15a\x1F%W`@Qc\n\x85\xBD\x01`\xE1\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x85\x16\x90c\x15\x0Bz\x02\x90a\x1Es\x903\x90\x89\x90\x88\x90\x88\x90`\x04\x01a/>V[` `@Q\x80\x83\x03\x81`\0\x87Z\xF1\x92PPP\x80\x15a\x1E\xAEWP`@\x80Q`\x1F=\x90\x81\x01`\x1F\x19\x16\x82\x01\x90\x92Ra\x1E\xAB\x91\x81\x01\x90a/{V[`\x01[a\x1F\x0BW=\x80\x80\x15a\x1E\xDCW`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=`\0` \x84\x01>a\x1E\xE1V[``\x91P[P\x80Q`\0\x03a\x1F\x03W`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x06Y\x90a.rV[\x80Q\x81` \x01\xFD[`\x01`\x01`\xE0\x1B\x03\x19\x16c\n\x85\xBD\x01`\xE1\x1B\x14\x90Pa\x11BV[P`\x01\x94\x93PPPPV[```\x0E\x80Ta\x05n\x90a+eV[``a\x1FJ\x82a\x0F\xD5V[a\x1F\xAEW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`/`$\x82\x01R\x7FERC721Metadata: URI query for no`D\x82\x01Rn72\xBC4\xB9\xBA2\xB7:\x10:7\xB5\xB2\xB7`\x89\x1B`d\x82\x01R`\x84\x01a\x06YV[`\0a\x1F\xB8a\x1F0V[\x90P`\0\x81Q\x11a\x1F\xD8W`@Q\x80` \x01`@R\x80`\0\x81RPa\r6V[\x80a\x1F\xE2\x84a\"/V[`@Q` \x01a\x1F\xF3\x92\x91\x90a.\xC4V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x93\x92PPPV[`\0`\x01`\x01`\xE0\x1B\x03\x19\x82\x16cZ\x05\x18\x0F`\xE0\x1B\x14\x80a\x05YWPa\x05Y\x82a#0V[`\x01`\x01`\xA0\x1B\x03\x83\x16a \x89Wa \x84\x81`\x0B\x80T`\0\x83\x81R`\x0C` R`@\x81 \x82\x90U`\x01\x82\x01\x83U\x91\x90\x91R\x7F\x01u\xB7\xA68Bw\x03\xF0\xDB\xE7\xBB\x9B\xBF\x98z%Qq{4\xE7\x9F3\xB5\xB1\0\x8D\x1F\xA0\x1D\xB9\x01UV[a \xACV[\x81`\x01`\x01`\xA0\x1B\x03\x16\x83`\x01`\x01`\xA0\x1B\x03\x16\x14a \xACWa \xAC\x83\x82a#eV[`\x01`\x01`\xA0\x1B\x03\x82\x16a \xC3Wa\x07\x8E\x81a$\x02V[\x82`\x01`\x01`\xA0\x1B\x03\x16\x82`\x01`\x01`\xA0\x1B\x03\x16\x14a\x07\x8EWa\x07\x8E\x82\x82a$\xB1V[`\0\x81\x81R`\x01\x83\x01` R`@\x81 Ta\x13\xFEWP\x81T`\x01\x81\x81\x01\x84U`\0\x84\x81R` \x80\x82 \x90\x93\x01\x84\x90U\x84T\x84\x82R\x82\x86\x01\x90\x93R`@\x90 \x91\x90\x91Ua\x05YV[`\0\x81\x81R`\x01\x83\x01` R`@\x81 T\x80\x15a\"\x16W`\0a!Q`\x01\x83a-\xBBV[\x85T\x90\x91P`\0\x90a!e\x90`\x01\x90a-\xBBV[\x90P\x81\x81\x14a!\xCAW`\0\x86`\0\x01\x82\x81T\x81\x10a!\x85Wa!\x85a,,V[\x90`\0R` `\0 \x01T\x90P\x80\x87`\0\x01\x84\x81T\x81\x10a!\xA8Wa!\xA8a,,V[`\0\x91\x82R` \x80\x83 \x90\x91\x01\x92\x90\x92U\x91\x82R`\x01\x88\x01\x90R`@\x90 \x83\x90U[\x85T\x86\x90\x80a!\xDBWa!\xDBa/\x98V[`\x01\x90\x03\x81\x81\x90`\0R` `\0 \x01`\0\x90U\x90U\x85`\x01\x01`\0\x86\x81R` \x01\x90\x81R` \x01`\0 `\0\x90U`\x01\x93PPPPa\x05YV[`\0\x91PPa\x05YV[``a\x11B\x84\x84`\0\x85a$\xF5V[``\x81`\0\x03a\"VWPP`@\x80Q\x80\x82\x01\x90\x91R`\x01\x81R`\x03`\xFC\x1B` \x82\x01R\x90V[\x81`\0[\x81\x15a\"\x80W\x80a\"j\x81a-\xA2V[\x91Pa\"y\x90P`\n\x83a/\xC4V[\x91Pa\"ZV[`\0\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\"\x9BWa\"\x9Ba'\x8AV[`@Q\x90\x80\x82R\x80`\x1F\x01`\x1F\x19\x16` \x01\x82\x01`@R\x80\x15a\"\xC5W` \x82\x01\x81\x806\x837\x01\x90P[P\x90P[\x84\x15a\x11BWa\"\xDA`\x01\x83a-\xBBV[\x91Pa\"\xE7`\n\x86a/\xD8V[a\"\xF2\x90`0a-\xCEV[`\xF8\x1B\x81\x83\x81Q\x81\x10a#\x07Wa#\x07a,,V[` \x01\x01\x90`\x01`\x01`\xF8\x1B\x03\x19\x16\x90\x81`\0\x1A\x90SPa#)`\n\x86a/\xC4V[\x94Pa\"\xC9V[`\0`\x01`\x01`\xE0\x1B\x03\x19\x82\x16cye\xDB\x0B`\xE0\x1B\x14\x80a\x05YWPc\x01\xFF\xC9\xA7`\xE0\x1B`\x01`\x01`\xE0\x1B\x03\x19\x83\x16\x14a\x05YV[`\0`\x01a#r\x84a\x0C\x97V[a#|\x91\x90a-\xBBV[`\0\x83\x81R`\n` R`@\x90 T\x90\x91P\x80\x82\x14a#\xCFW`\x01`\x01`\xA0\x1B\x03\x84\x16`\0\x90\x81R`\t` \x90\x81R`@\x80\x83 \x85\x84R\x82R\x80\x83 T\x84\x84R\x81\x84 \x81\x90U\x83R`\n\x90\x91R\x90 \x81\x90U[P`\0\x91\x82R`\n` \x90\x81R`@\x80\x84 \x84\x90U`\x01`\x01`\xA0\x1B\x03\x90\x94\x16\x83R`\t\x81R\x83\x83 \x91\x83RR\x90\x81 UV[`\x0BT`\0\x90a$\x14\x90`\x01\x90a-\xBBV[`\0\x83\x81R`\x0C` R`@\x81 T`\x0B\x80T\x93\x94P\x90\x92\x84\x90\x81\x10a$<Wa$<a,,V[\x90`\0R` `\0 \x01T\x90P\x80`\x0B\x83\x81T\x81\x10a$]Wa$]a,,V[`\0\x91\x82R` \x80\x83 \x90\x91\x01\x92\x90\x92U\x82\x81R`\x0C\x90\x91R`@\x80\x82 \x84\x90U\x85\x82R\x81 U`\x0B\x80T\x80a$\x95Wa$\x95a/\x98V[`\x01\x90\x03\x81\x81\x90`\0R` `\0 \x01`\0\x90U\x90UPPPPV[`\0a$\xBC\x83a\x0C\x97V[`\x01`\x01`\xA0\x1B\x03\x90\x93\x16`\0\x90\x81R`\t` \x90\x81R`@\x80\x83 \x86\x84R\x82R\x80\x83 \x85\x90U\x93\x82R`\n\x90R\x91\x90\x91 \x91\x90\x91UPV[``\x82G\x10\x15a%VW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`&`$\x82\x01R\x7FAddress: insufficient balance fo`D\x82\x01Re\x1C\x88\x18\xD8[\x1B`\xD2\x1B`d\x82\x01R`\x84\x01a\x06YV[\x84;a%\xA4W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1D`$\x82\x01R\x7FAddress: call to non-contract\0\0\0`D\x82\x01R`d\x01a\x06YV[`\0\x80\x86`\x01`\x01`\xA0\x1B\x03\x16\x85\x87`@Qa%\xC0\x91\x90a.VV[`\0`@Q\x80\x83\x03\x81\x85\x87Z\xF1\x92PPP=\x80`\0\x81\x14a%\xFDW`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=`\0` \x84\x01>a&\x02V[``\x91P[P\x91P\x91Pa&\x12\x82\x82\x86a&\x1DV[\x97\x96PPPPPPPV[``\x83\x15a&,WP\x81a\r6V[\x82Q\x15a&<W\x82Q\x80\x84` \x01\xFD[\x81`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x06Y\x91\x90a&\xDCV[`\x01`\x01`\xE0\x1B\x03\x19\x81\x16\x81\x14a&lW`\0\x80\xFD[PV[`\0` \x82\x84\x03\x12\x15a&\x81W`\0\x80\xFD[\x815a\r6\x81a&VV[`\0[\x83\x81\x10\x15a&\xA7W\x81\x81\x01Q\x83\x82\x01R` \x01a&\x8FV[PP`\0\x91\x01RV[`\0\x81Q\x80\x84Ra&\xC8\x81` \x86\x01` \x86\x01a&\x8CV[`\x1F\x01`\x1F\x19\x16\x92\x90\x92\x01` \x01\x92\x91PPV[` \x81R`\0a\r6` \x83\x01\x84a&\xB0V[`\0` \x82\x84\x03\x12\x15a'\x01W`\0\x80\xFD[P5\x91\x90PV[\x805`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a'\x1FW`\0\x80\xFD[\x91\x90PV[`\0\x80`@\x83\x85\x03\x12\x15a'7W`\0\x80\xFD[a'@\x83a'\x08V[\x94` \x93\x90\x93\x015\x93PPPV[`\0\x80`\0``\x84\x86\x03\x12\x15a'cW`\0\x80\xFD[a'l\x84a'\x08V[\x92Pa'z` \x85\x01a'\x08V[\x91P`@\x84\x015\x90P\x92P\x92P\x92V[cNH{q`\xE0\x1B`\0R`A`\x04R`$`\0\xFD[`\0g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x84\x11\x15a'\xBBWa'\xBBa'\x8AV[`@Q`\x1F\x85\x01`\x1F\x19\x90\x81\x16`?\x01\x16\x81\x01\x90\x82\x82\x11\x81\x83\x10\x17\x15a'\xE3Wa'\xE3a'\x8AV[\x81`@R\x80\x93P\x85\x81R\x86\x86\x86\x01\x11\x15a'\xFCW`\0\x80\xFD[\x85\x85` \x83\x017`\0` \x87\x83\x01\x01RPPP\x93\x92PPPV[`\0\x82`\x1F\x83\x01\x12a('W`\0\x80\xFD[a\r6\x83\x835` \x85\x01a'\xA0V[`\0\x80`\0\x80`\0`\xA0\x86\x88\x03\x12\x15a(NW`\0\x80\xFD[a(W\x86a'\x08V[\x94P` \x86\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x82\x11\x15a(tW`\0\x80\xFD[a(\x80\x89\x83\x8A\x01a(\x16V[\x95P`@\x88\x015\x91P\x80\x82\x11\x15a(\x96W`\0\x80\xFD[Pa(\xA3\x88\x82\x89\x01a(\x16V[\x95\x98\x94\x97P\x94\x95``\x81\x015\x95P`\x80\x015\x93\x92PPPV[`\0\x80`@\x83\x85\x03\x12\x15a(\xCFW`\0\x80\xFD[\x825\x91Pa(\xDF` \x84\x01a'\x08V[\x90P\x92P\x92\x90PV[`\0` \x82\x84\x03\x12\x15a(\xFAW`\0\x80\xFD[a\r6\x82a'\x08V[`\0\x80`@\x83\x85\x03\x12\x15a)\x16W`\0\x80\xFD[PP\x805\x92` \x90\x91\x015\x91PV[`\0` \x82\x84\x03\x12\x15a)7W`\0\x80\xFD[\x815g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a)NW`\0\x80\xFD[a\x11B\x84\x82\x85\x01a(\x16V[`\0\x80\x83`\x1F\x84\x01\x12a)lW`\0\x80\xFD[P\x815g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a)\x84W`\0\x80\xFD[` \x83\x01\x91P\x83` \x82\x85\x01\x01\x11\x15a)\x9CW`\0\x80\xFD[\x92P\x92\x90PV[`\0\x80`\0\x80`\0\x80`\0\x80`\xA0\x89\x8B\x03\x12\x15a)\xBFW`\0\x80\xFD[\x885g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x82\x11\x15a)\xD7W`\0\x80\xFD[\x81\x8B\x01\x91P\x8B`\x1F\x83\x01\x12a)\xEBW`\0\x80\xFD[\x815\x81\x81\x11\x15a)\xFAW`\0\x80\xFD[\x8C` \x82`\x05\x1B\x85\x01\x01\x11\x15a*\x0FW`\0\x80\xFD[` \x92\x83\x01\x9AP\x98P\x90\x8A\x015\x90\x80\x82\x11\x15a**W`\0\x80\xFD[a*6\x8C\x83\x8D\x01a)ZV[\x90\x98P\x96P`@\x8B\x015\x91P\x80\x82\x11\x15a*OW`\0\x80\xFD[Pa*\\\x8B\x82\x8C\x01a)ZV[\x99\x9C\x98\x9BP\x96\x99\x95\x98\x96\x97``\x87\x015\x96`\x80\x015\x95P\x93PPPPV[\x80\x15\x15\x81\x14a&lW`\0\x80\xFD[`\0\x80`@\x83\x85\x03\x12\x15a*\x9BW`\0\x80\xFD[a*\xA4\x83a'\x08V[\x91P` \x83\x015a*\xB4\x81a*zV[\x80\x91PP\x92P\x92\x90PV[`\0\x80`\0\x80`\x80\x85\x87\x03\x12\x15a*\xD5W`\0\x80\xFD[a*\xDE\x85a'\x08V[\x93Pa*\xEC` \x86\x01a'\x08V[\x92P`@\x85\x015\x91P``\x85\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a+\x0FW`\0\x80\xFD[\x85\x01`\x1F\x81\x01\x87\x13a+ W`\0\x80\xFD[a+/\x87\x825` \x84\x01a'\xA0V[\x91PP\x92\x95\x91\x94P\x92PV[`\0\x80`@\x83\x85\x03\x12\x15a+NW`\0\x80\xFD[a+W\x83a'\x08V[\x91Pa(\xDF` \x84\x01a'\x08V[`\x01\x81\x81\x1C\x90\x82\x16\x80a+yW`\x7F\x82\x16\x91P[` \x82\x10\x81\x03a+\x99WcNH{q`\xE0\x1B`\0R`\"`\x04R`$`\0\xFD[P\x91\x90PV[` \x80\x82R`1\x90\x82\x01R\x7FERC721: transfer caller is not o`@\x82\x01Rp\x1D\xDB\x99\\\x88\x1B\x9B\xDC\x88\x18\\\x1C\x1C\x9B\xDD\x99Y`z\x1B``\x82\x01R`\x80\x01\x90V[`\0\x83Qa,\x02\x81\x84` \x88\x01a&\x8CV[`/`\xF8\x1B\x90\x83\x01\x90\x81R\x83Qa, \x81`\x01\x84\x01` \x88\x01a&\x8CV[\x01`\x01\x01\x94\x93PPPPV[cNH{q`\xE0\x1B`\0R`2`\x04R`$`\0\xFD[`\0` \x82\x84\x03\x12\x15a,TW`\0\x80\xFD[PQ\x91\x90PV[`\x1F\x82\x11\x15a\x07\x8EW`\0\x81\x81R` \x81 `\x1F\x85\x01`\x05\x1C\x81\x01` \x86\x10\x15a,\x82WP\x80[`\x1F\x85\x01`\x05\x1C\x82\x01\x91P[\x81\x81\x10\x15a\x14zW\x82\x81U`\x01\x01a,\x8EV[\x81Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a,\xBBWa,\xBBa'\x8AV[a,\xCF\x81a,\xC9\x84Ta+eV[\x84a,[V[` \x80`\x1F\x83\x11`\x01\x81\x14a-\x04W`\0\x84\x15a,\xECWP\x85\x83\x01Q[`\0\x19`\x03\x86\x90\x1B\x1C\x19\x16`\x01\x85\x90\x1B\x17\x85Ua\x14zV[`\0\x85\x81R` \x81 `\x1F\x19\x86\x16\x91[\x82\x81\x10\x15a-3W\x88\x86\x01Q\x82U\x94\x84\x01\x94`\x01\x90\x91\x01\x90\x84\x01a-\x14V[P\x85\x82\x10\x15a-QW\x87\x85\x01Q`\0\x19`\x03\x88\x90\x1B`\xF8\x16\x1C\x19\x16\x81U[PPPPP`\x01\x90\x81\x1B\x01\x90UPV[\x83\x85\x827`\0\x84\x82\x01`/`\xF8\x1B\x81R\x83\x85`\x01\x83\x017`\0\x93\x01`\x01\x01\x92\x83RP\x90\x94\x93PPPPV[cNH{q`\xE0\x1B`\0R`\x11`\x04R`$`\0\xFD[`\0`\x01\x82\x01a-\xB4Wa-\xB4a-\x8CV[P`\x01\x01\x90V[\x81\x81\x03\x81\x81\x11\x15a\x05YWa\x05Ya-\x8CV[\x80\x82\x01\x80\x82\x11\x15a\x05YWa\x05Ya-\x8CV[\x7FAccessControl: account \0\0\0\0\0\0\0\0\0\x81R`\0\x83Qa.\x19\x81`\x17\x85\x01` \x88\x01a&\x8CV[p\x01\x03K\x99\x03kK\x9B\x9BKs9\x03\x93{c)`}\x1B`\x17\x91\x84\x01\x91\x82\x01R\x83Qa.J\x81`(\x84\x01` \x88\x01a&\x8CV[\x01`(\x01\x94\x93PPPPV[`\0\x82Qa.h\x81\x84` \x87\x01a&\x8CV[\x91\x90\x91\x01\x92\x91PPV[` \x80\x82R`2\x90\x82\x01R\x7FERC721: transfer to non ERC721Re`@\x82\x01Rq1\xB2\xB4\xBB2\xB9\x104\xB6\xB862\xB6\xB2\xB7:2\xB9`q\x1B``\x82\x01R`\x80\x01\x90V[`\0\x83Qa.\xD6\x81\x84` \x88\x01a&\x8CV[\x83Q\x90\x83\x01\x90a.\xEA\x81\x83` \x88\x01a&\x8CV[\x01\x94\x93PPPPV[\x80\x82\x02\x81\x15\x82\x82\x04\x84\x14\x17a\x05YWa\x05Ya-\x8CV[`\0\x81a/\x19Wa/\x19a-\x8CV[P`\0\x19\x01\x90V[`\0` \x82\x84\x03\x12\x15a/3W`\0\x80\xFD[\x81Qa\r6\x81a*zV[`\x01`\x01`\xA0\x1B\x03\x85\x81\x16\x82R\x84\x16` \x82\x01R`@\x81\x01\x83\x90R`\x80``\x82\x01\x81\x90R`\0\x90a/q\x90\x83\x01\x84a&\xB0V[\x96\x95PPPPPPV[`\0` \x82\x84\x03\x12\x15a/\x8DW`\0\x80\xFD[\x81Qa\r6\x81a&VV[cNH{q`\xE0\x1B`\0R`1`\x04R`$`\0\xFD[cNH{q`\xE0\x1B`\0R`\x12`\x04R`$`\0\xFD[`\0\x82a/\xD3Wa/\xD3a/\xAEV[P\x04\x90V[`\0\x82a/\xE7Wa/\xE7a/\xAEV[P\x06\x90V\xFE\xA2dipfsX\"\x12 m{\xDE\xEA\xFDk<\xBBC\x1FL|\"%\x04^\xD0\xE8\xE3\x9A6\x8F1\n'\xAEI_/\xC1\x0C\xDBdsolcC\0\x08\x13\x003",
    );
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `Approval(address,address,uint256)` and selector `0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925`.
```solidity
event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Approval {
        #[allow(missing_docs)]
        pub owner: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub approved: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub tokenId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Approval {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            const SIGNATURE: &'static str = "Approval(address,address,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                140u8, 91u8, 225u8, 229u8, 235u8, 236u8, 125u8, 91u8, 209u8, 79u8, 113u8,
                66u8, 125u8, 30u8, 132u8, 243u8, 221u8, 3u8, 20u8, 192u8, 247u8, 178u8,
                41u8, 30u8, 91u8, 32u8, 10u8, 200u8, 199u8, 195u8, 185u8, 37u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    owner: topics.1,
                    approved: topics.2,
                    tokenId: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.owner.clone(),
                    self.approved.clone(),
                    self.tokenId.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.owner,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.approved,
                );
                out[3usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.tokenId);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Approval {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Approval> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Approval) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `ApprovalForAll(address,address,bool)` and selector `0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31`.
```solidity
event ApprovalForAll(address indexed owner, address indexed operator, bool approved);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct ApprovalForAll {
        #[allow(missing_docs)]
        pub owner: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub approved: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for ApprovalForAll {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "ApprovalForAll(address,address,bool)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                23u8, 48u8, 126u8, 171u8, 57u8, 171u8, 97u8, 7u8, 232u8, 137u8, 152u8,
                69u8, 173u8, 61u8, 89u8, 189u8, 150u8, 83u8, 242u8, 0u8, 242u8, 32u8,
                146u8, 4u8, 137u8, 202u8, 43u8, 89u8, 55u8, 105u8, 108u8, 49u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    owner: topics.1,
                    operator: topics.2,
                    approved: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.approved,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.owner.clone(), self.operator.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.owner,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.operator,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for ApprovalForAll {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&ApprovalForAll> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &ApprovalForAll) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `BoostMinted(uint256,uint256,uint256)` and selector `0x735e5eb5afdd72cc64657ded7e5de390af3708afb5b9a80b0e5c911a0499d98f`.
```solidity
event BoostMinted(uint256 indexed boostTypeIndex, uint256 indexed boostNumerator, uint256 indexed redeemDeadline);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct BoostMinted {
        #[allow(missing_docs)]
        pub boostTypeIndex: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub boostNumerator: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub redeemDeadline: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for BoostMinted {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            const SIGNATURE: &'static str = "BoostMinted(uint256,uint256,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                115u8, 94u8, 94u8, 181u8, 175u8, 221u8, 114u8, 204u8, 100u8, 101u8,
                125u8, 237u8, 126u8, 93u8, 227u8, 144u8, 175u8, 55u8, 8u8, 175u8, 181u8,
                185u8, 168u8, 11u8, 14u8, 92u8, 145u8, 26u8, 4u8, 153u8, 217u8, 143u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    boostTypeIndex: topics.1,
                    boostNumerator: topics.2,
                    redeemDeadline: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.boostTypeIndex.clone(),
                    self.boostNumerator.clone(),
                    self.redeemDeadline.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.boostTypeIndex);
                out[2usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.boostNumerator);
                out[3usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.redeemDeadline);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for BoostMinted {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&BoostMinted> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &BoostMinted) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `RoleAdminChanged(bytes32,bytes32,bytes32)` and selector `0xbd79b86ffe0ab8e8776151514217cd7cacd52c909f66475c3af44e129f0b00ff`.
```solidity
event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RoleAdminChanged {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub previousAdminRole: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub newAdminRole: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RoleAdminChanged {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            const SIGNATURE: &'static str = "RoleAdminChanged(bytes32,bytes32,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                189u8, 121u8, 184u8, 111u8, 254u8, 10u8, 184u8, 232u8, 119u8, 97u8, 81u8,
                81u8, 66u8, 23u8, 205u8, 124u8, 172u8, 213u8, 44u8, 144u8, 159u8, 102u8,
                71u8, 92u8, 58u8, 244u8, 78u8, 18u8, 159u8, 11u8, 0u8, 255u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    role: topics.1,
                    previousAdminRole: topics.2,
                    newAdminRole: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.role.clone(),
                    self.previousAdminRole.clone(),
                    self.newAdminRole.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.role);
                out[2usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.previousAdminRole);
                out[3usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.newAdminRole);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RoleAdminChanged {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RoleAdminChanged> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RoleAdminChanged) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `RoleGranted(bytes32,address,address)` and selector `0x2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d`.
```solidity
event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RoleGranted {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub sender: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RoleGranted {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "RoleGranted(bytes32,address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                47u8, 135u8, 136u8, 17u8, 126u8, 126u8, 255u8, 29u8, 130u8, 233u8, 38u8,
                236u8, 121u8, 73u8, 1u8, 209u8, 124u8, 120u8, 2u8, 74u8, 80u8, 39u8, 9u8,
                64u8, 48u8, 69u8, 64u8, 167u8, 51u8, 101u8, 111u8, 13u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    role: topics.1,
                    account: topics.2,
                    sender: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.role.clone(),
                    self.account.clone(),
                    self.sender.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.role);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.account,
                );
                out[3usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.sender,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RoleGranted {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RoleGranted> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RoleGranted) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `RoleRevoked(bytes32,address,address)` and selector `0xf6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b`.
```solidity
event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RoleRevoked {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub sender: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RoleRevoked {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "RoleRevoked(bytes32,address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                246u8, 57u8, 31u8, 92u8, 50u8, 217u8, 198u8, 157u8, 42u8, 71u8, 234u8,
                103u8, 11u8, 68u8, 41u8, 116u8, 181u8, 57u8, 53u8, 209u8, 237u8, 199u8,
                253u8, 100u8, 235u8, 33u8, 224u8, 71u8, 168u8, 57u8, 23u8, 27u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    role: topics.1,
                    account: topics.2,
                    sender: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.role.clone(),
                    self.account.clone(),
                    self.sender.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.role);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.account,
                );
                out[3usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.sender,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RoleRevoked {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RoleRevoked> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RoleRevoked) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `Transfer(address,address,uint256)` and selector `0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef`.
```solidity
event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Transfer {
        #[allow(missing_docs)]
        pub from: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub to: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub tokenId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Transfer {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            const SIGNATURE: &'static str = "Transfer(address,address,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                221u8, 242u8, 82u8, 173u8, 27u8, 226u8, 200u8, 155u8, 105u8, 194u8,
                176u8, 104u8, 252u8, 55u8, 141u8, 170u8, 149u8, 43u8, 167u8, 241u8, 99u8,
                196u8, 161u8, 22u8, 40u8, 245u8, 90u8, 77u8, 245u8, 35u8, 179u8, 239u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    from: topics.1,
                    to: topics.2,
                    tokenId: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.from.clone(),
                    self.to.clone(),
                    self.tokenId.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.from,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.to,
                );
                out[3usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.tokenId);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Transfer {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Transfer> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Transfer) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Constructor`.
```solidity
constructor(address newAdmin, string baseTokenURI);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct constructorCall {
        #[allow(missing_docs)]
        pub newAdmin: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub baseTokenURI: alloy::sol_types::private::String,
    }
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::String,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::String,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<constructorCall> for UnderlyingRustTuple<'_> {
                fn from(value: constructorCall) -> Self {
                    (value.newAdmin, value.baseTokenURI)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for constructorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        newAdmin: tuple.0,
                        baseTokenURI: tuple.1,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolConstructor for constructorCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::String,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.newAdmin,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.baseTokenURI,
                    ),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `DEFAULT_ADMIN_ROLE()` and selector `0xa217fddf`.
```solidity
function DEFAULT_ADMIN_ROLE() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DEFAULT_ADMIN_ROLECall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`DEFAULT_ADMIN_ROLE()`](DEFAULT_ADMIN_ROLECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DEFAULT_ADMIN_ROLEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DEFAULT_ADMIN_ROLECall>
            for UnderlyingRustTuple<'_> {
                fn from(value: DEFAULT_ADMIN_ROLECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DEFAULT_ADMIN_ROLECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DEFAULT_ADMIN_ROLEReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: DEFAULT_ADMIN_ROLEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DEFAULT_ADMIN_ROLEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for DEFAULT_ADMIN_ROLECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "DEFAULT_ADMIN_ROLE()";
            const SELECTOR: [u8; 4] = [162u8, 23u8, 253u8, 223u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: DEFAULT_ADMIN_ROLEReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: DEFAULT_ADMIN_ROLEReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `MINTER_ROLE()` and selector `0xd5391393`.
```solidity
function MINTER_ROLE() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct MINTER_ROLECall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`MINTER_ROLE()`](MINTER_ROLECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct MINTER_ROLEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<MINTER_ROLECall> for UnderlyingRustTuple<'_> {
                fn from(value: MINTER_ROLECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for MINTER_ROLECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<MINTER_ROLEReturn> for UnderlyingRustTuple<'_> {
                fn from(value: MINTER_ROLEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for MINTER_ROLEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for MINTER_ROLECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "MINTER_ROLE()";
            const SELECTOR: [u8; 4] = [213u8, 57u8, 19u8, 147u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: MINTER_ROLEReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: MINTER_ROLEReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `approve(address,uint256)` and selector `0x095ea7b3`.
```solidity
function approve(address to, uint256 tokenId) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct approveCall {
        #[allow(missing_docs)]
        pub to: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub tokenId: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`approve(address,uint256)`](approveCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct approveReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<approveCall> for UnderlyingRustTuple<'_> {
                fn from(value: approveCall) -> Self {
                    (value.to, value.tokenId)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for approveCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        to: tuple.0,
                        tokenId: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<approveReturn> for UnderlyingRustTuple<'_> {
                fn from(value: approveReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for approveReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl approveReturn {
            fn _tokenize(
                &self,
            ) -> <approveCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for approveCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = approveReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "approve(address,uint256)";
            const SELECTOR: [u8; 4] = [9u8, 94u8, 167u8, 179u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.tokenId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                approveReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `balanceOf(address)` and selector `0x70a08231`.
```solidity
function balanceOf(address owner) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct balanceOfCall {
        #[allow(missing_docs)]
        pub owner: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`balanceOf(address)`](balanceOfCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct balanceOfReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<balanceOfCall> for UnderlyingRustTuple<'_> {
                fn from(value: balanceOfCall) -> Self {
                    (value.owner,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for balanceOfCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { owner: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<balanceOfReturn> for UnderlyingRustTuple<'_> {
                fn from(value: balanceOfReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for balanceOfReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for balanceOfCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "balanceOf(address)";
            const SELECTOR: [u8; 4] = [112u8, 160u8, 130u8, 49u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.owner,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: balanceOfReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: balanceOfReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `batchMint(address[],string,string,uint256,uint256)` and selector `0x9365c533`.
```solidity
function batchMint(address[] memory to, string memory boostType, string memory boostRank, uint256 boostNumerator, uint256 redeemDeadline) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct batchMintCall {
        #[allow(missing_docs)]
        pub to: alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
        #[allow(missing_docs)]
        pub boostType: alloy::sol_types::private::String,
        #[allow(missing_docs)]
        pub boostRank: alloy::sol_types::private::String,
        #[allow(missing_docs)]
        pub boostNumerator: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub redeemDeadline: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`batchMint(address[],string,string,uint256,uint256)`](batchMintCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct batchMintReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
                alloy::sol_types::private::String,
                alloy::sol_types::private::String,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<batchMintCall> for UnderlyingRustTuple<'_> {
                fn from(value: batchMintCall) -> Self {
                    (
                        value.to,
                        value.boostType,
                        value.boostRank,
                        value.boostNumerator,
                        value.redeemDeadline,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for batchMintCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        to: tuple.0,
                        boostType: tuple.1,
                        boostRank: tuple.2,
                        boostNumerator: tuple.3,
                        redeemDeadline: tuple.4,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<batchMintReturn> for UnderlyingRustTuple<'_> {
                fn from(value: batchMintReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for batchMintReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl batchMintReturn {
            fn _tokenize(
                &self,
            ) -> <batchMintCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for batchMintCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = batchMintReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "batchMint(address[],string,string,uint256,uint256)";
            const SELECTOR: [u8; 4] = [147u8, 101u8, 197u8, 51u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Address,
                    > as alloy_sol_types::SolType>::tokenize(&self.to),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.boostType,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.boostRank,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.boostNumerator),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.redeemDeadline),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                batchMintReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `boostOf(uint256)` and selector `0x896cddf4`.
```solidity
function boostOf(uint256 tokenId) external view returns (uint256, uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct boostOfCall {
        #[allow(missing_docs)]
        pub tokenId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`boostOf(uint256)`](boostOfCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct boostOfReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub _1: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<boostOfCall> for UnderlyingRustTuple<'_> {
                fn from(value: boostOfCall) -> Self {
                    (value.tokenId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for boostOfCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { tokenId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<boostOfReturn> for UnderlyingRustTuple<'_> {
                fn from(value: boostOfReturn) -> Self {
                    (value._0, value._1)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for boostOfReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0, _1: tuple.1 }
                }
            }
        }
        impl boostOfReturn {
            fn _tokenize(
                &self,
            ) -> <boostOfCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._0),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._1),
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for boostOfCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = boostOfReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "boostOf(uint256)";
            const SELECTOR: [u8; 4] = [137u8, 108u8, 221u8, 244u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.tokenId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                boostOfReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getApproved(uint256)` and selector `0x081812fc`.
```solidity
function getApproved(uint256 tokenId) external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getApprovedCall {
        #[allow(missing_docs)]
        pub tokenId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getApproved(uint256)`](getApprovedCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getApprovedReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getApprovedCall> for UnderlyingRustTuple<'_> {
                fn from(value: getApprovedCall) -> Self {
                    (value.tokenId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getApprovedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { tokenId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getApprovedReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getApprovedReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getApprovedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getApprovedCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getApproved(uint256)";
            const SELECTOR: [u8; 4] = [8u8, 24u8, 18u8, 252u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.tokenId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getApprovedReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getApprovedReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getRoleAdmin(bytes32)` and selector `0x248a9ca3`.
```solidity
function getRoleAdmin(bytes32 role) external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRoleAdminCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getRoleAdmin(bytes32)`](getRoleAdminCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRoleAdminReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRoleAdminCall> for UnderlyingRustTuple<'_> {
                fn from(value: getRoleAdminCall) -> Self {
                    (value.role,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getRoleAdminCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { role: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRoleAdminReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getRoleAdminReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getRoleAdminReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getRoleAdminCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getRoleAdmin(bytes32)";
            const SELECTOR: [u8; 4] = [36u8, 138u8, 156u8, 163u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getRoleAdminReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getRoleAdminReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getRoleMember(bytes32,uint256)` and selector `0x9010d07c`.
```solidity
function getRoleMember(bytes32 role, uint256 index) external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRoleMemberCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub index: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getRoleMember(bytes32,uint256)`](getRoleMemberCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRoleMemberReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRoleMemberCall> for UnderlyingRustTuple<'_> {
                fn from(value: getRoleMemberCall) -> Self {
                    (value.role, value.index)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getRoleMemberCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        index: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRoleMemberReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getRoleMemberReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getRoleMemberReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getRoleMemberCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getRoleMember(bytes32,uint256)";
            const SELECTOR: [u8; 4] = [144u8, 16u8, 208u8, 124u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.index),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getRoleMemberReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getRoleMemberReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getRoleMemberCount(bytes32)` and selector `0xca15c873`.
```solidity
function getRoleMemberCount(bytes32 role) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRoleMemberCountCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getRoleMemberCount(bytes32)`](getRoleMemberCountCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRoleMemberCountReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRoleMemberCountCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getRoleMemberCountCall) -> Self {
                    (value.role,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getRoleMemberCountCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { role: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRoleMemberCountReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getRoleMemberCountReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getRoleMemberCountReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getRoleMemberCountCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getRoleMemberCount(bytes32)";
            const SELECTOR: [u8; 4] = [202u8, 21u8, 200u8, 115u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getRoleMemberCountReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getRoleMemberCountReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `grantRole(bytes32,address)` and selector `0x2f2ff15d`.
```solidity
function grantRole(bytes32 role, address account) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct grantRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`grantRole(bytes32,address)`](grantRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct grantRoleReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<grantRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: grantRoleCall) -> Self {
                    (value.role, value.account)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for grantRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        account: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<grantRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: grantRoleReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for grantRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl grantRoleReturn {
            fn _tokenize(
                &self,
            ) -> <grantRoleCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for grantRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = grantRoleReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "grantRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [47u8, 47u8, 241u8, 93u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                grantRoleReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `hasRole(bytes32,address)` and selector `0x91d14854`.
```solidity
function hasRole(bytes32 role, address account) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct hasRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`hasRole(bytes32,address)`](hasRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct hasRoleReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<hasRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: hasRoleCall) -> Self {
                    (value.role, value.account)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for hasRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        account: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<hasRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: hasRoleReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for hasRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for hasRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bool;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "hasRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [145u8, 209u8, 72u8, 84u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: hasRoleReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: hasRoleReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `isApprovedForAll(address,address)` and selector `0xe985e9c5`.
```solidity
function isApprovedForAll(address owner, address operator) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isApprovedForAllCall {
        #[allow(missing_docs)]
        pub owner: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`isApprovedForAll(address,address)`](isApprovedForAllCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isApprovedForAllReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isApprovedForAllCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: isApprovedForAllCall) -> Self {
                    (value.owner, value.operator)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for isApprovedForAllCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        owner: tuple.0,
                        operator: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isApprovedForAllReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: isApprovedForAllReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for isApprovedForAllReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for isApprovedForAllCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bool;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "isApprovedForAll(address,address)";
            const SELECTOR: [u8; 4] = [233u8, 133u8, 233u8, 197u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.owner,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operator,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: isApprovedForAllReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: isApprovedForAllReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `mint(address,string,string,uint256,uint256)` and selector `0x29867dac`.
```solidity
function mint(address to, string memory boostType, string memory boostRank, uint256 boostNumerator, uint256 redeemDeadline) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct mintCall {
        #[allow(missing_docs)]
        pub to: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub boostType: alloy::sol_types::private::String,
        #[allow(missing_docs)]
        pub boostRank: alloy::sol_types::private::String,
        #[allow(missing_docs)]
        pub boostNumerator: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub redeemDeadline: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`mint(address,string,string,uint256,uint256)`](mintCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct mintReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::String,
                alloy::sol_types::private::String,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<mintCall> for UnderlyingRustTuple<'_> {
                fn from(value: mintCall) -> Self {
                    (
                        value.to,
                        value.boostType,
                        value.boostRank,
                        value.boostNumerator,
                        value.redeemDeadline,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for mintCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        to: tuple.0,
                        boostType: tuple.1,
                        boostRank: tuple.2,
                        boostNumerator: tuple.3,
                        redeemDeadline: tuple.4,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<mintReturn> for UnderlyingRustTuple<'_> {
                fn from(value: mintReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for mintReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl mintReturn {
            fn _tokenize(
                &self,
            ) -> <mintCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for mintCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = mintReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "mint(address,string,string,uint256,uint256)";
            const SELECTOR: [u8; 4] = [41u8, 134u8, 125u8, 172u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.boostType,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.boostRank,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.boostNumerator),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.redeemDeadline),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                mintReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `name()` and selector `0x06fdde03`.
```solidity
function name() external view returns (string memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct nameCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`name()`](nameCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct nameReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<nameCall> for UnderlyingRustTuple<'_> {
                fn from(value: nameCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for nameCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<nameReturn> for UnderlyingRustTuple<'_> {
                fn from(value: nameReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for nameReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for nameCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::String;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "name()";
            const SELECTOR: [u8; 4] = [6u8, 253u8, 222u8, 3u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: nameReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: nameReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `ownerOf(uint256)` and selector `0x6352211e`.
```solidity
function ownerOf(uint256 tokenId) external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ownerOfCall {
        #[allow(missing_docs)]
        pub tokenId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`ownerOf(uint256)`](ownerOfCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ownerOfReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ownerOfCall> for UnderlyingRustTuple<'_> {
                fn from(value: ownerOfCall) -> Self {
                    (value.tokenId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ownerOfCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { tokenId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ownerOfReturn> for UnderlyingRustTuple<'_> {
                fn from(value: ownerOfReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ownerOfReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for ownerOfCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ownerOf(uint256)";
            const SELECTOR: [u8; 4] = [99u8, 82u8, 33u8, 30u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.tokenId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: ownerOfReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: ownerOfReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `reclaimErc20Tokens(address)` and selector `0x6067bc15`.
```solidity
function reclaimErc20Tokens(address tokenAddress) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct reclaimErc20TokensCall {
        #[allow(missing_docs)]
        pub tokenAddress: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`reclaimErc20Tokens(address)`](reclaimErc20TokensCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct reclaimErc20TokensReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<reclaimErc20TokensCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: reclaimErc20TokensCall) -> Self {
                    (value.tokenAddress,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for reclaimErc20TokensCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { tokenAddress: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<reclaimErc20TokensReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: reclaimErc20TokensReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for reclaimErc20TokensReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl reclaimErc20TokensReturn {
            fn _tokenize(
                &self,
            ) -> <reclaimErc20TokensCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for reclaimErc20TokensCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = reclaimErc20TokensReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "reclaimErc20Tokens(address)";
            const SELECTOR: [u8; 4] = [96u8, 103u8, 188u8, 21u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.tokenAddress,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                reclaimErc20TokensReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `reclaimErc721Tokens(address,uint256)` and selector `0x48c64e41`.
```solidity
function reclaimErc721Tokens(address tokenAddress, uint256 tokenId) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct reclaimErc721TokensCall {
        #[allow(missing_docs)]
        pub tokenAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub tokenId: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`reclaimErc721Tokens(address,uint256)`](reclaimErc721TokensCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct reclaimErc721TokensReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<reclaimErc721TokensCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: reclaimErc721TokensCall) -> Self {
                    (value.tokenAddress, value.tokenId)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for reclaimErc721TokensCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        tokenAddress: tuple.0,
                        tokenId: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<reclaimErc721TokensReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: reclaimErc721TokensReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for reclaimErc721TokensReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl reclaimErc721TokensReturn {
            fn _tokenize(
                &self,
            ) -> <reclaimErc721TokensCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for reclaimErc721TokensCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = reclaimErc721TokensReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "reclaimErc721Tokens(address,uint256)";
            const SELECTOR: [u8; 4] = [72u8, 198u8, 78u8, 65u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.tokenAddress,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.tokenId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                reclaimErc721TokensReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `renounceRole(bytes32,address)` and selector `0x36568abe`.
```solidity
function renounceRole(bytes32 role, address account) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`renounceRole(bytes32,address)`](renounceRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceRoleReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: renounceRoleCall) -> Self {
                    (value.role, value.account)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for renounceRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        account: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: renounceRoleReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for renounceRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl renounceRoleReturn {
            fn _tokenize(
                &self,
            ) -> <renounceRoleCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for renounceRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = renounceRoleReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "renounceRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [54u8, 86u8, 138u8, 190u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                renounceRoleReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `revokeRole(bytes32,address)` and selector `0xd547741f`.
```solidity
function revokeRole(bytes32 role, address account) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct revokeRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`revokeRole(bytes32,address)`](revokeRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct revokeRoleReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<revokeRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: revokeRoleCall) -> Self {
                    (value.role, value.account)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for revokeRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        account: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<revokeRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: revokeRoleReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for revokeRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl revokeRoleReturn {
            fn _tokenize(
                &self,
            ) -> <revokeRoleCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for revokeRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = revokeRoleReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "revokeRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [213u8, 71u8, 116u8, 31u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                revokeRoleReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `safeTransferFrom(address,address,uint256)` and selector `0x42842e0e`.
```solidity
function safeTransferFrom(address from, address to, uint256 tokenId) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct safeTransferFrom_0Call {
        #[allow(missing_docs)]
        pub from: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub to: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub tokenId: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`safeTransferFrom(address,address,uint256)`](safeTransferFrom_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct safeTransferFrom_0Return {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<safeTransferFrom_0Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: safeTransferFrom_0Call) -> Self {
                    (value.from, value.to, value.tokenId)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for safeTransferFrom_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        from: tuple.0,
                        to: tuple.1,
                        tokenId: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<safeTransferFrom_0Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: safeTransferFrom_0Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for safeTransferFrom_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl safeTransferFrom_0Return {
            fn _tokenize(
                &self,
            ) -> <safeTransferFrom_0Call as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for safeTransferFrom_0Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = safeTransferFrom_0Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "safeTransferFrom(address,address,uint256)";
            const SELECTOR: [u8; 4] = [66u8, 132u8, 46u8, 14u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.from,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.tokenId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                safeTransferFrom_0Return::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `safeTransferFrom(address,address,uint256,bytes)` and selector `0xb88d4fde`.
```solidity
function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct safeTransferFrom_1Call {
        #[allow(missing_docs)]
        pub from: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub to: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub tokenId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub _data: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`safeTransferFrom(address,address,uint256,bytes)`](safeTransferFrom_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct safeTransferFrom_1Return {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<safeTransferFrom_1Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: safeTransferFrom_1Call) -> Self {
                    (value.from, value.to, value.tokenId, value._data)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for safeTransferFrom_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        from: tuple.0,
                        to: tuple.1,
                        tokenId: tuple.2,
                        _data: tuple.3,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<safeTransferFrom_1Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: safeTransferFrom_1Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for safeTransferFrom_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl safeTransferFrom_1Return {
            fn _tokenize(
                &self,
            ) -> <safeTransferFrom_1Call as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for safeTransferFrom_1Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = safeTransferFrom_1Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "safeTransferFrom(address,address,uint256,bytes)";
            const SELECTOR: [u8; 4] = [184u8, 141u8, 79u8, 222u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.from,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.tokenId),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self._data,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                safeTransferFrom_1Return::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `setApprovalForAll(address,bool)` and selector `0xa22cb465`.
```solidity
function setApprovalForAll(address operator, bool approved) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setApprovalForAllCall {
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub approved: bool,
    }
    ///Container type for the return parameters of the [`setApprovalForAll(address,bool)`](setApprovalForAllCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setApprovalForAllReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bool,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address, bool);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setApprovalForAllCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: setApprovalForAllCall) -> Self {
                    (value.operator, value.approved)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setApprovalForAllCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        operator: tuple.0,
                        approved: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setApprovalForAllReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setApprovalForAllReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setApprovalForAllReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl setApprovalForAllReturn {
            fn _tokenize(
                &self,
            ) -> <setApprovalForAllCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setApprovalForAllCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bool,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setApprovalForAllReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setApprovalForAll(address,bool)";
            const SELECTOR: [u8; 4] = [162u8, 44u8, 180u8, 101u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operator,
                    ),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.approved,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                setApprovalForAllReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `supportsInterface(bytes4)` and selector `0x01ffc9a7`.
```solidity
function supportsInterface(bytes4 interfaceId) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct supportsInterfaceCall {
        #[allow(missing_docs)]
        pub interfaceId: alloy::sol_types::private::FixedBytes<4>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`supportsInterface(bytes4)`](supportsInterfaceCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct supportsInterfaceReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<4>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<4>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<supportsInterfaceCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: supportsInterfaceCall) -> Self {
                    (value.interfaceId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for supportsInterfaceCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { interfaceId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<supportsInterfaceReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: supportsInterfaceReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for supportsInterfaceReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for supportsInterfaceCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<4>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bool;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "supportsInterface(bytes4)";
            const SELECTOR: [u8; 4] = [1u8, 255u8, 201u8, 167u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        4,
                    > as alloy_sol_types::SolType>::tokenize(&self.interfaceId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: supportsInterfaceReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: supportsInterfaceReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `symbol()` and selector `0x95d89b41`.
```solidity
function symbol() external view returns (string memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct symbolCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`symbol()`](symbolCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct symbolReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<symbolCall> for UnderlyingRustTuple<'_> {
                fn from(value: symbolCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for symbolCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<symbolReturn> for UnderlyingRustTuple<'_> {
                fn from(value: symbolReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for symbolReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for symbolCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::String;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "symbol()";
            const SELECTOR: [u8; 4] = [149u8, 216u8, 155u8, 65u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: symbolReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: symbolReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `tokenByIndex(uint256)` and selector `0x4f6ccce7`.
```solidity
function tokenByIndex(uint256 index) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct tokenByIndexCall {
        #[allow(missing_docs)]
        pub index: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`tokenByIndex(uint256)`](tokenByIndexCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct tokenByIndexReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<tokenByIndexCall> for UnderlyingRustTuple<'_> {
                fn from(value: tokenByIndexCall) -> Self {
                    (value.index,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for tokenByIndexCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { index: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<tokenByIndexReturn> for UnderlyingRustTuple<'_> {
                fn from(value: tokenByIndexReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for tokenByIndexReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for tokenByIndexCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "tokenByIndex(uint256)";
            const SELECTOR: [u8; 4] = [79u8, 108u8, 204u8, 231u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.index),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: tokenByIndexReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: tokenByIndexReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `tokenOfOwnerByIndex(address,uint256)` and selector `0x2f745c59`.
```solidity
function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct tokenOfOwnerByIndexCall {
        #[allow(missing_docs)]
        pub owner: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub index: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`tokenOfOwnerByIndex(address,uint256)`](tokenOfOwnerByIndexCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct tokenOfOwnerByIndexReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<tokenOfOwnerByIndexCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: tokenOfOwnerByIndexCall) -> Self {
                    (value.owner, value.index)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for tokenOfOwnerByIndexCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        owner: tuple.0,
                        index: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<tokenOfOwnerByIndexReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: tokenOfOwnerByIndexReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for tokenOfOwnerByIndexReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for tokenOfOwnerByIndexCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "tokenOfOwnerByIndex(address,uint256)";
            const SELECTOR: [u8; 4] = [47u8, 116u8, 92u8, 89u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.owner,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.index),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: tokenOfOwnerByIndexReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: tokenOfOwnerByIndexReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `tokenURI(uint256)` and selector `0xc87b56dd`.
```solidity
function tokenURI(uint256 tokenId) external view returns (string memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct tokenURICall {
        #[allow(missing_docs)]
        pub tokenId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`tokenURI(uint256)`](tokenURICall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct tokenURIReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<tokenURICall> for UnderlyingRustTuple<'_> {
                fn from(value: tokenURICall) -> Self {
                    (value.tokenId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for tokenURICall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { tokenId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<tokenURIReturn> for UnderlyingRustTuple<'_> {
                fn from(value: tokenURIReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for tokenURIReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for tokenURICall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::String;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "tokenURI(uint256)";
            const SELECTOR: [u8; 4] = [200u8, 123u8, 86u8, 221u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.tokenId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: tokenURIReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: tokenURIReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `totalSupply()` and selector `0x18160ddd`.
```solidity
function totalSupply() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct totalSupplyCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`totalSupply()`](totalSupplyCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct totalSupplyReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<totalSupplyCall> for UnderlyingRustTuple<'_> {
                fn from(value: totalSupplyCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for totalSupplyCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<totalSupplyReturn> for UnderlyingRustTuple<'_> {
                fn from(value: totalSupplyReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for totalSupplyReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for totalSupplyCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "totalSupply()";
            const SELECTOR: [u8; 4] = [24u8, 22u8, 13u8, 221u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: totalSupplyReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: totalSupplyReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `transferFrom(address,address,uint256)` and selector `0x23b872dd`.
```solidity
function transferFrom(address from, address to, uint256 tokenId) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferFromCall {
        #[allow(missing_docs)]
        pub from: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub to: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub tokenId: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`transferFrom(address,address,uint256)`](transferFromCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferFromReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferFromCall> for UnderlyingRustTuple<'_> {
                fn from(value: transferFromCall) -> Self {
                    (value.from, value.to, value.tokenId)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for transferFromCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        from: tuple.0,
                        to: tuple.1,
                        tokenId: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferFromReturn> for UnderlyingRustTuple<'_> {
                fn from(value: transferFromReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for transferFromReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl transferFromReturn {
            fn _tokenize(
                &self,
            ) -> <transferFromCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for transferFromCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = transferFromReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "transferFrom(address,address,uint256)";
            const SELECTOR: [u8; 4] = [35u8, 184u8, 114u8, 221u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.from,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.tokenId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                transferFromReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `typeAt(uint256)` and selector `0xb5185a88`.
```solidity
function typeAt(uint256 typeIndex) external view returns (string memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct typeAtCall {
        #[allow(missing_docs)]
        pub typeIndex: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`typeAt(uint256)`](typeAtCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct typeAtReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<typeAtCall> for UnderlyingRustTuple<'_> {
                fn from(value: typeAtCall) -> Self {
                    (value.typeIndex,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for typeAtCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { typeIndex: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<typeAtReturn> for UnderlyingRustTuple<'_> {
                fn from(value: typeAtReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for typeAtReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for typeAtCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::String;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "typeAt(uint256)";
            const SELECTOR: [u8; 4] = [181u8, 24u8, 90u8, 136u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.typeIndex),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: typeAtReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: typeAtReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `typeIndexOf(uint256)` and selector `0x562317c5`.
```solidity
function typeIndexOf(uint256 tokenId) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct typeIndexOfCall {
        #[allow(missing_docs)]
        pub tokenId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`typeIndexOf(uint256)`](typeIndexOfCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct typeIndexOfReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<typeIndexOfCall> for UnderlyingRustTuple<'_> {
                fn from(value: typeIndexOfCall) -> Self {
                    (value.tokenId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for typeIndexOfCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { tokenId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<typeIndexOfReturn> for UnderlyingRustTuple<'_> {
                fn from(value: typeIndexOfReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for typeIndexOfReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for typeIndexOfCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "typeIndexOf(uint256)";
            const SELECTOR: [u8; 4] = [86u8, 35u8, 23u8, 197u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.tokenId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: typeIndexOfReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: typeIndexOfReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `typeOf(uint256)` and selector `0xc588ff8b`.
```solidity
function typeOf(uint256 tokenId) external view returns (string memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct typeOfCall {
        #[allow(missing_docs)]
        pub tokenId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`typeOf(uint256)`](typeOfCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct typeOfReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<typeOfCall> for UnderlyingRustTuple<'_> {
                fn from(value: typeOfCall) -> Self {
                    (value.tokenId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for typeOfCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { tokenId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<typeOfReturn> for UnderlyingRustTuple<'_> {
                fn from(value: typeOfReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for typeOfReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for typeOfCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::String;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "typeOf(uint256)";
            const SELECTOR: [u8; 4] = [197u8, 136u8, 255u8, 139u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.tokenId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: typeOfReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: typeOfReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `updateBaseURI(string)` and selector `0x931688cb`.
```solidity
function updateBaseURI(string memory baseTokenURI) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct updateBaseURICall {
        #[allow(missing_docs)]
        pub baseTokenURI: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`updateBaseURI(string)`](updateBaseURICall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct updateBaseURIReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateBaseURICall> for UnderlyingRustTuple<'_> {
                fn from(value: updateBaseURICall) -> Self {
                    (value.baseTokenURI,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for updateBaseURICall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { baseTokenURI: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateBaseURIReturn> for UnderlyingRustTuple<'_> {
                fn from(value: updateBaseURIReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for updateBaseURIReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl updateBaseURIReturn {
            fn _tokenize(
                &self,
            ) -> <updateBaseURICall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for updateBaseURICall {
            type Parameters<'a> = (alloy::sol_types::sol_data::String,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = updateBaseURIReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "updateBaseURI(string)";
            const SELECTOR: [u8; 4] = [147u8, 22u8, 136u8, 203u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.baseTokenURI,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                updateBaseURIReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`HoprBoost`](self) function calls.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive()]
    pub enum HoprBoostCalls {
        #[allow(missing_docs)]
        DEFAULT_ADMIN_ROLE(DEFAULT_ADMIN_ROLECall),
        #[allow(missing_docs)]
        MINTER_ROLE(MINTER_ROLECall),
        #[allow(missing_docs)]
        approve(approveCall),
        #[allow(missing_docs)]
        balanceOf(balanceOfCall),
        #[allow(missing_docs)]
        batchMint(batchMintCall),
        #[allow(missing_docs)]
        boostOf(boostOfCall),
        #[allow(missing_docs)]
        getApproved(getApprovedCall),
        #[allow(missing_docs)]
        getRoleAdmin(getRoleAdminCall),
        #[allow(missing_docs)]
        getRoleMember(getRoleMemberCall),
        #[allow(missing_docs)]
        getRoleMemberCount(getRoleMemberCountCall),
        #[allow(missing_docs)]
        grantRole(grantRoleCall),
        #[allow(missing_docs)]
        hasRole(hasRoleCall),
        #[allow(missing_docs)]
        isApprovedForAll(isApprovedForAllCall),
        #[allow(missing_docs)]
        mint(mintCall),
        #[allow(missing_docs)]
        name(nameCall),
        #[allow(missing_docs)]
        ownerOf(ownerOfCall),
        #[allow(missing_docs)]
        reclaimErc20Tokens(reclaimErc20TokensCall),
        #[allow(missing_docs)]
        reclaimErc721Tokens(reclaimErc721TokensCall),
        #[allow(missing_docs)]
        renounceRole(renounceRoleCall),
        #[allow(missing_docs)]
        revokeRole(revokeRoleCall),
        #[allow(missing_docs)]
        safeTransferFrom_0(safeTransferFrom_0Call),
        #[allow(missing_docs)]
        safeTransferFrom_1(safeTransferFrom_1Call),
        #[allow(missing_docs)]
        setApprovalForAll(setApprovalForAllCall),
        #[allow(missing_docs)]
        supportsInterface(supportsInterfaceCall),
        #[allow(missing_docs)]
        symbol(symbolCall),
        #[allow(missing_docs)]
        tokenByIndex(tokenByIndexCall),
        #[allow(missing_docs)]
        tokenOfOwnerByIndex(tokenOfOwnerByIndexCall),
        #[allow(missing_docs)]
        tokenURI(tokenURICall),
        #[allow(missing_docs)]
        totalSupply(totalSupplyCall),
        #[allow(missing_docs)]
        transferFrom(transferFromCall),
        #[allow(missing_docs)]
        typeAt(typeAtCall),
        #[allow(missing_docs)]
        typeIndexOf(typeIndexOfCall),
        #[allow(missing_docs)]
        typeOf(typeOfCall),
        #[allow(missing_docs)]
        updateBaseURI(updateBaseURICall),
    }
    #[automatically_derived]
    impl HoprBoostCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [1u8, 255u8, 201u8, 167u8],
            [6u8, 253u8, 222u8, 3u8],
            [8u8, 24u8, 18u8, 252u8],
            [9u8, 94u8, 167u8, 179u8],
            [24u8, 22u8, 13u8, 221u8],
            [35u8, 184u8, 114u8, 221u8],
            [36u8, 138u8, 156u8, 163u8],
            [41u8, 134u8, 125u8, 172u8],
            [47u8, 47u8, 241u8, 93u8],
            [47u8, 116u8, 92u8, 89u8],
            [54u8, 86u8, 138u8, 190u8],
            [66u8, 132u8, 46u8, 14u8],
            [72u8, 198u8, 78u8, 65u8],
            [79u8, 108u8, 204u8, 231u8],
            [86u8, 35u8, 23u8, 197u8],
            [96u8, 103u8, 188u8, 21u8],
            [99u8, 82u8, 33u8, 30u8],
            [112u8, 160u8, 130u8, 49u8],
            [137u8, 108u8, 221u8, 244u8],
            [144u8, 16u8, 208u8, 124u8],
            [145u8, 209u8, 72u8, 84u8],
            [147u8, 22u8, 136u8, 203u8],
            [147u8, 101u8, 197u8, 51u8],
            [149u8, 216u8, 155u8, 65u8],
            [162u8, 23u8, 253u8, 223u8],
            [162u8, 44u8, 180u8, 101u8],
            [181u8, 24u8, 90u8, 136u8],
            [184u8, 141u8, 79u8, 222u8],
            [197u8, 136u8, 255u8, 139u8],
            [200u8, 123u8, 86u8, 221u8],
            [202u8, 21u8, 200u8, 115u8],
            [213u8, 57u8, 19u8, 147u8],
            [213u8, 71u8, 116u8, 31u8],
            [233u8, 133u8, 233u8, 197u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for HoprBoostCalls {
        const NAME: &'static str = "HoprBoostCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 34usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::DEFAULT_ADMIN_ROLE(_) => {
                    <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::MINTER_ROLE(_) => {
                    <MINTER_ROLECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::approve(_) => <approveCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::balanceOf(_) => {
                    <balanceOfCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::batchMint(_) => {
                    <batchMintCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::boostOf(_) => <boostOfCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::getApproved(_) => {
                    <getApprovedCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getRoleAdmin(_) => {
                    <getRoleAdminCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getRoleMember(_) => {
                    <getRoleMemberCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getRoleMemberCount(_) => {
                    <getRoleMemberCountCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::grantRole(_) => {
                    <grantRoleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::hasRole(_) => <hasRoleCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::isApprovedForAll(_) => {
                    <isApprovedForAllCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::mint(_) => <mintCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::name(_) => <nameCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::ownerOf(_) => <ownerOfCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::reclaimErc20Tokens(_) => {
                    <reclaimErc20TokensCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::reclaimErc721Tokens(_) => {
                    <reclaimErc721TokensCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::renounceRole(_) => {
                    <renounceRoleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::revokeRole(_) => {
                    <revokeRoleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::safeTransferFrom_0(_) => {
                    <safeTransferFrom_0Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::safeTransferFrom_1(_) => {
                    <safeTransferFrom_1Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setApprovalForAll(_) => {
                    <setApprovalForAllCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::supportsInterface(_) => {
                    <supportsInterfaceCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::symbol(_) => <symbolCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::tokenByIndex(_) => {
                    <tokenByIndexCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::tokenOfOwnerByIndex(_) => {
                    <tokenOfOwnerByIndexCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::tokenURI(_) => <tokenURICall as alloy_sol_types::SolCall>::SELECTOR,
                Self::totalSupply(_) => {
                    <totalSupplyCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::transferFrom(_) => {
                    <transferFromCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::typeAt(_) => <typeAtCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::typeIndexOf(_) => {
                    <typeIndexOfCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::typeOf(_) => <typeOfCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::updateBaseURI(_) => {
                    <updateBaseURICall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<HoprBoostCalls>] = &[
                {
                    fn supportsInterface(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprBoostCalls::supportsInterface)
                    }
                    supportsInterface
                },
                {
                    fn name(data: &[u8]) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <nameCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(HoprBoostCalls::name)
                    }
                    name
                },
                {
                    fn getApproved(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <getApprovedCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprBoostCalls::getApproved)
                    }
                    getApproved
                },
                {
                    fn approve(data: &[u8]) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <approveCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(HoprBoostCalls::approve)
                    }
                    approve
                },
                {
                    fn totalSupply(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <totalSupplyCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprBoostCalls::totalSupply)
                    }
                    totalSupply
                },
                {
                    fn transferFrom(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <transferFromCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprBoostCalls::transferFrom)
                    }
                    transferFrom
                },
                {
                    fn getRoleAdmin(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <getRoleAdminCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprBoostCalls::getRoleAdmin)
                    }
                    getRoleAdmin
                },
                {
                    fn mint(data: &[u8]) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <mintCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(HoprBoostCalls::mint)
                    }
                    mint
                },
                {
                    fn grantRole(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <grantRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(HoprBoostCalls::grantRole)
                    }
                    grantRole
                },
                {
                    fn tokenOfOwnerByIndex(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <tokenOfOwnerByIndexCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprBoostCalls::tokenOfOwnerByIndex)
                    }
                    tokenOfOwnerByIndex
                },
                {
                    fn renounceRole(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <renounceRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprBoostCalls::renounceRole)
                    }
                    renounceRole
                },
                {
                    fn safeTransferFrom_0(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <safeTransferFrom_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprBoostCalls::safeTransferFrom_0)
                    }
                    safeTransferFrom_0
                },
                {
                    fn reclaimErc721Tokens(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <reclaimErc721TokensCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprBoostCalls::reclaimErc721Tokens)
                    }
                    reclaimErc721Tokens
                },
                {
                    fn tokenByIndex(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <tokenByIndexCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprBoostCalls::tokenByIndex)
                    }
                    tokenByIndex
                },
                {
                    fn typeIndexOf(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <typeIndexOfCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprBoostCalls::typeIndexOf)
                    }
                    typeIndexOf
                },
                {
                    fn reclaimErc20Tokens(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <reclaimErc20TokensCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprBoostCalls::reclaimErc20Tokens)
                    }
                    reclaimErc20Tokens
                },
                {
                    fn ownerOf(data: &[u8]) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <ownerOfCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(HoprBoostCalls::ownerOf)
                    }
                    ownerOf
                },
                {
                    fn balanceOf(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <balanceOfCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(HoprBoostCalls::balanceOf)
                    }
                    balanceOf
                },
                {
                    fn boostOf(data: &[u8]) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <boostOfCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(HoprBoostCalls::boostOf)
                    }
                    boostOf
                },
                {
                    fn getRoleMember(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <getRoleMemberCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprBoostCalls::getRoleMember)
                    }
                    getRoleMember
                },
                {
                    fn hasRole(data: &[u8]) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <hasRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(HoprBoostCalls::hasRole)
                    }
                    hasRole
                },
                {
                    fn updateBaseURI(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <updateBaseURICall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprBoostCalls::updateBaseURI)
                    }
                    updateBaseURI
                },
                {
                    fn batchMint(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <batchMintCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(HoprBoostCalls::batchMint)
                    }
                    batchMint
                },
                {
                    fn symbol(data: &[u8]) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <symbolCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(HoprBoostCalls::symbol)
                    }
                    symbol
                },
                {
                    fn DEFAULT_ADMIN_ROLE(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprBoostCalls::DEFAULT_ADMIN_ROLE)
                    }
                    DEFAULT_ADMIN_ROLE
                },
                {
                    fn setApprovalForAll(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <setApprovalForAllCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprBoostCalls::setApprovalForAll)
                    }
                    setApprovalForAll
                },
                {
                    fn typeAt(data: &[u8]) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <typeAtCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(HoprBoostCalls::typeAt)
                    }
                    typeAt
                },
                {
                    fn safeTransferFrom_1(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <safeTransferFrom_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprBoostCalls::safeTransferFrom_1)
                    }
                    safeTransferFrom_1
                },
                {
                    fn typeOf(data: &[u8]) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <typeOfCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(HoprBoostCalls::typeOf)
                    }
                    typeOf
                },
                {
                    fn tokenURI(data: &[u8]) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <tokenURICall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(HoprBoostCalls::tokenURI)
                    }
                    tokenURI
                },
                {
                    fn getRoleMemberCount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <getRoleMemberCountCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprBoostCalls::getRoleMemberCount)
                    }
                    getRoleMemberCount
                },
                {
                    fn MINTER_ROLE(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <MINTER_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprBoostCalls::MINTER_ROLE)
                    }
                    MINTER_ROLE
                },
                {
                    fn revokeRole(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <revokeRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprBoostCalls::revokeRole)
                    }
                    revokeRole
                },
                {
                    fn isApprovedForAll(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <isApprovedForAllCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HoprBoostCalls::isApprovedForAll)
                    }
                    isApprovedForAll
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data)
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw_validate(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_VALIDATE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<HoprBoostCalls>] = &[
                {
                    fn supportsInterface(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprBoostCalls::supportsInterface)
                    }
                    supportsInterface
                },
                {
                    fn name(data: &[u8]) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <nameCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprBoostCalls::name)
                    }
                    name
                },
                {
                    fn getApproved(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <getApprovedCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprBoostCalls::getApproved)
                    }
                    getApproved
                },
                {
                    fn approve(data: &[u8]) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <approveCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprBoostCalls::approve)
                    }
                    approve
                },
                {
                    fn totalSupply(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <totalSupplyCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprBoostCalls::totalSupply)
                    }
                    totalSupply
                },
                {
                    fn transferFrom(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <transferFromCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprBoostCalls::transferFrom)
                    }
                    transferFrom
                },
                {
                    fn getRoleAdmin(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <getRoleAdminCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprBoostCalls::getRoleAdmin)
                    }
                    getRoleAdmin
                },
                {
                    fn mint(data: &[u8]) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <mintCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprBoostCalls::mint)
                    }
                    mint
                },
                {
                    fn grantRole(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <grantRoleCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprBoostCalls::grantRole)
                    }
                    grantRole
                },
                {
                    fn tokenOfOwnerByIndex(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <tokenOfOwnerByIndexCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprBoostCalls::tokenOfOwnerByIndex)
                    }
                    tokenOfOwnerByIndex
                },
                {
                    fn renounceRole(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <renounceRoleCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprBoostCalls::renounceRole)
                    }
                    renounceRole
                },
                {
                    fn safeTransferFrom_0(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <safeTransferFrom_0Call as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprBoostCalls::safeTransferFrom_0)
                    }
                    safeTransferFrom_0
                },
                {
                    fn reclaimErc721Tokens(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <reclaimErc721TokensCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprBoostCalls::reclaimErc721Tokens)
                    }
                    reclaimErc721Tokens
                },
                {
                    fn tokenByIndex(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <tokenByIndexCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprBoostCalls::tokenByIndex)
                    }
                    tokenByIndex
                },
                {
                    fn typeIndexOf(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <typeIndexOfCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprBoostCalls::typeIndexOf)
                    }
                    typeIndexOf
                },
                {
                    fn reclaimErc20Tokens(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <reclaimErc20TokensCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprBoostCalls::reclaimErc20Tokens)
                    }
                    reclaimErc20Tokens
                },
                {
                    fn ownerOf(data: &[u8]) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <ownerOfCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprBoostCalls::ownerOf)
                    }
                    ownerOf
                },
                {
                    fn balanceOf(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <balanceOfCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprBoostCalls::balanceOf)
                    }
                    balanceOf
                },
                {
                    fn boostOf(data: &[u8]) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <boostOfCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprBoostCalls::boostOf)
                    }
                    boostOf
                },
                {
                    fn getRoleMember(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <getRoleMemberCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprBoostCalls::getRoleMember)
                    }
                    getRoleMember
                },
                {
                    fn hasRole(data: &[u8]) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <hasRoleCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprBoostCalls::hasRole)
                    }
                    hasRole
                },
                {
                    fn updateBaseURI(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <updateBaseURICall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprBoostCalls::updateBaseURI)
                    }
                    updateBaseURI
                },
                {
                    fn batchMint(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <batchMintCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprBoostCalls::batchMint)
                    }
                    batchMint
                },
                {
                    fn symbol(data: &[u8]) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <symbolCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprBoostCalls::symbol)
                    }
                    symbol
                },
                {
                    fn DEFAULT_ADMIN_ROLE(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprBoostCalls::DEFAULT_ADMIN_ROLE)
                    }
                    DEFAULT_ADMIN_ROLE
                },
                {
                    fn setApprovalForAll(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <setApprovalForAllCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprBoostCalls::setApprovalForAll)
                    }
                    setApprovalForAll
                },
                {
                    fn typeAt(data: &[u8]) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <typeAtCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprBoostCalls::typeAt)
                    }
                    typeAt
                },
                {
                    fn safeTransferFrom_1(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <safeTransferFrom_1Call as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprBoostCalls::safeTransferFrom_1)
                    }
                    safeTransferFrom_1
                },
                {
                    fn typeOf(data: &[u8]) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <typeOfCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprBoostCalls::typeOf)
                    }
                    typeOf
                },
                {
                    fn tokenURI(data: &[u8]) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <tokenURICall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprBoostCalls::tokenURI)
                    }
                    tokenURI
                },
                {
                    fn getRoleMemberCount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <getRoleMemberCountCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprBoostCalls::getRoleMemberCount)
                    }
                    getRoleMemberCount
                },
                {
                    fn MINTER_ROLE(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <MINTER_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprBoostCalls::MINTER_ROLE)
                    }
                    MINTER_ROLE
                },
                {
                    fn revokeRole(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <revokeRoleCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprBoostCalls::revokeRole)
                    }
                    revokeRole
                },
                {
                    fn isApprovedForAll(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HoprBoostCalls> {
                        <isApprovedForAllCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HoprBoostCalls::isApprovedForAll)
                    }
                    isApprovedForAll
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_VALIDATE_SHIMS[idx](data)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::DEFAULT_ADMIN_ROLE(inner) => {
                    <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::MINTER_ROLE(inner) => {
                    <MINTER_ROLECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::approve(inner) => {
                    <approveCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::balanceOf(inner) => {
                    <balanceOfCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::batchMint(inner) => {
                    <batchMintCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::boostOf(inner) => {
                    <boostOfCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::getApproved(inner) => {
                    <getApprovedCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getRoleAdmin(inner) => {
                    <getRoleAdminCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getRoleMember(inner) => {
                    <getRoleMemberCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getRoleMemberCount(inner) => {
                    <getRoleMemberCountCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::grantRole(inner) => {
                    <grantRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::hasRole(inner) => {
                    <hasRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::isApprovedForAll(inner) => {
                    <isApprovedForAllCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::mint(inner) => {
                    <mintCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::name(inner) => {
                    <nameCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::ownerOf(inner) => {
                    <ownerOfCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::reclaimErc20Tokens(inner) => {
                    <reclaimErc20TokensCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::reclaimErc721Tokens(inner) => {
                    <reclaimErc721TokensCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::renounceRole(inner) => {
                    <renounceRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::revokeRole(inner) => {
                    <revokeRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::safeTransferFrom_0(inner) => {
                    <safeTransferFrom_0Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::safeTransferFrom_1(inner) => {
                    <safeTransferFrom_1Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setApprovalForAll(inner) => {
                    <setApprovalForAllCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::supportsInterface(inner) => {
                    <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::symbol(inner) => {
                    <symbolCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::tokenByIndex(inner) => {
                    <tokenByIndexCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::tokenOfOwnerByIndex(inner) => {
                    <tokenOfOwnerByIndexCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::tokenURI(inner) => {
                    <tokenURICall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::totalSupply(inner) => {
                    <totalSupplyCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::transferFrom(inner) => {
                    <transferFromCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::typeAt(inner) => {
                    <typeAtCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::typeIndexOf(inner) => {
                    <typeIndexOfCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::typeOf(inner) => {
                    <typeOfCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::updateBaseURI(inner) => {
                    <updateBaseURICall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::DEFAULT_ADMIN_ROLE(inner) => {
                    <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::MINTER_ROLE(inner) => {
                    <MINTER_ROLECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::approve(inner) => {
                    <approveCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::balanceOf(inner) => {
                    <balanceOfCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::batchMint(inner) => {
                    <batchMintCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::boostOf(inner) => {
                    <boostOfCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::getApproved(inner) => {
                    <getApprovedCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getRoleAdmin(inner) => {
                    <getRoleAdminCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getRoleMember(inner) => {
                    <getRoleMemberCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getRoleMemberCount(inner) => {
                    <getRoleMemberCountCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::grantRole(inner) => {
                    <grantRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::hasRole(inner) => {
                    <hasRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::isApprovedForAll(inner) => {
                    <isApprovedForAllCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::mint(inner) => {
                    <mintCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::name(inner) => {
                    <nameCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::ownerOf(inner) => {
                    <ownerOfCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::reclaimErc20Tokens(inner) => {
                    <reclaimErc20TokensCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::reclaimErc721Tokens(inner) => {
                    <reclaimErc721TokensCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::renounceRole(inner) => {
                    <renounceRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::revokeRole(inner) => {
                    <revokeRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::safeTransferFrom_0(inner) => {
                    <safeTransferFrom_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::safeTransferFrom_1(inner) => {
                    <safeTransferFrom_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setApprovalForAll(inner) => {
                    <setApprovalForAllCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::supportsInterface(inner) => {
                    <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::symbol(inner) => {
                    <symbolCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::tokenByIndex(inner) => {
                    <tokenByIndexCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::tokenOfOwnerByIndex(inner) => {
                    <tokenOfOwnerByIndexCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::tokenURI(inner) => {
                    <tokenURICall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::totalSupply(inner) => {
                    <totalSupplyCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::transferFrom(inner) => {
                    <transferFromCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::typeAt(inner) => {
                    <typeAtCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::typeIndexOf(inner) => {
                    <typeIndexOfCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::typeOf(inner) => {
                    <typeOfCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::updateBaseURI(inner) => {
                    <updateBaseURICall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`HoprBoost`](self) events.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub enum HoprBoostEvents {
        #[allow(missing_docs)]
        Approval(Approval),
        #[allow(missing_docs)]
        ApprovalForAll(ApprovalForAll),
        #[allow(missing_docs)]
        BoostMinted(BoostMinted),
        #[allow(missing_docs)]
        RoleAdminChanged(RoleAdminChanged),
        #[allow(missing_docs)]
        RoleGranted(RoleGranted),
        #[allow(missing_docs)]
        RoleRevoked(RoleRevoked),
        #[allow(missing_docs)]
        Transfer(Transfer),
    }
    #[automatically_derived]
    impl HoprBoostEvents {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                23u8, 48u8, 126u8, 171u8, 57u8, 171u8, 97u8, 7u8, 232u8, 137u8, 152u8,
                69u8, 173u8, 61u8, 89u8, 189u8, 150u8, 83u8, 242u8, 0u8, 242u8, 32u8,
                146u8, 4u8, 137u8, 202u8, 43u8, 89u8, 55u8, 105u8, 108u8, 49u8,
            ],
            [
                47u8, 135u8, 136u8, 17u8, 126u8, 126u8, 255u8, 29u8, 130u8, 233u8, 38u8,
                236u8, 121u8, 73u8, 1u8, 209u8, 124u8, 120u8, 2u8, 74u8, 80u8, 39u8, 9u8,
                64u8, 48u8, 69u8, 64u8, 167u8, 51u8, 101u8, 111u8, 13u8,
            ],
            [
                115u8, 94u8, 94u8, 181u8, 175u8, 221u8, 114u8, 204u8, 100u8, 101u8,
                125u8, 237u8, 126u8, 93u8, 227u8, 144u8, 175u8, 55u8, 8u8, 175u8, 181u8,
                185u8, 168u8, 11u8, 14u8, 92u8, 145u8, 26u8, 4u8, 153u8, 217u8, 143u8,
            ],
            [
                140u8, 91u8, 225u8, 229u8, 235u8, 236u8, 125u8, 91u8, 209u8, 79u8, 113u8,
                66u8, 125u8, 30u8, 132u8, 243u8, 221u8, 3u8, 20u8, 192u8, 247u8, 178u8,
                41u8, 30u8, 91u8, 32u8, 10u8, 200u8, 199u8, 195u8, 185u8, 37u8,
            ],
            [
                189u8, 121u8, 184u8, 111u8, 254u8, 10u8, 184u8, 232u8, 119u8, 97u8, 81u8,
                81u8, 66u8, 23u8, 205u8, 124u8, 172u8, 213u8, 44u8, 144u8, 159u8, 102u8,
                71u8, 92u8, 58u8, 244u8, 78u8, 18u8, 159u8, 11u8, 0u8, 255u8,
            ],
            [
                221u8, 242u8, 82u8, 173u8, 27u8, 226u8, 200u8, 155u8, 105u8, 194u8,
                176u8, 104u8, 252u8, 55u8, 141u8, 170u8, 149u8, 43u8, 167u8, 241u8, 99u8,
                196u8, 161u8, 22u8, 40u8, 245u8, 90u8, 77u8, 245u8, 35u8, 179u8, 239u8,
            ],
            [
                246u8, 57u8, 31u8, 92u8, 50u8, 217u8, 198u8, 157u8, 42u8, 71u8, 234u8,
                103u8, 11u8, 68u8, 41u8, 116u8, 181u8, 57u8, 53u8, 209u8, 237u8, 199u8,
                253u8, 100u8, 235u8, 33u8, 224u8, 71u8, 168u8, 57u8, 23u8, 27u8,
            ],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for HoprBoostEvents {
        const NAME: &'static str = "HoprBoostEvents";
        const COUNT: usize = 7usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(<Approval as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Approval as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::Approval)
                }
                Some(<ApprovalForAll as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <ApprovalForAll as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::ApprovalForAll)
                }
                Some(<BoostMinted as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <BoostMinted as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::BoostMinted)
                }
                Some(<RoleAdminChanged as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <RoleAdminChanged as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::RoleAdminChanged)
                }
                Some(<RoleGranted as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <RoleGranted as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::RoleGranted)
                }
                Some(<RoleRevoked as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <RoleRevoked as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::RoleRevoked)
                }
                Some(<Transfer as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Transfer as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::Transfer)
                }
                _ => {
                    alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                        name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                        log: alloy_sol_types::private::Box::new(
                            alloy_sol_types::private::LogData::new_unchecked(
                                topics.to_vec(),
                                data.to_vec().into(),
                            ),
                        ),
                    })
                }
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData for HoprBoostEvents {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::Approval(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::ApprovalForAll(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::BoostMinted(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RoleAdminChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RoleGranted(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RoleRevoked(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Transfer(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::Approval(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::ApprovalForAll(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::BoostMinted(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RoleAdminChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RoleGranted(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RoleRevoked(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Transfer(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`HoprBoost`](self) contract instance.

See the [wrapper's documentation](`HoprBoostInstance`) for more details.*/
    #[inline]
    pub const fn new<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> HoprBoostInstance<P, N> {
        HoprBoostInstance::<P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        newAdmin: alloy::sol_types::private::Address,
        baseTokenURI: alloy::sol_types::private::String,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<HoprBoostInstance<P, N>>,
    > {
        HoprBoostInstance::<P, N>::deploy(provider, newAdmin, baseTokenURI)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        newAdmin: alloy::sol_types::private::Address,
        baseTokenURI: alloy::sol_types::private::String,
    ) -> alloy_contract::RawCallBuilder<P, N> {
        HoprBoostInstance::<P, N>::deploy_builder(provider, newAdmin, baseTokenURI)
    }
    /**A [`HoprBoost`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`HoprBoost`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct HoprBoostInstance<P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network: ::core::marker::PhantomData<N>,
    }
    #[automatically_derived]
    impl<P, N> ::core::fmt::Debug for HoprBoostInstance<P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("HoprBoostInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > HoprBoostInstance<P, N> {
        /**Creates a new wrapper around an on-chain [`HoprBoost`](self) contract instance.

See the [wrapper's documentation](`HoprBoostInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
            newAdmin: alloy::sol_types::private::Address,
            baseTokenURI: alloy::sol_types::private::String,
        ) -> alloy_contract::Result<HoprBoostInstance<P, N>> {
            let call_builder = Self::deploy_builder(provider, newAdmin, baseTokenURI);
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(
            provider: P,
            newAdmin: alloy::sol_types::private::Address,
            baseTokenURI: alloy::sol_types::private::String,
        ) -> alloy_contract::RawCallBuilder<P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                [
                    &BYTECODE[..],
                    &alloy_sol_types::SolConstructor::abi_encode(
                        &constructorCall {
                            newAdmin,
                            baseTokenURI,
                        },
                    )[..],
                ]
                    .concat()
                    .into(),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<P: ::core::clone::Clone, N> HoprBoostInstance<&P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> HoprBoostInstance<P, N> {
            HoprBoostInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > HoprBoostInstance<P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<&P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`DEFAULT_ADMIN_ROLE`] function.
        pub fn DEFAULT_ADMIN_ROLE(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, DEFAULT_ADMIN_ROLECall, N> {
            self.call_builder(&DEFAULT_ADMIN_ROLECall)
        }
        ///Creates a new call builder for the [`MINTER_ROLE`] function.
        pub fn MINTER_ROLE(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, MINTER_ROLECall, N> {
            self.call_builder(&MINTER_ROLECall)
        }
        ///Creates a new call builder for the [`approve`] function.
        pub fn approve(
            &self,
            to: alloy::sol_types::private::Address,
            tokenId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, approveCall, N> {
            self.call_builder(&approveCall { to, tokenId })
        }
        ///Creates a new call builder for the [`balanceOf`] function.
        pub fn balanceOf(
            &self,
            owner: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, balanceOfCall, N> {
            self.call_builder(&balanceOfCall { owner })
        }
        ///Creates a new call builder for the [`batchMint`] function.
        pub fn batchMint(
            &self,
            to: alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
            boostType: alloy::sol_types::private::String,
            boostRank: alloy::sol_types::private::String,
            boostNumerator: alloy::sol_types::private::primitives::aliases::U256,
            redeemDeadline: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, batchMintCall, N> {
            self.call_builder(
                &batchMintCall {
                    to,
                    boostType,
                    boostRank,
                    boostNumerator,
                    redeemDeadline,
                },
            )
        }
        ///Creates a new call builder for the [`boostOf`] function.
        pub fn boostOf(
            &self,
            tokenId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, boostOfCall, N> {
            self.call_builder(&boostOfCall { tokenId })
        }
        ///Creates a new call builder for the [`getApproved`] function.
        pub fn getApproved(
            &self,
            tokenId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, getApprovedCall, N> {
            self.call_builder(&getApprovedCall { tokenId })
        }
        ///Creates a new call builder for the [`getRoleAdmin`] function.
        pub fn getRoleAdmin(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, getRoleAdminCall, N> {
            self.call_builder(&getRoleAdminCall { role })
        }
        ///Creates a new call builder for the [`getRoleMember`] function.
        pub fn getRoleMember(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            index: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, getRoleMemberCall, N> {
            self.call_builder(&getRoleMemberCall { role, index })
        }
        ///Creates a new call builder for the [`getRoleMemberCount`] function.
        pub fn getRoleMemberCount(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, getRoleMemberCountCall, N> {
            self.call_builder(&getRoleMemberCountCall { role })
        }
        ///Creates a new call builder for the [`grantRole`] function.
        pub fn grantRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, grantRoleCall, N> {
            self.call_builder(&grantRoleCall { role, account })
        }
        ///Creates a new call builder for the [`hasRole`] function.
        pub fn hasRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, hasRoleCall, N> {
            self.call_builder(&hasRoleCall { role, account })
        }
        ///Creates a new call builder for the [`isApprovedForAll`] function.
        pub fn isApprovedForAll(
            &self,
            owner: alloy::sol_types::private::Address,
            operator: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, isApprovedForAllCall, N> {
            self.call_builder(
                &isApprovedForAllCall {
                    owner,
                    operator,
                },
            )
        }
        ///Creates a new call builder for the [`mint`] function.
        pub fn mint(
            &self,
            to: alloy::sol_types::private::Address,
            boostType: alloy::sol_types::private::String,
            boostRank: alloy::sol_types::private::String,
            boostNumerator: alloy::sol_types::private::primitives::aliases::U256,
            redeemDeadline: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, mintCall, N> {
            self.call_builder(
                &mintCall {
                    to,
                    boostType,
                    boostRank,
                    boostNumerator,
                    redeemDeadline,
                },
            )
        }
        ///Creates a new call builder for the [`name`] function.
        pub fn name(&self) -> alloy_contract::SolCallBuilder<&P, nameCall, N> {
            self.call_builder(&nameCall)
        }
        ///Creates a new call builder for the [`ownerOf`] function.
        pub fn ownerOf(
            &self,
            tokenId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, ownerOfCall, N> {
            self.call_builder(&ownerOfCall { tokenId })
        }
        ///Creates a new call builder for the [`reclaimErc20Tokens`] function.
        pub fn reclaimErc20Tokens(
            &self,
            tokenAddress: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, reclaimErc20TokensCall, N> {
            self.call_builder(
                &reclaimErc20TokensCall {
                    tokenAddress,
                },
            )
        }
        ///Creates a new call builder for the [`reclaimErc721Tokens`] function.
        pub fn reclaimErc721Tokens(
            &self,
            tokenAddress: alloy::sol_types::private::Address,
            tokenId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, reclaimErc721TokensCall, N> {
            self.call_builder(
                &reclaimErc721TokensCall {
                    tokenAddress,
                    tokenId,
                },
            )
        }
        ///Creates a new call builder for the [`renounceRole`] function.
        pub fn renounceRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, renounceRoleCall, N> {
            self.call_builder(&renounceRoleCall { role, account })
        }
        ///Creates a new call builder for the [`revokeRole`] function.
        pub fn revokeRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, revokeRoleCall, N> {
            self.call_builder(&revokeRoleCall { role, account })
        }
        ///Creates a new call builder for the [`safeTransferFrom_0`] function.
        pub fn safeTransferFrom_0(
            &self,
            from: alloy::sol_types::private::Address,
            to: alloy::sol_types::private::Address,
            tokenId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, safeTransferFrom_0Call, N> {
            self.call_builder(
                &safeTransferFrom_0Call {
                    from,
                    to,
                    tokenId,
                },
            )
        }
        ///Creates a new call builder for the [`safeTransferFrom_1`] function.
        pub fn safeTransferFrom_1(
            &self,
            from: alloy::sol_types::private::Address,
            to: alloy::sol_types::private::Address,
            tokenId: alloy::sol_types::private::primitives::aliases::U256,
            _data: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<&P, safeTransferFrom_1Call, N> {
            self.call_builder(
                &safeTransferFrom_1Call {
                    from,
                    to,
                    tokenId,
                    _data,
                },
            )
        }
        ///Creates a new call builder for the [`setApprovalForAll`] function.
        pub fn setApprovalForAll(
            &self,
            operator: alloy::sol_types::private::Address,
            approved: bool,
        ) -> alloy_contract::SolCallBuilder<&P, setApprovalForAllCall, N> {
            self.call_builder(
                &setApprovalForAllCall {
                    operator,
                    approved,
                },
            )
        }
        ///Creates a new call builder for the [`supportsInterface`] function.
        pub fn supportsInterface(
            &self,
            interfaceId: alloy::sol_types::private::FixedBytes<4>,
        ) -> alloy_contract::SolCallBuilder<&P, supportsInterfaceCall, N> {
            self.call_builder(
                &supportsInterfaceCall {
                    interfaceId,
                },
            )
        }
        ///Creates a new call builder for the [`symbol`] function.
        pub fn symbol(&self) -> alloy_contract::SolCallBuilder<&P, symbolCall, N> {
            self.call_builder(&symbolCall)
        }
        ///Creates a new call builder for the [`tokenByIndex`] function.
        pub fn tokenByIndex(
            &self,
            index: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, tokenByIndexCall, N> {
            self.call_builder(&tokenByIndexCall { index })
        }
        ///Creates a new call builder for the [`tokenOfOwnerByIndex`] function.
        pub fn tokenOfOwnerByIndex(
            &self,
            owner: alloy::sol_types::private::Address,
            index: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, tokenOfOwnerByIndexCall, N> {
            self.call_builder(
                &tokenOfOwnerByIndexCall {
                    owner,
                    index,
                },
            )
        }
        ///Creates a new call builder for the [`tokenURI`] function.
        pub fn tokenURI(
            &self,
            tokenId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, tokenURICall, N> {
            self.call_builder(&tokenURICall { tokenId })
        }
        ///Creates a new call builder for the [`totalSupply`] function.
        pub fn totalSupply(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, totalSupplyCall, N> {
            self.call_builder(&totalSupplyCall)
        }
        ///Creates a new call builder for the [`transferFrom`] function.
        pub fn transferFrom(
            &self,
            from: alloy::sol_types::private::Address,
            to: alloy::sol_types::private::Address,
            tokenId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, transferFromCall, N> {
            self.call_builder(
                &transferFromCall {
                    from,
                    to,
                    tokenId,
                },
            )
        }
        ///Creates a new call builder for the [`typeAt`] function.
        pub fn typeAt(
            &self,
            typeIndex: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, typeAtCall, N> {
            self.call_builder(&typeAtCall { typeIndex })
        }
        ///Creates a new call builder for the [`typeIndexOf`] function.
        pub fn typeIndexOf(
            &self,
            tokenId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, typeIndexOfCall, N> {
            self.call_builder(&typeIndexOfCall { tokenId })
        }
        ///Creates a new call builder for the [`typeOf`] function.
        pub fn typeOf(
            &self,
            tokenId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, typeOfCall, N> {
            self.call_builder(&typeOfCall { tokenId })
        }
        ///Creates a new call builder for the [`updateBaseURI`] function.
        pub fn updateBaseURI(
            &self,
            baseTokenURI: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<&P, updateBaseURICall, N> {
            self.call_builder(&updateBaseURICall { baseTokenURI })
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > HoprBoostInstance<P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<&P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        ///Creates a new event filter for the [`Approval`] event.
        pub fn Approval_filter(&self) -> alloy_contract::Event<&P, Approval, N> {
            self.event_filter::<Approval>()
        }
        ///Creates a new event filter for the [`ApprovalForAll`] event.
        pub fn ApprovalForAll_filter(
            &self,
        ) -> alloy_contract::Event<&P, ApprovalForAll, N> {
            self.event_filter::<ApprovalForAll>()
        }
        ///Creates a new event filter for the [`BoostMinted`] event.
        pub fn BoostMinted_filter(&self) -> alloy_contract::Event<&P, BoostMinted, N> {
            self.event_filter::<BoostMinted>()
        }
        ///Creates a new event filter for the [`RoleAdminChanged`] event.
        pub fn RoleAdminChanged_filter(
            &self,
        ) -> alloy_contract::Event<&P, RoleAdminChanged, N> {
            self.event_filter::<RoleAdminChanged>()
        }
        ///Creates a new event filter for the [`RoleGranted`] event.
        pub fn RoleGranted_filter(&self) -> alloy_contract::Event<&P, RoleGranted, N> {
            self.event_filter::<RoleGranted>()
        }
        ///Creates a new event filter for the [`RoleRevoked`] event.
        pub fn RoleRevoked_filter(&self) -> alloy_contract::Event<&P, RoleRevoked, N> {
            self.event_filter::<RoleRevoked>()
        }
        ///Creates a new event filter for the [`Transfer`] event.
        pub fn Transfer_filter(&self) -> alloy_contract::Event<&P, Transfer, N> {
            self.event_filter::<Transfer>()
        }
    }
}
