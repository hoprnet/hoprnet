\subsection{On-chain Commitment}

HOPR uses a commitment scheme to deposit values on-chain and reveal them once a node redeems an incentive for relaying packets. This comes with the benefit that the redeeming party discloses a secret that is unknown to the issuer of the incentive until it is claimed on-chain. The $\textbf{opening}$ $\mathsf{Open}$ and the $\textbf{response}$ $r$ to the PoR challenge (or as we call them in the smart contract \textit{nextCommitment} and \textit{proofOfRelaySecret}) are then used by the smart contract to determine whether the ticket has been redeemed or not.

\begin{defnsub}
    % Currently leaving out further details such as unconditionally/computationally binding / hiding
    A commitment scheme $\mathsf{C_m} = (\mathsf{Commit}, \mathsf{Open})$ is a protocol between two parties, $A$ and $B$, that gives $A$ the opportunity to store a value $comm = \mathsf{Commit}(x)$ at $B$. The value $x$ stays unknown to $B$ until $A$ decides to reveal it to $B$.
    Such that for any $m\in \mathbb{M}$, $(c,d)\leftarrow \mathsf{Commit(m)}$ is the commitment/opening pair for $m$ where $c = c(m)$ serves as the commitment value, and $d = d(m)$ as the opening value.
    \\~\\ \noindent\textbf{Hiding:} A commitment scheme is called \textbf{computational hiding} if the following holds:
    $$\forall \;x\neq x' \; \{\mathsf{Commit}_k(x,U_k)\}_{k\in\mathbb{N}}\approx\{{\mathsf{Commit}_k(x',U_k)}\}_{k\in\mathbb{N}}$$ which means both probability ensembles are computationally indistinguashable such that $U_{k}$ is the uniform distribution over the $2^{k}$ opening values for the security parameter $k$.
    \\~\\\noindent\textbf{Binding:} A commitment scheme is called \textbf{computational binding} if for all bounded polynomial adversary \textit{Adv} algorithms that run in time $t$ and output $x,x',open,open'$ the following holds:
    $$P	[ \,x\neq x' \; and \; \mathsf{Commit}(x,open)={\mathsf{Commit}(x',open')}] \,\leq \epsilon$$ A Computationally bounded adversary means that the adversary has limitations on their computational resources. 

\end{defnsub}

\subsubsection{Commitment phase}

Once a node is the destination of a HOPR unidirectional channel, it derives a master key $comm_0$ from its private key and uses it to create an iterated commitment $comm_i$ such that for every $i \in \mathbb{N}_0$ and $i > 0$ it holds that $$ \mathsf{Open}(comm_{i}, comm_{i-1}) = \top $$
which means opening $comm_{i}$ with $comm_{i-1}$ holds true.
The iterated commitment is computed as $$comm_n = h^n(comm_0)$$ where $h$ is a preimage-resistant hash function (we use keccak256 hash function which is used in Ethereum) and $comm_0$ is derived as 
$$ comm_0 = \mathsf{h}(privKey,chainId, contractAddr, channelId, channelEpoch)$$
The master key is supposed to be pseudo-random such that all intermediate commitments $comm_{i}$ for $i \in \mathbb{N}_0$ and $0 < i \le n$ are indistinguishable for the ticket issuer from random numbers of the same length. This is necessary in order to ensure that the ticket issuer is unable to determine whether a ticket is a win or not when issuing the ticket. This makes it infeasible for the ticket issuer to tweak the challenge to such that it cannot be a win.
\\~\\When dispatching a transaction that opens the payment channel, the commitment $comm_n$ is stored in the channel structure in the smart contract and the smart contract will force the ticket recipient to reveal $comm_{n-1}$ when redeeming a ticket issued in this channel.
The number of iterations $n$ can be chosen as a constant and should reflect the number of tickets a node intends to redeem within a channel.

\subsubsection{Opening phase}

In order to redeem a ticket, a node has to reveal the opening to the current commitment $comm_i$ that is stored in the smart contract for the channel. Since the opening $comm_{i-1}$ allows the ticket issuer to determine whether a ticket is going to be a win, the ticket recipient should keep $comm_{i-1}$ until it is used to redeem a ticket.
Tickets lead to a win if: $$\mathsf{h}( t_h, r_i, comm_{i-1} ) < P_w$$ where $P_w$ is the ticket's winning probability and $$t_h=\mathsf{h}(t) \;and\; \mathsf{Open}(comm_i, comm_{i-1}) = \top$$ Since $comm_{0}$ is known to the ticket recipient, the ticket recipient can compute the opening as $comm_{n-1} = \mathsf{h}^{n-1}(comm_0)$.
Once redeeming a ticket, the smart contract verifies that $$\mathsf{Open}(comm_i, comm_{i-1}) = \top$$ and sets $channel.comm[redeemer] \leftarrow comm_{i-1}$. Hence next time, the node redeems a ticket, it has to reveal $comm_{i-2}$.
In addition, each node is granted the right to reset the commitment to a new value which is necessary especially once a node reveals $comm_0$ and therefore is with high probability unable to compute a value $r$ such that $$\mathsf{Open}(comm_0,r) \neq \bot$$ where $\bot$ represents the truth value "false".
\\~\\Since this mechanism can be abused by the ticket recipient to tweak the entropy that is used to determine whether a ticket is a win or not, the smart contract keeps track on resets of the on-chain commitment and sets $$channel.ticketEpoch[redeemer] \leftarrow channel.ticketEpoch[redeemer] +1$$  and thereby invalidates all previously unredeemed tickets.


