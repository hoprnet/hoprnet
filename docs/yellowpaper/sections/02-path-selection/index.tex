\section{Path Selection}
\label{sec:path-selection}
HOPR currently utilizes free-route sender-selected paths which are known to provide better privacy than other topologies, as well as better packet delivery in the event of partial network failure \cite{Dingledine2004SynchronousBF}. HOPR makes it easy to customize various different routing strategies. In this section, we present the free-routing strategy that HOPR nodes are currently following. Another strategy is later introduced in the \lcnameref{sec:CT} section.

\subsection{Objectives and Approach}
A packet in the HOPR network is sent via multiple mix node hops before it is delivered to its final recipient. A sender has to consider three partially antagonistic points when selecting a path

\begin{enumerate}
    \item selected nodes should be effective at mixing packets
    \item path selection must not be deterministic
    \item offline nodes should be avoided
\end{enumerate}

As anyone can run a node in the HOPR network, it is also important to have neutral Schelling points for effective mix nodes. The default path selection mechanism uses the number of tokens that a node has staked in a particular payment channel as a signal for how much traffic the node is willing to relay in a fashion that aligns its incentives with the rest of the network. Thus, stake is used as a Schelling point for which nodes will mix packets more effectively than others with lower traffic.

To meet HOPR's stated \lcnameref{sec:securitygoals}, it is crucial for nodes in the network to keep the chosen path secret. While the individual nodes along a path are selected, based on their stake, a node's individual path selection must remain hard to predict for third parties in order to provide sender-receipient unlinkability. HOPR achieves that by randomizing channel stake by multiplying its stake with a random number.

In order to keep sender-receiver packet loss low, the sender only chooses nodes that it considers to be online. The path selection mechanism uses a heartbeat mechanism for this.



\subsection{Randomization Stake as Edge Weights}
The path selection algorithm outlined below uses edge weights that determine likelihood of randomly choosing a specific edge. The edge weights are initialized with the payment channel balance and the payment channel topology. The more tokens a node stakes to an outgoing payment channel, the more likely the edge is selected on a path, hence the more likely the connected nodes are chosen as relayers by other nodes.

Since this initialization step based on channel stake is entirely deterministic and potential adversaries could thus deduce the path of an individual packet from public information, each node score is randomized by multiplying it with a random number, $0 \le r_i \le 1$. Over long time scales, the expectation value of the weight is still proportional to the channels's score and thus provides a predictable Schelling point.

$$ weight(n_i) := balance(n_i) * r_i$$

Note that the random numbers are assigned once at the beginning of the process and reassigned upon the selection of a subsequent packet.


\subsection{Heartbeat}
HOPR nodes use a heartbeat mechanism to estimate the availability of nodes in the network. Nodes keep scores of each other that measure their health. They utilize a exponential backoff to efficiently measure health scores.

\subsubsection{Health Score}
Each node keeps a score of all other nodes and increases that score if it has been observed online and decreases if it could not be reached. Each node that has an funded outgoing payment channel is initially listed with $healthScore = 0.2$. Responding to a \textit{ping} with a \textit{pong} packet or sending its own \textit{ping} increases a node's score by 0.1. Not responding to a \textit{ping} reduces the node's score by 0.1. The minimal node score is 0 and the maximal score is 1. Nodes with a $healthScore \ge healthThreshold$ considered online and utilized in paths, nodes with lower scores are omitted. The default $healthThreshold$ is $0.5$.

\subsubsection{Exponential Backoff}
Since the network status can change abruptly, e.g., due to electricity outages or unstable network links, availability needs to be measured frequently on an ongoing basis. On the other hand, it does not make sense to constantly probe nodes that are known to be offline. To provide a dynamic trade-off for both cases, HOPR utilizes a heartbeat with exponential backoff, the time until the next \textit{ping} is sent to a node increases with the number of failed ping attempts $n_{fail}$ since the last sucessful attempt or the network start. A successful response to \textit{ping} resets the backoff timer.

$$ t_{bo} = {t_{base}}^{{f_{bo}}^{n_{fail}}} $$

where $t_{bo}$ is the backoff time, $t_{base} = 2s$ is the initial backoff time and $f_{bo} = 1.5$.

The maximal backoff time of 512 seconds corresponds to $n_{fail} = 5$.



\subsection{Path selection}
\label{sec:path-selection:graph-traversal}

The HOPR network uses source-selected routing. This means a node must sample the entire path the mixnet packet will take before sending it to the first relayer.

To achieve the aforementioned privacy guarantees, paths must include at least one intermediate node. However, using the Sphinx packet format (see Section \ref{sec:sphinx}) increases both the size of the header and the computation needed to generate it, which makes it possible for adversaries to distinguish packets on longer paths. Therefore, all nodes in the HOPR network are strongly encouraged to use a $targetLength$ of three. Packets with longer paths are dropped by relayers. It is possible but discouraged for nodes to use paths of one or two hops.

Nodes can only be chosen once per path. For example, when choosing the third node in the path $A\rightarrow B$, if $A$ is found to be the only node with an open channel to $B$, the search will fail and a new path will be generated.

The algorithm terminates once a path with $targetLength$ is found. To prevent the algorithm from visiting too many nodes, the number of iterations is bound by $maxIterations$ and the longest known path is returned if no path of length $targetLength$ was found.

The default path selection algorithm is a best-first search of edges which got initialized with randomized payment channels stakes as outlined above. It omits paths that would contain loops and nodes with $healthScore < healthThreshold$ and paths that would be shorter than $targetLength$.

\begin{algorithm}[H]
    \SetAlgoNoLine
    \DontPrintSemicolon
    \KwIn{$\text{nodes} \ V, \text{edges} \ E$}
    \;
    $queue \leftarrow \mathbf{new} \ \mathsf{PriorityQueue}_{\textsf{pathWeight}}()$\;
    $queue.addAll(\{ (x,y) \in E \ | \ x = self)$\;
    $closed \leftarrow \emptyset$\;
    $iterations \leftarrow 0$\;
    \;
    \While{$size(queue) > 0 \ \mathsf{and} \ iterations < maxIterations$}{
        $path \leftarrow queue.peek()$\;
        \If{$length(path) = targetLength$}{
            \Return{$path$}
        }
        \;
        $current \leftarrow last(path)$\;
        $open \leftarrow \emptyset$\;
        \;
        \ForEach{$next \in \{ y \in V \ | \ (x,y) \in E \ \land \ x = current \}$}{
            \If{$healthScore(next) \ge healthThreshold \ \mathbf{and} \ y \notin closed \ \mathbf{and} \ y \notin path$}{
                $open.push(y)$\;
            }
        }
        \;
        \uIf{$size(open) = 0$} {
            $queue.pop()$\;
            $closed.add(current)$\;
        }
        \Else{
            \ForEach{$node \in open$}{
                $queue.push(\ (...path, node) \ )$\;
            }
        }
        \;
        $iterations \leftarrow iterations + 1$\;
    }
    \Return{$queue.peek()$}
    \caption{Path selection}
\end{algorithm}
