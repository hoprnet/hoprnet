\section{Path Selection}
\label{sec:pathselection}

To send packets through the HOPR network, each node must
decide which path a packet is sent via. This decision, called
\textbf{path selection}, must be performed for every packet. HOPR uses a
random selection algorithm to determine the identities of nodes participating in
the network relaying service, both generally and for each particular packet.
\\~\\The selection process is divided into two steps:

\begin{enumerate}

    \item \textbf{Pre-Selection:}
          Initially, a subset $m<<n$ nodes will be selected based on the following factors:
          \begin{itemize}
              \item Node availability
              \item Payment channel graph
              \item Payment channel stake
          \end{itemize}
          Each node receives a weight that is proportional to these factors.

    \item \textbf{Random Selection:} Each edge (from node $A$ to $B$) within the subset
          $m$ is assigned a random number $r_i$. Edges are then sorted by
          $$r_i*weight(edge_i).$$ The path with the largest weight is extended next,
          using a priority queue mechanism.

\end{enumerate}

An edge that is sorted first can either be originated from a high $r_i$ assigned to that node \textit{or} a high weight computed as aforementioned including \textbf{availability}, \textbf{payment channel graph} or \textbf{stake}. This makes sure that neither nodes with high $r_i$ nor nodes with higher score are first, hence the score rather depends equally on the rating based on \textit{availabilty}, the \textit{payment channel graph}, the nodes's \textit{stake} and on the assigned $r_i$.

\begin{algorithm}[H]
    \SetAlgoNoLine
    \DontPrintSemicolon
    $V := Nodes$\;
    $M := MaxSelectionIterations$\;
    $A := MinNodeAvailability$\;
    $P := RequiredPathLength$\;
    \;
    $openChannels \leftarrow \{ (x, y) \in V \times V \ | \ x \ne y \land getChannel(x,y).state = OPEN \}$\;
    $queue \leftarrow new \ PriorityQueue()$\;
    $queue.addAll(\{ (x,y) \in openChannels \ | \ x = self \})$\;
    $deadEnds \leftarrow \emptyset$\;
    $iterations \leftarrow 0$\;
    \;
    \While{$!queue.isEmpty() \land iterations < M$}{
        $current \leftarrow queue.peek()$\;
        \If{$|current| = P$}{
            \Return{$current$}
        }
        \;
        $currentNode \leftarrow lastNode(current)$\;
        $open \leftarrow \{ (x, y) \in E \ | \ x = currentNode \land y \notin deadEnds \land y \ne currentNode \land availability(y) > A$ \}\;
        $open \leftarrow open.sort(weight_fun)$\;
        \;
        \eIf{$open = \emptyset$} {
            $queue.pop()$\;
            $deadEnds \leftarrow deadEnds \cup currentNode$\;
        } {
            $newPath \leftarrow \{ (current_0, ..., current_{|current| - 1}, o) \ | \ o \in open \})$\;
            $queue.push(newPath)$\;
        }
        \;
        $iterations \leftarrow iterations + 1$\;
    }
    \Return{$\bot$}
    \caption{Path selection in HOPR}
\end{algorithm}

\subsection{Node Availability}
\label{sec:nodeavailability}

Node availability is estimated using a heartbeat protocol. Each node maintains a
list of its neighbouring nodes within the network. A node will \textit{ping} neighbours and
respond to \textit{pings} from other nodes to determine whether they are online or offline.
A node is considered online if the ping response (``pong‚Äù) returns within a
certain timeframe. Otherwise, the node is considered offline and the waiting
time before the next ping attempt to that node is doubled. Newly working pings will gladually improve a
neighbour's availability score.

\subsection{Payment channel graph}

Every node that intends to send messages needs to have a basic understanding
about the topology of the network, meanings whether a payment channel to the node is open and
funded with sufficient HOPR tokens for the relaying service. If no such
payment channel exists, the sender creates a new channel and funds it with
sufficient HOPR tokens.

\subsection{Payment channel stake}

As payment channels are opened with other nodes, HOPR tokens are staked in those channels and therefore the network as a whole. Nodes use these HOPR
tokens to cover transaction costs when interacting with the blockchain. The higher
the stake a node has locked, the higher probability that it will be chosen as a relayer.
