\section{Path Selection}
\label{sec:path-selection}

Packets in the HOPR network are sent via multiple \textit{hops} before they are delivered to the final destination. To achieve its privacy properties, it is crucial for nodes in the network to keep the chosen path secret. As relay nodes differ in their ability to forward packets, path choices need to incorporate the nodes' resources and cannot be chosen entirely at random.
\\Path selection is therefore done in multiple steps: first, there is a pre-selection based on the node resources which gives a subgraph of the network. Afterwards each node is assigned a randomly generated number. Aggretating both values, network quality and the random number, gives the edge weight that is used to sample a path.

\begin{enumerate}
    \item \textbf{Pre-select} nodes according to node quality yielding a subgraph of the network
    \item \textbf{Randomize} the edge weights of the subgraph
    \item \textbf{Find} a path in the subgraph using a graph traversal algorithm
\end{enumerate}

\subsection{Pre-selection}
\label{sec:pathselection:pre-selection}

Nodes in the network suffer from various problems, including unclear availability due to transport problems as well as outdated information. Once a packet makes it into the receive buffer of the next hop, it needs to be processed which involves non-negligible computation and can lead to congestion on that node.
\\As relay nodes in the network get compensated for their work, there need to be an edge in the payment channel graph that has enough stake to cover the costs for the packets.
\\Last but not least, nodes \textit{can} exclude certain nodes due to past bad behavior or other preferences.
\\The outcome is a subgraph $G = (V, E)$ where $V$ is a subset of all nodes $V_{all}$ in the network and $E$ including all possible edges between the nodes as determined by the payment channel graph.

\subsection{Randomization}
\label{sec:pathselection:randomization}

Since the previous step is entirely deterministic and potential adversaries can thus deduct the outcome from public information, each edge weight gets randomized by multplying it with a random number $r_{i,j}$.
$$weight(e_{i,j}) := quality(e_{i,j}) * r_{i,j}$$.

\subsection{Graph traversal}
\label{sec:pathselection:graph-traversal}

The HOPR network uses source-selected routing, hence each node needs to sample the entire path that the mixnet packet is going to take before sending it to the first relayer.
\\To achieve the aforementioned privacy guarantees, paths should include a minimum number of intermediate node and to make all interactions look the same towards an adversary, \textit{most} of the paths should have the same length. Conversely, the maximum path length is fixed to $pathLength$ due to the usage of the SPHINX packet format, see section \ref{sec:sphinx}, and longer paths lead to larger packet headers which can be easily perceived by a potential adversary.
\\As a result of the previous pre-selection, the final path sampling can run on disconnected subgraphs that do not lead to a sufficiently long path. Since the algorithm might take too long in these cases to terminate, the number of iterations is limited by ${maxIteraions}$. Analogously, nodes that often lead to dead ends are excluded from further node expansions.

\begin{algorithm}[H]
    \SetAlgoNoLine
    \DontPrintSemicolon
    $queue \leftarrow \mathbf{new} \ \mathsf{PriorityQueue}_{\textsf{pathWeight}}()$\;
    $queue.addAll((x,y) \in E)$\;
    $deadEnds \leftarrow \emptyset$\;
    $iterations \leftarrow 0$\;
    \;
    \While{$size(queue) > 0 \ \mathsf{and} \ iterations < maxIterations$}{
    $path \leftarrow queue.peek()$\;
    \If{$length(path) = pathLength$}{
        \Return{$current$}
    }
    \;
    $current \leftarrow last(path)$\;

    $open \leftarrow \mathbf{new} \ \mathsf{PriorityQueue}_{\mathsf{edgeWeight}}()$\;

    \ForEach{$ (x,y) \in E$}{
        \If{$x = current \ \mathbf{and} \ y \notin deadEnds$}{
            $open.push(y)$\;
        }
    }
    \;
    \eIf{$size(open) = 0$} {
        $queue.pop()$\;
        $deadEnds \leftarrow deadEnds \cup current$\;
    } {
        \ForEach{$node \in open$)}{
            $queue.push(\ (...path, node) \ )$\;
        }
    }
    \;
    $iterations \leftarrow iterations + 1$\;
    }
    \caption{Path selection}
\end{algorithm}

\subsection{WIP: Node Availability}
\label{sec:nodeavailability}

Node availability is estimated using a heartbeat protocol. Each node maintains a
list of its neighbouring nodes within the network. A node will \textit{ping} neighbours and
respond to \textit{pings} from other nodes to determine whether they are online or offline.
A node is considered online if the ping response (``pong”) returns within a
certain timeframe. Otherwise, the node is considered offline and the waiting
time before the next ping attempt to that node is doubled. Newly working pings will gladually improve a
neighbour's availability score.

\subsection{WIP: Payment channel graph}

Every node that intends to send messages needs to have a basic understanding
about the topology of the network, meanings whether a payment channel to the node is open and
funded with sufficient HOPR tokens for the relaying service. If no such
payment channel exists, the sender creates a new channel and funds it with
sufficient HOPR tokens.

\subsection{WIP: Payment channel stake}

As payment channels are opened with other nodes, HOPR tokens are staked in those channels and therefore the network as a whole. Nodes use these HOPR
tokens to cover transaction costs when interacting with the blockchain. The higher
the stake a node has locked, the higher probability that it will be chosen as a relayer.
